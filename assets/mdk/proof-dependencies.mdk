Colorizer     : dafnyx

Heading Depth: 0

Css Header:
  body.madoko {
    max-width: 100%;
    margin: 0;
    padding: 0;
  }
  .page-content {
    padding: 0;
  }

# Introduction

A verified program is only as good as its specification. If the properties you want to prove about your program are contradictory, any program will satisfy them. If the properties you want to prove don't cover all of the program's behavior, any implementation will satisfy the uncovered portions. Specification problems of these sort result in verification that is technically sound, but that may provide a false sense of security that the program behaves as intended.

As of version TODO, Dafny now includes features to detect problems of this sort, using a notion of _proof dependency_. A proof dependency is a portion of a program that needed to be taken into account in order to construct a proof that the program is correct.

If it's possible to prove a program correct without taking the final proof goal (_e.g._, `assert` statement or `ensures` clause) into account, that goal must have been proven using contradictory assumptions or infeasible branches in the program. Contradictory specifications are particularly easy to construct by accident when writing assumed specifications about external or yet-to-be-written code. Consider the following example.

<!-- inline-dafny vacuous/Vacuous -->

Here, the `Find` method has a roughly reasonable-looking (if incomplete) specification. However, it turns out that the `ensures` clause is always false if `start` and `end` are the same or adjacent indices, and `CallFind` passes in adjacent indices. Therefore, it's possible to prove a false assertion after the call.

Proof dependencies can also identify unspecified portions of an implementation. If it's possible to prove a program correct without taking into account certain implementation statements, then those statements are unconstrained by the verification. They could be changed arbitrarily without causing verification to fail. In the following example of a binary search implementation, Dafny verifies only the absence of undefined behavior. In particular, it doesn't prove that the return value is reasonable. Therefore, any of the return statements could be replaced with essentially anything without resulting in a verification failure.

<!-- inline-dafny unspecified/BinarySearch -->

As a final example, proof dependency analysis can also detect preconditions, assumptions, or intermediate assertions that are unnecessary for constructing a proof of correctness. These redundant specifications may indicate a mistake, such that they would not be redundant if written correctly. Or it may be possible to remove them, simplifying the program and proof process. In the following example, the precondition (which one might think would be required to make the code well-defined) turns out to be unnecessary.

<!-- inline-dafny redundant/BinarySearch -->

# Proof dependencies in Dafny

Three new flags to the `dafny verify` command enable proof dependency calculation.

The `--warn-contradictory-assumptions` flag instructs Dafny will emit a warning any time it completes a proof without taking the goal into account, indicating a dependence on contradictory assumptions.

<img class="clickable" id="img-vacuous-warning" src="/blog/assets/images/proof-dependencies/vacuous-warning.png" alt="Warnings emitted by Dafny on an example of a vacuous proof" style="display:block;margin-left:auto;margin-right:auto;width:1126px;max-width:95%;"/>

The `--warn-redundant-assumptions` flag instructs Dafny will emit a warning any time an assumption in scope (from an `assume` statement or `requires` clause) was not required to complete any proof goal.

<img class="clickable" id="img-redundant-warning" src="/blog/assets/images/proof-dependencies/redundant-warning.png" alt="Warnings emitted by Dafny on an example of a proof with a redundant requires clause" style="display:block;margin-left:auto;margin-right:auto;width:1301px;max-width:95%;"/>

These options can be enabled in the IDE, as well. We recommend doing this in a `dfyconfig.toml` file such as the following:

```
[options]
warn-redundant-assumptions = true
warn-contradictory-assumptions = true
```

With this in place, the example of contradictory assumptions shown above looks something like the following in Visual Studio Code:

<img class="clickable" id="img-vacuous-vscode" src="/blog/assets/images/proof-dependencies/vacuous-vscode.png" alt="Visual Studio Code warnings  on an example of a vacuous proof" style="display:block;margin-left:auto;margin-right:auto;width:1121px;max-width:95%;"/>

To identify portions of a program that were not included in verification currently requires a slightly more manual step. Consider the unspecified version of binary search again.

<!-- inline-dafny unspecified/BinarySearch -->

Dafny includes a verification logger that will describe the status of and statistics about each verification goal in the program. When proof dependency analysis is enabled, this will include information about which potential proof dependencies did or did not take place in the actual proof. This information will only be included if one of the other flags enabling proof dependency analysis is enabled, however. So, if we analyze the binary search example using the command
`dafny verify --log-format text --warn-redundant-assertions`, the output will include the following text.

```
    Unused by proof:
      unspecified.dfy(4,14)-(4,28): assignment (or return)
      unspecified.dfy(4,14)-(4,28): assignment (or return)
      unspecified.dfy(6,15)-(6,34): loop invariant
      unspecified.dfy(10,7)-(10,16): assignment (or return)
      unspecified.dfy(14,7)-(14,17): assignment (or return)
      unspecified.dfy(17,3)-(17,12): assignment (or return)
      unspecified.dfy(18,1)-(18,1): out-parameter 'r', which is subject to definite-assignment rules, is always initialized at this return point
```

This shows that the assignment/return statements on lines 10, 14, and 17, for example, were not necessary to show that the method is well-defined.


Enabling proof dependency calculation requires additional work as part of the proof process. This means it can slow down verification, and potentially cause especially brittle proofs to fail. In our experiments so far, it can add ~30% to verification time. If your project is developed with the feature turned on from the start, however, this cost can be mitigated, especially when taking verification optimization guidance into account.

# Theory and implementation

Internally, the analysis is build on the common SMT feature of _unsatisfiable cores_. Dafny encodes each verification goal as an SMT query that negates the original goal. This means that a conclusion that the negated goal is unsatisfiable (_i.e._, no value exists that will make it true) means that the original goal is valid (_i.e._, true for all possible values). Many SMT solvers, including the Z3 solver that Dafny uses by default, can accompany a conclusion of UNSAT with a subset of the sub-expressions (clauses, in SMT terminology) from the original goal that is still unsatisfiable. This subset is generally smaller than the original formula, though it is not guaranteed to be so, and is not guaranteed to be minimal.
