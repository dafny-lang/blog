<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html
        xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
    <link rel="stylesheet" href="./.resources/coverage.css" type="text/css"/>
    <title>chessWithQuantifiers.dfy, Expected Test Coverage</title>
</head>
<body onload="window['PR_TAB_WIDTH']=4">
<div class="menu" id="menu">
    <a href="./index_tests_expected.html">Index</a>
    
</div>
<h1>chessWithQuantifiers.dfy, Expected Test Coverage</h1>
<h1 hidden>/Users/fedchina/Desktop/blog/assets/src/test-generation/chessWithQuantifiers.dfy</h1>
<pre class="source lang-java linenums">
<span class="na" id="1:1">module Chess {
  datatype Color = Black | White
  datatype Kind = Knight(c: Color) | King(c: Color) | Pawn(c: Color)
  datatype Pos = Pos(row: int, col: int)
  type ChessPos = pos: Pos | // in this declaration, "|" means "such that" 
    && 0 <= pos.row < 8
    && 0 <= pos.col < 8 witness Pos(0, 0) // "witness" proves that the type is nonempty

  datatype Piece = Piece(kind: Kind, at: ChessPos) {
    predicate {:testInline} Threatens(pos: ChessPos) {
</span><span class="pc" id="11:1">      && at != pos
</span><span class="fc" id="12:1">      && match this.kind {
</span><span class="na" id="13:1">        case Knight(c) =>
</span><span class="fc" id="14:1">          || ( && abs(pos.col - at.col) == 2
              && abs(pos.row - at.row) == 1)
          || ( && abs(pos.col - at.col) == 1
              && abs(pos.row - at.row) == 2)
</span><span class="nc" id="18:1">        case King(c) => abs(pos.col - at.col) < 2 && abs(pos.row - at.row) < 2
</span><span class="na" id="19:1">        case Pawn(c) =>
</span><span class="pc" id="20:1">          && pos.row == at.row + (if c.White? then -1 else 1)
</span><span class="fc" id="21:1">          && (pos.col == at.col + 1 || pos.col == at.col - 1)
      }
</span><span class="na" id="23:1">    }
  }
  function abs(n: int): nat { if n > 0 then n else -n }

  datatype Board = Board(pieces: seq<Piece>) 
  predicate BoardIsValid(board: Board) { // No two pieces on a single square
    forall i: nat, j: nat :: 
      0 <= i < j < |board.pieces| ==> 
      board.pieces[i].at != board.pieces[j].at
  }
  type ValidBoard = board: Board | BoardIsValid(board) witness Board([])

  predicate {:testInline} CheckedByPlayer(board: ValidBoard, king: Piece, byPlayer: Color) {
</span><span class="fc" id="36:1">    || CheckedByPiece(board, king, Knight(byPlayer)) 
    || CheckedByPiece(board, king, Pawn(byPlayer))
</span><span class="na" id="38:1">  }

  predicate {:testInline} CheckedByPiece(board: ValidBoard, king: Piece, byPiece: Kind) {
    exists i: int :: 
      && 0 <= i < |board.pieces| 
      && board.pieces[i].kind == byPiece 
      && board.pieces[i].Threatens(king.at)
</span><span class="fc" id="45:1">  } by method {
    for i := 0 to |board.pieces| 
</span><span class="na" id="47:1">      invariant !CheckedByPiece(Board(board.pieces[..i]), king, byPiece)
    {
</span><span class="fc" id="49:1">      if board.pieces[i].kind == byPiece && 
         board.pieces[i].Threatens(king.at) {
        return true;
</span><span class="na" id="52:1">      }
    }
</span><span class="fc" id="54:1">    return false;
</span><span class="na" id="55:1">  } 

  predicate CheckmatedByPlayer(board: ValidBoard, king: Piece, byPlayer: Color) {
    && (king.at.row == 0 || king.at.col == 7 || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row - 1, king.at.col + 1)), byPlayer))
    && (                    king.at.col == 7 || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row,     king.at.col + 1)), byPlayer))
    && (king.at.row == 7 || king.at.col == 7 || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row + 1, king.at.col + 1)), byPlayer))
    && (king.at.row == 0                     || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row - 1, king.at.col)),     byPlayer))   
    &&                                          CheckedByPlayer(board, king, byPlayer)     
    && (king.at.row == 7                     || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row + 1, king.at.col)),     byPlayer))
    && (king.at.row == 0 || king.at.col == 0 || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row - 1, king.at.col - 1)), byPlayer))
    && (                 || king.at.col == 0 || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row,     king.at.col - 1)), byPlayer))
    && (king.at.row == 7 || king.at.col == 0 || CheckedByPlayer(board, Piece(king.kind, Pos(king.at.row + 1, king.at.col - 1)), byPlayer))
  }

  predicate BoardPreset(board: Board) {
    && |board.pieces| == 5
    && board.pieces[0].kind == King(White) 
    && board.pieces[1].kind == Knight(Black) && board.pieces[2].kind == Knight(Black)
    && board.pieces[3].kind == Pawn(Black)   && board.pieces[4].kind == Pawn(Black)
  }

  // {:testEntry} tells Dafny to use this method as an entry point
  method {:testEntry} Describe(board: ValidBoard) 
    requires BoardPreset(board)
</span><span class="fc" id="79:1">  {
    var whiteKing := board.pieces[0];
    if CheckedByPlayer(board, whiteKing, Black) {
      print "White king is in check\n";
</span><span class="na" id="83:1">    } else {
</span><span class="fc" id="84:1">      print "White king is safe\n";
</span><span class="na" id="85:1">    }
</span><span class="fc" id="86:1">    if CheckmatedByPlayer(board, whiteKing, Black) {
</span><span class="na" id="87:1">      expect CheckedByPlayer(board, whiteKing, Black);
</span><span class="fc" id="88:1">      print "It is checkmate for white\n";
</span><span class="na" id="89:1">    } else {
</span><span class="fc" id="90:1">      print "No checkmate yet\n"; 
</span><span class="na" id="91:1">    }
</span><span class="fc" id="92:1">    SerializeToSVG(board);
  }

</span><span class="na" id="95:1">  method SerializeToSVG(board:Board) {
    var scale:int := 30; // default size of one square in pixels
    print "<svg width=\"",  scale * 8, 
            "\" height=\"", scale * 8, 
            "\" xmlns=\"http://www.w3.org/2000/svg\">";
    for row := 0 to 8 {
      for col := 0 to 8 {
        var pos:ChessPos := Pos(row, col);
        var image := "assets/" + if (col + row) % 2 == 0 then "light_square" else "dark_square";
        for n := 0 to |board.pieces| {
          if board.pieces[n].at != pos {
            continue;
          }
          image := image + "_" +
            (match board.pieces[n].kind.c {
              case White => "white" 
              case Black => "black"})
            + "_" + 
            (match board.pieces[n].kind {
              case King(_) => "king"
              case Knight(_) => "knight"
              case Pawn(_) => "pawn"
            });
        }
        print "\n<image x=\"",      col*scale, 
                    "\" y=\"",      row*scale, 
                    "\" width=\"",  scale,
                    "\" height=\"", scale,
                    "\" href=\"",   image,
              ".svg\" />";
      }
      print "\n";
    }
    print "</svg>\n\n";
  }
}
</span></pre>
<div class="footer">
    <span class="right">
        Created with 
        <a href="https://github.com/dafny-lang/dafny">Dafny</a>
    </span>
</div>
</body>
</html>