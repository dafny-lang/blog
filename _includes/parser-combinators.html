<style>
  /* Styles for the interactive demo */
  .demo-container {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    margin: 20px 0;
    background-color: #f9f9f9;
  }

  .input-area {
    width: 100%;
    height: 1em;
    font-family: monospace;
    margin-bottom: 10px;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .output-area {
    width: 100%;
    min-height: 100px;
    font-family: monospace;
    background-color: #f0f0f0;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-top: 10px;
    white-space: pre-wrap;
  }

  /* Preserve whitespace in parser output spans */
  [id$="-parsed"],
  [id$="-remaining"] {
    white-space: pre-wrap;
  }

  .error-display {
    color: #d9534f;
    margin-top: 10px;
    font-family: monospace;
  }

  .controls {
    margin: 10px 0;
  }

  button {
    background-color: #337ab7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
  }

  button:hover {
    background-color: #286090;
  }

  /* Example button styles */
  .example-buttons {
    margin: 10px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .example-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-family: monospace;
  }

  .example-btn.positive {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }

  .example-btn.positive:hover {
    background-color: #c3e6cb;
  }

  .example-btn.negative {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }

  .example-btn.negative:hover {
    background-color: #f5c6cb;
  }
</style>

<script>
  function setInput(inputId, value) {
    // Set the input value
    document.getElementById(inputId).value = value;
    
    // Find the corresponding parse button by replacing '-input' with '-parse-button'
    const parseButtonId = inputId.replace('-input', '-parse-button');
    const parseButton = document.getElementById(parseButtonId);
    
    if (parseButton) {
      // Trigger the parse button click
      parseButton.click();
    } else {
      console.warn('Parse button not found for input:', inputId, 'Expected button ID:', parseButtonId);
    }
  }
</script>

<script>
  function setInput(inputId, value) {
    document.getElementById(inputId).value = value;
    // Trigger the parser automatically after setting the input
    const parseButtonId = inputId.replace('-input', '-parse-button');
    const parseButton = document.getElementById(parseButtonId);
    if (parseButton) {
      parseButton.click();
    }
  }
</script>

<script>
  function setInput(inputId, value) {
    document.getElementById(inputId).value = value;
    // Trigger the parser if there's a parse button
    const parseButtonId = inputId.replace('-input', '-parse-button');
    const parseButton = document.getElementById(parseButtonId);
    if (parseButton) {
      parseButton.click();
    }
  }
</script>

<h2>Introduction</h2>

<p>
  Parser combinators are a powerful technique for building parsers by composing smaller parsing functions.
  They provide a clean, modular approach to parsing that aligns well with functional programming principles.
  In this blog post, we'll explore Dafny's standard parser combinators library and demonstrate how to use it
  to build a formatter for S-expressions (symbolic expressions), which are the foundation of languages like LISP.
  We'll include an interactive JavaScript demo that you can use to experiment with the formatter directly in your
  browser.
</p>

<h2>Parser Builders DSL in Dafny</h2>

<p>
  Parser combinators are higher-order functions that accept parsers as input and return new parsers as output.
  This approach allows you to build complex parsers by combining simpler ones. Dafny's standard library provides
  a concise Domain-Specific Language (DSL) for building parsers that uses minimal syntax to make complex parser
  definitions more readable.
</p>

<p>
  To use the parser builders DSL in Dafny, you need to import:
</p>

<pre><code>import opened Std.Parsers.StringBuilders</code></pre>

<p>
  This gives you access to a set of short, expressive combinators that reduce syntactic noise and highlight the parser
  logic.
  Some of the most commonly used combinators in this DSL include:
</p>

<ul>
  <li><code>S</code>: Creates a parser that matches a specific string</li>
  <li><code>CharTest</code>: Creates a parser that succeeds if the input character satisfies a given predicate</li>
  <li><code>Rep</code>: Applies a parser zero or more times</li>
  <li><code>Rep1</code>: Applies a parser one or more times (at least once)</li>
  <li><code>O</code>: Tries each parser in sequence until one succeeds (Or)</li>
  <li><code>I_I</code>: Concatenates two parsers, keeping both results (Concat)</li>
  <li><code>e_I</code>: Concatenates two parsers, discarding the left result</li>
  <li><code>I_e</code>: Concatenates two parsers, discarding the right result</li>
  <li><code>M</code>: Transforms the result of a parser (Map)</li>
  <li><code>Rec</code>: Creates a recursive parser</li>
</ul>

<h2>Interactive Parser Examples</h2>

<p>
  Before diving into the full S-expression parser, let's explore some basic parser components and see how they work
  individually. Each parser has an <code>Apply</code> method that takes an input string and returns a
  <code>ParseResult</code>:
</p>

<pre><code>datatype ParseResult&lt;T&gt; = 
  | ParseSuccess(result: T, remaining: Input)
  | ParseFailure(level: FailureLevel, data: FailureData)</code></pre>

<p>
  When a parser succeeds, it returns the parsed value and the remaining unconsumed characters. When it fails, it returns
  an error message and the position where parsing failed.
  Each example below includes an interactive demo where you can test the parser with your own input.
</p>

<h3>Building Parsers Step by Step</h3>

<p>
  Let's build up to the S-expression parser by starting with the most fundamental building blocks and gradually
  combining them into more complex parsers.
</p>

<h4>Character Testing (CharTest) - Parsing Anger</h4>

<p>
  The <code>CharTest</code> combinator is the foundation of most parsers. It takes a predicate function and succeeds if
  the next character satisfies that condition. Let's start with something fun - parsing anger characters!
</p>

<pre><code class="parser-definition">const AngerParser := CharTest(c => c == 'ğŸ˜ ' || c == 'ğŸ˜¡' || c == 'ğŸ¤¬' || c == 'ğŸ˜¤', "anger")</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive" onclick="setInput('anger-input', 'ğŸ˜  I am angry!')">ğŸ˜  I am angry!</button>
    <button class="example-btn positive" onclick="setInput('anger-input', 'ğŸ˜¡Hello')">ğŸ˜¡Hello</button>
    <button class="example-btn positive" onclick="setInput('anger-input', 'ğŸ¤¬!!!')">ğŸ¤¬!!!</button>
    <button class="example-btn positive" onclick="setInput('anger-input', 'ğŸ˜¤ Huffing!')">ğŸ˜¤ Huffing!</button>
    <button class="example-btn negative" onclick="setInput('anger-input', 'ğŸ˜€ Happy')">ğŸ˜€ Happy</button>
    <button class="example-btn negative" onclick="setInput('anger-input', 'No emoji')">No emoji</button>
  </div>

  <textarea id="anger-input" class="input-area" placeholder="ğŸ˜  I am angry!">ğŸ˜  I am angry!</textarea>

  <div class="output-container">
    <div>
      <button id="anger-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="anger-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="anger-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Repetition (Rep) - Parsing Joy</h4>

<p>
  The <code>Rep</code> combinator applies a parser zero or more times. Let's use it to parse sequences of joyful
  characters:
</p>

<pre><code class="parser-definition">const JoyParser := CharTest(c => c == 'ğŸ˜€' || c == 'ğŸ˜ƒ' || c == 'ğŸ˜„' || c == 'ğŸ˜' || c == 'ğŸ¥³', "joy").Rep()</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive" onclick="setInput('joy-input', 'ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!')">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</button>
    <button class="example-btn positive" onclick="setInput('joy-input', 'ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So happy!')">ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So
      happy!</button>
    <button class="example-btn positive" onclick="setInput('joy-input', 'No joy here')">No joy here</button>
    <button class="example-btn negative" onclick="setInput('joy-input', 'ğŸ˜ ğŸ˜¡ Angry')">ğŸ˜ ğŸ˜¡ Angry</button>
  </div>

  <textarea id="joy-input" class="input-area" placeholder="ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</textarea>

  <div class="output-container">
    <div>
      <button id="joy-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="joy-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="joy-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Mapping (M) - Joy Score Calculator</h4>

<p>
  The <code>M</code> combinator transforms the result of a parser. Let's create a joy score calculator that gives 2
  points for each joyful character:
</p>

<pre><code class="parser-definition">const JoyScoreParser := CharTest(c => c == 'ğŸ˜€' || c == 'ğŸ˜ƒ' || c == 'ğŸ˜„' || c == 'ğŸ˜' || c == 'ğŸ¥³', "joy").Rep().M(joyString => |joyString| * 2)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive" onclick="setInput('joyscore-input', 'ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!')">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day! (6
      points)</button>
    <button class="example-btn positive" onclick="setInput('joyscore-input', 'ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So happy!')">ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So
      happy! (10 points)</button>
    <button class="example-btn positive" onclick="setInput('joyscore-input', 'No joy here')">No joy here (0
      points)</button>
    <button class="example-btn negative" onclick="setInput('joyscore-input', 'ğŸ˜ ğŸ˜¡ Angry')">ğŸ˜ ğŸ˜¡ Angry (0
      points)</button>
  </div>

  <textarea id="joyscore-input" class="input-area" placeholder="ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</textarea>

  <div class="output-container">
    <div>
      <button id="joyscore-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="joyscore-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="joyscore-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Whitespace Parser (WS)</h4>

<p>
  Now we can understand how the built-in <code>WS</code> parser works - it's actually defined using
  <code>CharTest</code> and <code>Rep</code>:
</p>

<pre><code class="parser-definition">// WS is roughly equivalent to:
// CharTest(c => c == ' ' || c == '\t' || c == '\n' || c == '\r', "whitespace").Rep()
const WSParser := WS</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter some text with whitespace at the beginning</p>
  <textarea id="ws-input" class="input-area" placeholder="   Hello world">   Hello world</textarea>

  <div class="output-container">
    <div>
      <button id="ws-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="ws-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="ws-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Identifier Parser</h4>

<p>
  Let's build an identifier parser that will be crucial for S-expressions. An identifier starts with a letter and can
  contain letters, digits, and some special characters:
</p>

<pre><code class="parser-definition">const IdentifierParser := CharTest(c => 'a' <= c <= 'z' || 'A' <= c <= 'Z', "letter").Rep1()</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter identifiers like "factorial", "list-length", "+"</p>
  <textarea id="identifier-input" class="input-area" placeholder="factorial">factorial</textarea>

  <div class="output-container">
    <div>
      <button id="identifier-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="identifier-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="identifier-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Concatenation - Building S-Expression Structure</h4>

<p>
  Now let's use concatenation to start building the structure we need for S-expressions. The concatenation operators
  combine parsers in sequence:
</p>
<ul>
  <li><code>I_I</code>: Keeps both results</li>
  <li><code>I_e</code>: Keeps only the left result</li>
  <li><code>e_I</code>: Keeps only the right result</li>
</ul>

<p>
  Let's build a parser that recognizes the start of an S-expression: an opening parenthesis followed by an identifier
  (like "(define" or "(lambda"):
</p>

<pre><code class="parser-definition">// Parse "(" followed by an identifier - the start of an S-expression!
const SExprStart_I_I := S("(").I_I(IdentifierParser)

// Just keep the identifier, discard the "("
const SExprStart_e_I := S("(").e_I(IdentifierParser)

// Just keep the "(", discard the identifier  
const SExprStart_I_e := S("(").I_e(IdentifierParser)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter S-expression starts like "(define", "(lambda", "(list"</p>
  <textarea id="concat-input" class="input-area" placeholder="(define">(define</textarea>

  <div class="controls">
    <select id="concat-type">
      <option value="SExprStart_I_I">I_I (both "(" and identifier)</option>
      <option value="SExprStart_e_I">e_I (just identifier)</option>
      <option value="SExprStart_I_e">I_e (just "(")</option>
    </select>
  </div>

  <div class="output-container">
    <div>
      <button id="concat-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="concat-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="concat-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Choice (O) - Anger or Joy</h4>

<p>
  The <code>O</code> (choice) operator tries each parser in sequence until one succeeds. Let's combine our anger and joy
  parsers to parse any emotional emoji:
</p>

<pre><code class="parser-definition">const EmotionParser := O([AngerParser, CharTest(c => c == 'ğŸ˜€' || c == 'ğŸ˜ƒ' || c == 'ğŸ˜„' || c == 'ğŸ˜' || c == 'ğŸ¥³', "joy")])</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ˜  Angry!')">ğŸ˜  Angry!</button>
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ˜ƒ Happy!')">ğŸ˜ƒ Happy!</button>
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ¤¬ Furious!')">ğŸ¤¬ Furious!</button>
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ¥³ Party!')">ğŸ¥³ Party!</button>
    <button class="example-btn negative" onclick="setInput('emotion-input', 'ğŸ˜ Neutral')">ğŸ˜ Neutral</button>
    <button class="example-btn negative" onclick="setInput('emotion-input', 'No emoji')">No emoji</button>
  </div>

  <textarea id="emotion-input" class="input-area" placeholder="ğŸ˜  Angry!">ğŸ˜  Angry!</textarea>

  <div class="output-container">
    <div>
      <button id="emotion-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="emotion-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="emotion-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Putting It Together</h4>

<p>
  Now we have all the building blocks for S-expressions! We can parse:
</p>
<ul>
  <li><strong>Atoms</strong>: identifiers and numbers</li>
  <li><strong>List starts</strong>: "(" followed by an identifier</li>
  <li><strong>Whitespace</strong>: to separate elements</li>
  <li><strong>Repetition</strong>: to handle multiple elements</li>
</ul>

<p>
  The full S-expression parser combines all these concepts using recursion to handle nested structures. Let's see how it
  all comes together!
</p>

<h2>S-Expressions</h2>

<p>
  Now that we understand the basic parsers, let's see how we can combine them to build a more complex parser.
  We'll create a parser for S-expressions, which will demonstrate how the individual parser components we've explored
  can work together to handle a recursive, nested structure.
</p>

<p>
  S-expressions (symbolic expressions) are a notation for representing nested data structures, originally used in the
  LISP programming language.
  They have a simple syntax: an S-expression is either an atom (like a symbol or number) or a list of S-expressions
  enclosed in parentheses.
  Here's a simple example of an S-expression:
</p>

<pre><code>(define (factorial n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))</code></pre>

<p>
  In this blog post, we'll build a parser and formatter for S-expressions, including:
</p>

<ul>
  <li>Atoms (identifiers like <code>factorial</code>, <code>n</code>)</li>
  <li>Numbers (integers like <code>0</code>, <code>1</code>)</li>
  <li>Lists (like <code>(define (factorial n) ...)</code>)</li>
</ul>

<h2>Building an S-Expression Parser</h2>

<p>
  Let's look at how we can build an S-expression parser using Dafny's parser combinators. The parser will handle both
  atoms and nested expressions.
</p>

<p>
  First, we'll define our data structure for S-expressions:
</p>

<pre><code>module ExampleParsers.SExprParser {
  import opened Std.Parsers.StringBuilders

  datatype SExpr =
    | Atom(name: string)
    | List(items: seq&lt;SExpr&gt;)
}</code></pre>

<p>
  Next, we'll define a parser for whitespace and comments:
</p>

<pre><code>  // Parse whitespace and comments
  const WSOrComment := 
    WS.I_I(
      S(";").I_I(CharTest((c: char) => c != '\n', "anything except newline").Rep())
      .I_I(O([S("\n"), EOS.M(x => "")])).Rep()
    )</code></pre>

<p>
  Now, let's define the main parser for S-expressions. This is where the power of parser combinators really shines:
</p>

<pre><code>  // Parse an S-expression
  const parserSExpr := 
    Rec((SExpr: B&lt;SExpr&gt;) =>
      O([
        // Either a list: (expr1 expr2 ...)
        S("(").e_I(WSOrComment).Then(
          (r: string) =>
            SExpr.I_e(WSOrComment)
            .Rep().I_e(S(")")).I_e(WSOrComment)
        ).M((r: seq&lt;SExpr&gt;) => List(r)),
        
        // Or an atom: symbol
        CharTest((c: char) => c != '(' && c != ')' && !isWhitespace(c), "atom character")
        .Rep1().M((r: string) => Atom(r)).I_e(WSOrComment)
      ])
    )</code></pre>

<p>
  This parser uses the <code>Rec</code> combinator to create a recursive parser that can handle nested expressions.
  The parser first tries to match a list (expressions enclosed in parentheses) and if that fails, it tries to match an
  atom.
</p>

<p>
  We can also add a method to format S-expressions nicely:
</p>

<pre><code>  function ToString(expr: SExpr, indent: string := ""): string {
    match expr {
      case Atom(name) => name
      case List(items) =>
        if |items| == 0 then
          "()"
        else
          "(" + 
          String.Join(
            seq(|items|, i requires 0 <= i < |items| => 
              if i == 0 then ToString(items[i], indent + "  ")
              else "\n" + indent + "  " + ToString(items[i], indent + "  ")
            ),
            ""
          ) + ")"
    }
  }</code></pre>

<p>
  The formatting function above uses a recursive approach to pretty-print S-expressions. Here's how it works:
</p>

<ul>
  <li>For atoms, it simply returns the name of the atom.</li>
  <li>For empty lists, it returns "()".</li>
  <li>For non-empty lists, it formats the first item on the same line as the opening parenthesis, and each subsequent
    item on a new line with proper indentation.</li>
  <li>The indentation increases by two spaces for each level of nesting, making the structure clear and readable.</li>
  <li>The function uses Dafny's sequence comprehension to build the formatted string for each item in the list.</li>
</ul>

<p>
  This formatting approach is particularly useful for complex, nested S-expressions, as it makes the structure visually
  apparent.
</p>

<p>
  Finally, we can add a test method to verify our parser works correctly:
</p>

<pre><code>  method TestParser() {
    var input := "(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))";
    var result := parserSExpr.Apply(input);
    
    match result {
      case ParseSuccess(value, _) =>
        print "Parsed successfully: ", ToString(value), "\n";
      case ParseFailure(error, _) =>
        print "Parse error: ", error, "\n";
    }
  }</code></pre>

<h2>Interactive Demo</h2>

<p>
  Below is an interactive demo where you can enter S-expressions and see them parsed and formatted:
</p>

<div class="demo-container">
  <textarea id="input-area" class="input-area"
    placeholder="Enter an S-expression here, e.g., (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"></textarea>

  <div class="controls">
    <button id="parse-button">Parse & Format</button>
    <label>
      <input type="checkbox" id="pretty-print" checked> Pretty Print
    </label>
    <select id="example-select">
      <option value="">-- Select Example --</option>
      <option value="(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))">Factorial Function</option>
      <option value="(let ((x 5) (y 10)) (+ x y))">Let Binding</option>
      <option value="(lambda (x) (* x x))">Lambda Function</option>
      <option value="(list 1 2 3 4 5)">Simple List</option>
    </select>
  </div>

  <div id="output-area" class="output-area">Formatted output will appear here</div>
  <div id="error-display" class="error-display"></div>
</div>

<!-- Load the required libraries and Dafny-compiled JavaScript -->
<script src="/blog/assets/js/bignumber.js"></script>
<script>
  // Mock require() function for browser compatibility
  window.require = function (module) {
    switch (module) {
      case 'bignumber.js':
        return window.BigNumber;
      case 'buffer':
        return { Buffer: window.Buffer || {} };
      case 'fs':
        return {};
      case 'path':
        return {};
      case 'process':
        return { argv: [] };
      default:
        console.warn('Unhandled require() call for module:', module);
        return {};
    }
  };
  window.process = {
    argv: [],
    stdout: {
      write: console.log
    }
  };
</script>
<script src="/blog/assets/js/parsers/parsers-combined.js"></script>
<script src="/blog/assets/js/parsers/parser-integration.js"></script>
</script>

<h2>Conclusion</h2>

<p>
  In this blog post, we've introduced Dafny's parser combinators library and demonstrated how to use it to build
  a parser and formatter for S-expressions. We've also shown how to compile Dafny code to JavaScript and integrate
  it into a web page to create an interactive demo.
</p>

<p>
  Parser combinators provide a powerful, modular approach to parsing that aligns well with functional programming
  principles.
  By using Dafny's standard library, you can leverage these techniques in your own projects, whether you're targeting
  JavaScript, C#, or other supported platforms.
</p>

<p>
  For more information on Dafny's standard libraries, including the parser combinators library, check out the
  <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyStandardLibraries">Dafny Standard Libraries
    repository</a>.
</p>