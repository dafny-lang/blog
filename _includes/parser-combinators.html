<style>
  /* Styles for the interactive demo */
  .demo-container {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    margin: 20px 0;
    background-color: #f9f9f9;
  }

  .input-area {
    width: 100%;
    min-height: 2em;
    font-family: monospace;
    margin-bottom: 10px;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    resize: vertical;
    overflow-y: hidden;
  }

  .output-area {
    width: 100%;
    min-height: 100px;
    font-family: monospace;
    background-color: #f0f0f0;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-top: 10px;
    white-space: pre-wrap;
    transition: border-color 0.3s ease;
  }

  .output-area.parsing {
    border-color: #337ab7;
    animation: parsing-pulse 1.5s ease-in-out infinite;
  }

  @keyframes parsing-pulse {
    0%, 100% {
      border-color: #337ab7;
      box-shadow: 0 0 0 0 rgba(51, 122, 183, 0.4);
    }
    50% {
      border-color: #286090;
      box-shadow: 0 0 0 4px rgba(51, 122, 183, 0.1);
    }
  }

  /* Preserve whitespace in parser output spans */
  [id$="-parsed"],
  [id$="-remaining"] {
    white-space: pre-wrap;
  }

  .error-display {
    color: #d9534f;
    margin-top: 10px;
    font-family: monospace;
  }

  .controls {
    margin: 10px 0;
  }

  button {
    background-color: #337ab7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
  }

  button:hover {
    background-color: #286090;
  }

  /* Hide parse buttons for live parsing */
  button[id$="-parse-button"],
  button[id="parse-button"] {
    display: none;
  }

  /* Example button styles */
  .example-buttons {
    margin: 10px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .example-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-family: monospace;
  }

  .example-btn.positive {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }

  .example-btn.positive:hover {
    background-color: #c3e6cb;
  }

  .example-btn.negative {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }

  .example-btn.negative:hover {
    background-color: #f5c6cb;
  }
</style>

<script>
  // Auto-resize textarea function
  function autoResize(textarea) {
    textarea.style.height = 'auto';
    textarea.style.height = Math.max(textarea.scrollHeight, 40) + 'px';
  }

  // Debounce function for live parsing
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  document.addEventListener('DOMContentLoaded', function () {
    // Initialize auto-resize and live parsing for all textareas
    document.querySelectorAll('textarea.input-area').forEach(textarea => {
      // Initial resize
      autoResize(textarea);

      // Auto-resize on input
      textarea.addEventListener('input', function () {
        autoResize(this);

        // Find associated parse button and trigger parsing
        const container = this.closest('.demo-container');
        if (container) {
          const parseButton = container.querySelector('button[id$="-parse-button"], button[id="parse-button"]');
          if (parseButton) {
            // Debounced parsing for performance
            const debouncedParse = debounce(() => parseButton.click(), 300);
            debouncedParse();
          }
        }
      });
    });

    // Initialize all example buttons
    document.querySelectorAll('.example-btn').forEach(button => {
      button.addEventListener('click', function () {
        // Check if this is an S-expression demo button (has data-example attribute)
        if (this.hasAttribute('data-example')) {
          const inputArea = document.getElementById('input-area');
          const parseButton = document.getElementById('parse-button');

          if (inputArea && parseButton) {
            // Set the input value to the example
            inputArea.value = this.getAttribute('data-example');
            // Auto-resize the textarea
            autoResize(inputArea);
            // Trigger the parse button to format immediately
            parseButton.click();
          }
          return;
        }

        // Handle building block demo buttons (existing logic)
        const demoContainer = this.closest('.demo-container');
        if (!demoContainer) {
          console.warn('Demo container not found for button:', this);
          return;
        }

        const input = demoContainer.querySelector('textarea.input-area, input.input-area');
        const parseButton = demoContainer.querySelector('button[id$="-parse-button"]');

        if (input && parseButton) {
          // Set the input value to the button's text content
          input.value = this.textContent;
          // Auto-resize if it's a textarea
          if (input.tagName === 'TEXTAREA') {
            autoResize(input);
          }
          // Trigger the parse button
          parseButton.click();
        } else {
          console.warn('Input or parse button not found in container:', {
            input: !!input,
            parseButton: !!parseButton,
            container: demoContainer
          });
        }
      });
    });
  });
</script>





<h2>Why Parser Combinators Matter</h2>

<p>
  Imagine you need to parse and format complex nested structures like this LISP factorial function:
</p>

<pre><code>(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))</code></pre>

<p>
  Most parsing approaches would require hundreds of lines of complex, error-prone code. But with parser combinators, you
  can build an elegant, working parser in just a few dozen lines. Even better - it compiles to JavaScript and runs in
  your browser!
</p>

<h2>Interactive S-Expression Formatter</h2>

<p>
  Try it yourself! Enter any S-expression below and watch it get parsed and beautifully formatted:
</p>

<div class="demo-container">
  <textarea id="input-area" class="input-area"
    placeholder="Enter an S-expression here, e.g., (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"></textarea>

  <div class="controls">
    <button id="parse-button">Parse & Format</button>
  </div>

  <div class="example-buttons">
    <button class="example-btn positive"
      data-example="(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))">Factorial Function</button>
    <button class="example-btn positive" data-example="(let ((x 5) (y 10)) (+ x y))">Let Binding</button>
    <button class="example-btn positive" data-example="(lambda (x) (* x x))">Lambda Function</button>
    <button class="example-btn positive" data-example="(list 1 2 3 4 5)">Simple List</button>
    <button class="example-btn positive" data-example="(if (> x 0) (+ x 1) (- x 1))">Conditional</button>
    <button class="example-btn positive" data-example="(map (lambda (x) (* x x)) (list 1 2 3 4))">Higher-Order
      Function</button>
    <button class="example-btn positive" data-example="; Fibonacci with comments
(define (fib n)
; Base cases
(if (<= n 1)
n
; Recursive case
(+ (fib (- n 1)) (fib (- n 2)))))">With Comments</button>
  </div>

  <div id="output-area" class="output-area">Formatted output will appear here</div>
  <div id="error-display" class="error-display"></div>
</div>

<p>
  This formatter handles nested structures, proper indentation, and error reporting - all built from simple, composable pieces (21 lines of parser combinators + 42 lines of datatypes and helpers). How is this possible? Let's explore the building blocks.
</p>

<h2>Parser Combinators: Building Complex from Simple</h2>

<p>
  Parser combinators are higher-order functions that accept parsers as input and return new parsers as output.
  This approach allows you to build complex parsers by combining simpler ones. Dafny's standard library provides
  a concise Domain-Specific Language (DSL) for building parsers that uses minimal syntax to make complex parser
  definitions more readable.
</p>

<p>
  To use the parser builders DSL in Dafny, you need to import:
</p>

<pre><code>import opened Std.Parsers.StringBuilders</code></pre>

<p>
  This gives you access to a set of short, expressive combinators that reduce syntactic noise and highlight the parser
  logic. Let's see how these simple pieces combine to create the powerful formatter above.
</p>


<h2>The Building Blocks</h2>

<p>
  Let's explore the fundamental parser components that make the S-expression formatter possible. Each parser has an
  <code>Apply</code> method that takes an input string and returns a <code>ParseResult</code>:
</p>

<pre><code>datatype ParseResult&lt;T&gt; = 
  | ParseSuccess(result: T, remaining: Input)
  | ParseFailure(level: FailureLevel, data: FailureData)</code></pre>

<p>
  When a parser succeeds, it returns the parsed value and the remaining unconsumed characters. When it fails, it returns
  an error message and the position where parsing failed. Each example below includes an interactive demo where you can
  experiment with the parser.
</p>

<h4>Character Testing (CharTest) - Parsing Anger</h4>

<p>
  The <code>CharTest</code> combinator is the foundation of most parsers. It takes a predicate function and succeeds if
  the next character satisfies that condition. Let's start with something fun - parsing anger characters!
</p>

<pre><code class="parser-definition">const AngerParser := CharTest(
  c => c == 'ğŸ˜ '
    || c == 'ğŸ˜¡'
    || c == 'ğŸ¤¬'
    || c == 'ğŸ˜¤',
  "Angry Smily")</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive">ğŸ˜  I am angry!</button>
    <button class="example-btn positive">ğŸ˜¡Hello</button>
    <button class="example-btn positive">ğŸ¤¬!!!</button>
    <button class="example-btn positive">ğŸ˜¤ Huffing!</button>
    <button class="example-btn negative">ğŸ˜€ Happy</button>
    <button class="example-btn negative">No emoji</button>
  </div>

  <textarea id="anger-input" class="input-area" placeholder="ğŸ˜  I am angry!">ğŸ˜  I am angry!</textarea>

  <div class="output-container">
    <div>
      <button id="anger-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="anger-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="anger-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Repetition (Rep) - Parsing Joy</h4>

<p>
  The <code>Rep</code> combinator applies a parser zero or more times. Let's use it to parse sequences of joyful
  characters:
</p>

<pre><code class="parser-definition">const JoyParser := CharTest(
  c => c == 'ğŸ˜€'
    || c == 'ğŸ˜ƒ'
    || c == 'ğŸ˜„'
    || c == 'ğŸ˜'
    || c == 'ğŸ¥³',
  "joy").Rep()</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</button>
    <button class="example-btn positive">ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So happy!</button>
    <button class="example-btn positive">ğŸ˜€ğŸ˜ƒğŸ¥³ğŸ˜ ğŸ˜¡ Joy then anger!</button>
    <button class="example-btn positive">No joy here</button>
    <button class="example-btn negative">ğŸ˜ ğŸ˜¡ Angry</button>
  </div>

  <textarea id="joy-input" class="input-area" placeholder="ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</textarea>

  <div class="output-container">
    <div>
      <button id="joy-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="joy-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="joy-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Mapping (M) - Joy Score Calculator</h4>

<p>
  The <code>M</code> combinator transforms the result of a parser. Let's create a joy score calculator that gives 2
  points for each joyful character:
</p>

<pre><code class="parser-definition">const JoyScoreParser := CharTest(
  c => c == 'ğŸ˜€'
    || c == 'ğŸ˜ƒ'
    || c == 'ğŸ˜„'
    || c == 'ğŸ˜'
    || c == 'ğŸ¥³',
  "joy").Rep().M(joyString => |joyString| * 2)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day! (6 points)</button>
    <button class="example-btn positive">ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So happy! (10 points)</button>
    <button class="example-btn positive">No joy here (0 points)</button>
    <button class="example-btn negative">ğŸ˜ ğŸ˜¡ Angry (0 points)</button>
  </div>

  <textarea id="joyscore-input" class="input-area" placeholder="ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</textarea>

  <div class="output-container">
    <div>
      <button id="joyscore-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="joyscore-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="joyscore-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Atoms - The Building Blocks of S-Expressions</h4>

<p>
  S-expressions are made of <strong>atoms</strong> (like <code>factorial</code>, <code>+</code>, <code>42</code>) and <strong>lists</strong> (like <code>(+ 1 2)</code>). 
  Let's start by parsing atoms - any sequence of characters that isn't a parenthesis or semicolon:
</p>

<pre><code class="parser-definition">const AtomParser := CharTest(c => c != '(' && c != ')' && c != ';' && c != ' ' && c != '\t' && c != '\n', "atom character").Rep1()</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own atoms:</p>

  <div class="example-buttons">
    <button class="example-btn positive">factorial</button>
    <button class="example-btn positive">+</button>
    <button class="example-btn positive">list-length</button>
    <button class="example-btn positive">42</button>
    <button class="example-btn positive">>=</button>
    <button class="example-btn negative">(not-an-atom</button>
  </div>

  <textarea id="atom-input" class="input-area" placeholder="factorial">factorial</textarea>

  <div class="output-container">
    <div>
      <button id="atom-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="atom-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="atom-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Numbers vs Symbols - Choice in Action</h4>

<p>
  The <code>O</code> (choice) combinator tries parsers in sequence until one succeeds. Let's use it to distinguish between numbers and symbols:
</p>

<pre><code class="parser-definition">const NumberOrSymbol := O([
  CharTest(c => '0' <= c <= '9', "digit").Rep1().M(digits => "NUMBER:" + digits),
  AtomParser.M(atom => "SYMBOL:" + atom)
])</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> See how the parser chooses between numbers and symbols:</p>

  <div class="example-buttons">
    <button class="example-btn positive">42</button>
    <button class="example-btn positive">factorial</button>
    <button class="example-btn positive">123</button>
    <button class="example-btn positive">+</button>
    <button class="example-btn positive">0</button>
    <button class="example-btn positive">hello-world</button>
  </div>

  <textarea id="choice-input" class="input-area" placeholder="42">42</textarea>

  <div class="output-container">
    <div>
      <button id="choice-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="choice-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="choice-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Lists - Parsing S-Expression Structure</h4>

<p>
  S-expressions use parentheses to create lists. Let's build a parser that recognizes the start of a function call - 
  an opening parenthesis followed by a function name. The concatenation operators let us combine parsers:
</p>
<ul>
  <li><code>I_I</code>: Keeps both results</li>
  <li><code>e_I</code>: Keeps only the right result (discard left)</li>
  <li><code>I_e</code>: Keeps only the left result (discard right)</li>
</ul>

<pre><code class="parser-definition">const FunctionCall := S("(").e_I(AtomParser).M(name => "CALL:" + name)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter function calls like "(+", "(factorial", "(if":</p>

  <div class="example-buttons">
    <button class="example-btn positive">(+</button>
    <button class="example-btn positive">(factorial</button>
    <button class="example-btn positive">(if</button>
    <button class="example-btn positive">(define</button>
    <button class="example-btn positive">(lambda</button>
    <button class="example-btn negative">no-paren</button>
  </div>

  <textarea id="function-input" class="input-area" placeholder="(+">(+</textarea>

  <div class="output-container">
    <div>
      <button id="function-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="function-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="function-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Whitespace - The Invisible Glue</h4>

<p>
  S-expressions need whitespace to separate atoms. The built-in <code>WS</code> parser handles spaces, tabs, and newlines.
  Let's see how it works with our atoms:
</p>

<pre><code class="parser-definition">const AtomWithSpaces := AtomParser.I_e(WS)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> See how whitespace gets consumed after parsing atoms:</p>

  <div class="example-buttons">
    <button class="example-btn positive">factorial   </button>
    <button class="example-btn positive">+	next</button>
    <button class="example-btn positive">42
newline</button>
    <button class="example-btn positive">hello world</button>
    <button class="example-btn negative">no-space-after</button>
  </div>

  <textarea id="whitespace-input" class="input-area" placeholder="factorial   ">factorial   </textarea>

  <div class="output-container">
    <div>
      <button id="whitespace-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="whitespace-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="whitespace-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Putting It Together</h4>

<p>
  Now we have all the building blocks! We can parse:
</p>
<ul>
  <li><strong>Individual characters</strong> with predicates (CharTest)</li>
  <li><strong>Sequences</strong> with repetition (Rep)</li>
  <li><strong>Transformations</strong> with mapping (M)</li>
  <li><strong>Combinations</strong> with concatenation (I_I, e_I, I_e)</li>
  <li><strong>Alternatives</strong> with choice (O)</li>
</ul>

<p>
  The S-expression formatter you tried above combines all these concepts using recursion to handle nested structures.
  Let's see how it works under the hood.
</p>

<h2>How the S-Expression Parser Works</h2>

<p>
  S-expressions (symbolic expressions) are a notation for representing nested data structures, originally used in the
  LISP programming language. They have a simple syntax: an S-expression is either an atom (like a symbol or number) or a
  list of S-expressions enclosed in parentheses.
</p>

<p>
  The parser handles:
</p>

<ul>
  <li>Atoms (identifiers like <code>factorial</code>, <code>n</code>)</li>
  <li>Numbers (integers like <code>0</code>, <code>1</code>)</li>
  <li>Lists (like <code>(define (factorial n) ...)</code>)</li>
</ul>

<h2>Implementation Details</h2>

<p>
  Let's look at how we can build an S-expression parser using Dafny's parser combinators. The parser will handle both
  atoms and nested expressions.
</p>

<p>
  First, we'll define our data structure for S-expressions:
</p>

<pre><code>module ExampleParsers.SExprParser {
  import opened Std.Parsers.StringBuilders

  datatype SExpr =
    | Atom(name: string)
    | List(items: seq&lt;SExpr&gt;)
}</code></pre>

<p>
  Next, we'll define a parser for whitespace and comments:
</p>

<pre><code>  // Parse whitespace and comments
  const WSOrComment := 
    WS.I_I(
      S(";").I_I(CharTest((c: char) => c != '\n', "anything except newline").Rep())
      .I_I(O([S("\n"), EOS.M(x => "")])).Rep()
    )</code></pre>

<p>
  Now, let's define the main parser for S-expressions. This is where the power of parser combinators really shines:
</p>

<pre><code>  // Parse an S-expression
  const parserSExpr := 
    Rec((SExpr: B&lt;SExpr&gt;) =>
      O([
        // Either a list: (expr1 expr2 ...)
        S("(").e_I(WSOrComment).Then(
          (r: string) =>
            SExpr.I_e(WSOrComment)
            .Rep().I_e(S(")")).I_e(WSOrComment)
        ).M((r: seq&lt;SExpr&gt;) => List(r)),
        
        // Or an atom: symbol
        CharTest((c: char) => c != '(' && c != ')' && !isWhitespace(c), "atom character")
        .Rep1().M((r: string) => Atom(r)).I_e(WSOrComment)
      ])
    )</code></pre>

<p>
  This parser uses the <code>Rec</code> combinator to create a recursive parser that can handle nested expressions.
  The parser first tries to match a list (expressions enclosed in parentheses) and if that fails, it tries to match an
  atom.
</p>

<p>
  We can also add a method to format S-expressions nicely:
</p>

<pre><code>  function ToString(expr: SExpr, indent: string := ""): string {
    match expr {
      case Atom(name) => name
      case List(items) =>
        if |items| == 0 then
          "()"
        else
          "(" + 
          String.Join(
            seq(|items|, i requires 0 <= i < |items| => 
              if i == 0 then ToString(items[i], indent + "  ")
              else "\n" + indent + "  " + ToString(items[i], indent + "  ")
            ),
            ""
          ) + ")"
    }
  }</code></pre>

<p>
  The formatting function above uses a recursive approach to pretty-print S-expressions. Here's how it works:
</p>

<ul>
  <li>For atoms, it simply returns the name of the atom.</li>
  <li>For empty lists, it returns "()".</li>
  <li>For non-empty lists, it formats the first item on the same line as the opening parenthesis, and each subsequent
    item on a new line with proper indentation.</li>
  <li>The indentation increases by two spaces for each level of nesting, making the structure clear and readable.</li>
  <li>The function uses Dafny's sequence comprehension to build the formatted string for each item in the list.</li>
</ul>

<p>
  This formatting approach is particularly useful for complex, nested S-expressions, as it makes the structure visually
  apparent.
</p>

<p>
  Finally, we can add a test method to verify our parser works correctly:
</p>

<pre><code>  method TestParser() {
    var input := "(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))";
    var result := parserSExpr.Apply(input);
    
    match result {
      case ParseSuccess(value, _) =>
        print "Parsed successfully: ", ToString(value), "\n";
      case ParseFailure(error, _) =>
        print "Parse error: ", error, "\n";
    }
  }</code></pre>



<!-- Load the required libraries and Dafny-compiled JavaScript -->
<script src="/blog/assets/js/bignumber.js"></script>
<script>
  // Mock require() function for browser compatibility
  window.require = function (module) {
    switch (module) {
      case 'bignumber.js':
        return window.BigNumber;
      case 'buffer':
        return { Buffer: window.Buffer || {} };
      case 'fs':
        return {};
      case 'path':
        return {};
      case 'process':
        return { argv: [] };
      default:
        console.warn('Unhandled require() call for module:', module);
        return {};
    }
  };
  window.process = {
    argv: [],
    stdout: {
      write: console.log
    }
  };
</script>
<script src="/blog/assets/js/parsers/parsers-combined.js"></script>
<script src="/blog/assets/js/parsers/parser-integration.js"></script>
</script>

<h2>Conclusion</h2>

<p>
  In this blog post, we've introduced Dafny's parser combinators library and demonstrated how to use it to build
  a parser and formatter for S-expressions. We've also shown how to compile Dafny code to JavaScript and integrate
  it into a web page to create an interactive demo.
</p>

<p>
  Parser combinators provide a powerful, modular approach to parsing that aligns well with functional programming
  principles.
  By using Dafny's standard library, you can leverage these techniques in your own projects, whether you're targeting
  JavaScript, C#, or other supported platforms.
</p>

<p>
  For more information on Dafny's standard libraries, including the parser combinators library, check out the
  <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyStandardLibraries">Dafny Standard Libraries
    repository</a>.
</p>