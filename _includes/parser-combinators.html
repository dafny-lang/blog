<style>
  /* Styles for the interactive demo */
  .demo-container {
    border: 1px solid #ddd;
    border-radius: 5px;
    padding: 15px;
    margin: 20px 0;
    background-color: #f9f9f9;
  }

  .input-area {
    width: 100%;
    height: 1em;
    font-family: monospace;
    margin-bottom: 10px;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
  }

  .output-area {
    width: 100%;
    min-height: 100px;
    font-family: monospace;
    background-color: #f0f0f0;
    padding: 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    margin-top: 10px;
    white-space: pre-wrap;
  }

  /* Preserve whitespace in parser output spans */
  [id$="-parsed"],
  [id$="-remaining"] {
    white-space: pre-wrap;
  }

  .error-display {
    color: #d9534f;
    margin-top: 10px;
    font-family: monospace;
  }

  .controls {
    margin: 10px 0;
  }

  button {
    background-color: #337ab7;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    margin-right: 10px;
  }

  button:hover {
    background-color: #286090;
  }

  /* Example button styles */
  .example-buttons {
    margin: 10px 0;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .example-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    font-family: monospace;
  }

  .example-btn.positive {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }

  .example-btn.positive:hover {
    background-color: #c3e6cb;
  }

  .example-btn.negative {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }

  .example-btn.negative:hover {
    background-color: #f5c6cb;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Initialize all example buttons for building block demos
    document.querySelectorAll('.example-btn').forEach(button => {
      button.addEventListener('click', function () {
        // Check if this is an S-expression demo button (has data-example attribute)
        if (this.hasAttribute('data-example')) {
          const inputArea = document.getElementById('input-area');
          const parseButton = document.getElementById('parse-button');
          
          if (inputArea && parseButton) {
            // Set the input value to the example
            inputArea.value = this.getAttribute('data-example');
            // Trigger the parse button to format immediately
            parseButton.click();
          }
          return;
        }

        // Handle building block demo buttons (existing logic)
        const demoContainer = this.closest('.demo-container');
        if (!demoContainer) {
          console.warn('Demo container not found for button:', this);
          return;
        }

        const input = demoContainer.querySelector('textarea.input-area, input.input-area');
        const parseButton = demoContainer.querySelector('button[id$="-parse-button"]');

        if (input && parseButton) {
          // Set the input value to the button's text content
          input.value = this.textContent;
          // Trigger the parse button
          parseButton.click();
        } else {
          console.warn('Input or parse button not found in container:', {
            input: !!input,
            parseButton: !!parseButton,
            container: demoContainer
          });
        }
      });
    });
  });
</script>





<h2>Why Parser Combinators Matter</h2>

<p>
  Imagine you need to parse and format complex nested structures like this LISP factorial function:
</p>

<pre><code>(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))</code></pre>

<p>
  Most parsing approaches would require hundreds of lines of complex, error-prone code. But with parser combinators, you
  can build an elegant, working parser in just a few dozen lines. Even better - it compiles to JavaScript and runs in
  your browser!
</p>

<h2>Interactive S-Expression Formatter</h2>

<p>
  Try it yourself! Enter any S-expression below and watch it get parsed and beautifully formatted:
</p>

<div class="demo-container">
  <textarea id="input-area" class="input-area"
    placeholder="Enter an S-expression here, e.g., (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))"></textarea>

  <div class="controls">
    <button id="parse-button">Parse & Format</button>
  </div>

  <div class="example-buttons">
    <button class="example-btn positive" data-example="(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))">Factorial Function</button>
    <button class="example-btn positive" data-example="(let ((x 5) (y 10)) (+ x y))">Let Binding</button>
    <button class="example-btn positive" data-example="(lambda (x) (* x x))">Lambda Function</button>
    <button class="example-btn positive" data-example="(list 1 2 3 4 5)">Simple List</button>
    <button class="example-btn positive" data-example="(if (> x 0) (+ x 1) (- x 1))">Conditional</button>
    <button class="example-btn positive" data-example="(map (lambda (x) (* x x)) (list 1 2 3 4))">Higher-Order Function</button>
    <button class="example-btn positive" data-example="; Fibonacci with comments
(define (fib n)
  ; Base cases
  (if (<= n 1)
      n
      ; Recursive case
      (+ (fib (- n 1)) (fib (- n 2)))))">With Comments</button>
  </div>

  <div id="output-area" class="output-area">Formatted output will appear here</div>
  <div id="error-display" class="error-display"></div>
</div>

<p>
  This formatter handles nested structures, proper indentation, and error reporting - all built from simple, composable
  pieces. How is this possible? Let's explore the building blocks.
</p>

<h2>Parser Combinators: Building Complex from Simple</h2>

<p>
  Parser combinators are higher-order functions that accept parsers as input and return new parsers as output.
  This approach allows you to build complex parsers by combining simpler ones. Dafny's standard library provides
  a concise Domain-Specific Language (DSL) for building parsers that uses minimal syntax to make complex parser
  definitions more readable.
</p>

<p>
  To use the parser builders DSL in Dafny, you need to import:
</p>

<pre><code>import opened Std.Parsers.StringBuilders</code></pre>

<p>
  This gives you access to a set of short, expressive combinators that reduce syntactic noise and highlight the parser
  logic. Let's see how these simple pieces combine to create the powerful formatter above.
</p>


<h2>The Building Blocks</h2>

<p>
  Let's explore the fundamental parser components that make the S-expression formatter possible. Each parser has an
  <code>Apply</code> method that takes an input string and returns a <code>ParseResult</code>:
</p>

<pre><code>datatype ParseResult&lt;T&gt; = 
  | ParseSuccess(result: T, remaining: Input)
  | ParseFailure(level: FailureLevel, data: FailureData)</code></pre>

<p>
  When a parser succeeds, it returns the parsed value and the remaining unconsumed characters. When it fails, it returns
  an error message and the position where parsing failed. Each example below includes an interactive demo where you can
  experiment with the parser.
</p>

<h4>Character Testing (CharTest) - Parsing Anger</h4>

<p>
  The <code>CharTest</code> combinator is the foundation of most parsers. It takes a predicate function and succeeds if
  the next character satisfies that condition. Let's start with something fun - parsing anger characters!
</p>

<pre><code class="parser-definition">const AngerParser := CharTest(
  c => c == 'ğŸ˜ '
    || c == 'ğŸ˜¡'
    || c == 'ğŸ¤¬'
    || c == 'ğŸ˜¤',
  "Angry Smily")</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive">ğŸ˜  I am angry!</button>
    <button class="example-btn positive">ğŸ˜¡Hello</button>
    <button class="example-btn positive">ğŸ¤¬!!!</button>
    <button class="example-btn positive">ğŸ˜¤ Huffing!</button>
    <button class="example-btn negative">ğŸ˜€ Happy</button>
    <button class="example-btn negative">No emoji</button>
  </div>

  <textarea id="anger-input" class="input-area" placeholder="ğŸ˜  I am angry!">ğŸ˜  I am angry!</textarea>

  <div class="output-container">
    <div>
      <button id="anger-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="anger-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="anger-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Repetition (Rep) - Parsing Joy</h4>

<p>
  The <code>Rep</code> combinator applies a parser zero or more times. Let's use it to parse sequences of joyful
  characters:
</p>

<pre><code class="parser-definition">const JoyParser := CharTest(
  c => c == 'ğŸ˜€'
    || c == 'ğŸ˜ƒ'
    || c == 'ğŸ˜„'
    || c == 'ğŸ˜'
    || c == 'ğŸ¥³',
  "joy").Rep()</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</button>
    <button class="example-btn positive">ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So happy!</button>
    <button class="example-btn positive">ğŸ˜€ğŸ˜ƒğŸ¥³ğŸ˜ ğŸ˜¡ Joy then anger!</button>
    <button class="example-btn positive">No joy here</button>
    <button class="example-btn negative">ğŸ˜ ğŸ˜¡ Angry</button>
  </div>

  <textarea id="joy-input" class="input-area" placeholder="ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</textarea>

  <div class="output-container">
    <div>
      <button id="joy-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="joy-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="joy-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Mapping (M) - Joy Score Calculator</h4>

<p>
  The <code>M</code> combinator transforms the result of a parser. Let's create a joy score calculator that gives 2
  points for each joyful character:
</p>

<pre><code class="parser-definition">const JoyScoreParser := CharTest(
  c => c == 'ğŸ˜€'
    || c == 'ğŸ˜ƒ'
    || c == 'ğŸ˜„'
    || c == 'ğŸ˜'
    || c == 'ğŸ¥³',
  "joy").Rep().M(joyString => |joyString| * 2)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day! (6 points)</button>
    <button class="example-btn positive">ğŸ˜ğŸ˜ğŸ˜ğŸ˜ğŸ¥³ So happy! (10 points)</button>
    <button class="example-btn positive">No joy here (0 points)</button>
    <button class="example-btn negative">ğŸ˜ ğŸ˜¡ Angry (0 points)</button>
  </div>

  <textarea id="joyscore-input" class="input-area" placeholder="ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!">ğŸ˜€ğŸ˜ƒğŸ˜„ Happy day!</textarea>

  <div class="output-container">
    <div>
      <button id="joyscore-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="joyscore-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="joyscore-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Whitespace Parser (WS)</h4>

<p>
  Now we can understand how the built-in <code>WS</code> parser works - it's actually defined using
  <code>CharTest</code> and <code>Rep</code>:
</p>

<pre><code class="parser-definition">// WS is roughly equivalent to:
// CharTest(c => c == ' ' || c == '\t' || c == '\n' || c == '\r', "whitespace").Rep()
const WSParser := WS</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter some text with whitespace at the beginning</p>
  <textarea id="ws-input" class="input-area" placeholder="   Hello world">   Hello world</textarea>

  <div class="output-container">
    <div>
      <button id="ws-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="ws-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="ws-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Identifier Parser</h4>

<p>
  Let's build an identifier parser that will be crucial for S-expressions. An identifier starts with a letter and can
  contain letters, digits, and some special characters:
</p>

<pre><code class="parser-definition">const IdentifierParser := CharTest(c => 'a' <= c <= 'z' || 'A' <= c <= 'Z', "letter").Rep1()</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter identifiers like "factorial", "list-length", "+"</p>
  <textarea id="identifier-input" class="input-area" placeholder="factorial">factorial</textarea>

  <div class="output-container">
    <div>
      <button id="identifier-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="identifier-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="identifier-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Concatenation - Building S-Expression Structure</h4>

<p>
  Now let's use concatenation to start building the structure we need for S-expressions. The concatenation operators
  combine parsers in sequence:
</p>
<ul>
  <li><code>I_I</code>: Keeps both results</li>
  <li><code>I_e</code>: Keeps only the left result</li>
  <li><code>e_I</code>: Keeps only the right result</li>
</ul>

<p>
  Let's build a parser that recognizes the start of an S-expression: an opening parenthesis followed by an identifier
  (like "(define" or "(lambda"):
</p>

<pre><code class="parser-definition">// Parse "(" followed by an identifier - the start of an S-expression!
const SExprStart_I_I := S("(").I_I(IdentifierParser)

// Just keep the identifier, discard the "("
const SExprStart_e_I := S("(").e_I(IdentifierParser)

// Just keep the "(", discard the identifier  
const SExprStart_I_e := S("(").I_e(IdentifierParser)</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Enter S-expression starts like "(define", "(lambda", "(list"</p>
  <textarea id="concat-input" class="input-area" placeholder="(define">(define</textarea>

  <div class="controls">
    <select id="concat-type">
      <option value="SExprStart_I_I">I_I (both "(" and identifier)</option>
      <option value="SExprStart_e_I">e_I (just identifier)</option>
      <option value="SExprStart_I_e">I_e (just "(")</option>
    </select>
  </div>

  <div class="output-container">
    <div>
      <button id="concat-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="concat-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="concat-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Choice (O) - Anger or Joy</h4>

<p>
  The <code>O</code> (choice) operator tries each parser in sequence until one succeeds. Let's combine our anger and joy
  parsers to parse any emotional emoji:
</p>

<pre><code class="parser-definition">const EmotionParser := O([AngerParser, CharTest(c => c == 'ğŸ˜€' || c == 'ğŸ˜ƒ' || c == 'ğŸ˜„' || c == 'ğŸ˜' || c == 'ğŸ¥³', "joy")])</code></pre>

<div class="demo-container">
  <p><strong>Try it:</strong> Click an example or enter your own text:</p>

  <div class="example-buttons">
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ˜  Angry!')">ğŸ˜  Angry!</button>
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ˜ƒ Happy!')">ğŸ˜ƒ Happy!</button>
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ¤¬ Furious!')">ğŸ¤¬ Furious!</button>
    <button class="example-btn positive" onclick="setInput('emotion-input', 'ğŸ¥³ Party!')">ğŸ¥³ Party!</button>
    <button class="example-btn negative" onclick="setInput('emotion-input', 'ğŸ˜ Neutral')">ğŸ˜ Neutral</button>
    <button class="example-btn negative" onclick="setInput('emotion-input', 'No emoji')">No emoji</button>
  </div>

  <textarea id="emotion-input" class="input-area" placeholder="ğŸ˜  Angry!">ğŸ˜  Angry!</textarea>

  <div class="output-container">
    <div>
      <button id="emotion-parse-button">Parse</button>
      <strong>Parsed:</strong> <span id="emotion-parsed" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
      <strong>Remaining:</strong> <span id="emotion-remaining" class="output-area"
        style="display: inline-block; min-height: 20px; width: 200px;"></span>
    </div>
  </div>
</div>

<h4>Putting It Together</h4>

<p>
  Now we have all the building blocks! We can parse:
</p>
<ul>
  <li><strong>Individual characters</strong> with predicates (CharTest)</li>
  <li><strong>Sequences</strong> with repetition (Rep)</li>
  <li><strong>Transformations</strong> with mapping (M)</li>
  <li><strong>Combinations</strong> with concatenation (I_I, e_I, I_e)</li>
  <li><strong>Alternatives</strong> with choice (O)</li>
</ul>

<p>
  The S-expression formatter you tried above combines all these concepts using recursion to handle nested structures.
  Let's see how it works under the hood.
</p>

<h2>How the S-Expression Parser Works</h2>

<p>
  S-expressions (symbolic expressions) are a notation for representing nested data structures, originally used in the
  LISP programming language. They have a simple syntax: an S-expression is either an atom (like a symbol or number) or a
  list of S-expressions enclosed in parentheses.
</p>

<p>
  The parser handles:
</p>

<ul>
  <li>Atoms (identifiers like <code>factorial</code>, <code>n</code>)</li>
  <li>Numbers (integers like <code>0</code>, <code>1</code>)</li>
  <li>Lists (like <code>(define (factorial n) ...)</code>)</li>
</ul>

<h2>Implementation Details</h2>

<p>
  Let's look at how we can build an S-expression parser using Dafny's parser combinators. The parser will handle both
  atoms and nested expressions.
</p>

<p>
  First, we'll define our data structure for S-expressions:
</p>

<pre><code>module ExampleParsers.SExprParser {
  import opened Std.Parsers.StringBuilders

  datatype SExpr =
    | Atom(name: string)
    | List(items: seq&lt;SExpr&gt;)
}</code></pre>

<p>
  Next, we'll define a parser for whitespace and comments:
</p>

<pre><code>  // Parse whitespace and comments
  const WSOrComment := 
    WS.I_I(
      S(";").I_I(CharTest((c: char) => c != '\n', "anything except newline").Rep())
      .I_I(O([S("\n"), EOS.M(x => "")])).Rep()
    )</code></pre>

<p>
  Now, let's define the main parser for S-expressions. This is where the power of parser combinators really shines:
</p>

<pre><code>  // Parse an S-expression
  const parserSExpr := 
    Rec((SExpr: B&lt;SExpr&gt;) =>
      O([
        // Either a list: (expr1 expr2 ...)
        S("(").e_I(WSOrComment).Then(
          (r: string) =>
            SExpr.I_e(WSOrComment)
            .Rep().I_e(S(")")).I_e(WSOrComment)
        ).M((r: seq&lt;SExpr&gt;) => List(r)),
        
        // Or an atom: symbol
        CharTest((c: char) => c != '(' && c != ')' && !isWhitespace(c), "atom character")
        .Rep1().M((r: string) => Atom(r)).I_e(WSOrComment)
      ])
    )</code></pre>

<p>
  This parser uses the <code>Rec</code> combinator to create a recursive parser that can handle nested expressions.
  The parser first tries to match a list (expressions enclosed in parentheses) and if that fails, it tries to match an
  atom.
</p>

<p>
  We can also add a method to format S-expressions nicely:
</p>

<pre><code>  function ToString(expr: SExpr, indent: string := ""): string {
    match expr {
      case Atom(name) => name
      case List(items) =>
        if |items| == 0 then
          "()"
        else
          "(" + 
          String.Join(
            seq(|items|, i requires 0 <= i < |items| => 
              if i == 0 then ToString(items[i], indent + "  ")
              else "\n" + indent + "  " + ToString(items[i], indent + "  ")
            ),
            ""
          ) + ")"
    }
  }</code></pre>

<p>
  The formatting function above uses a recursive approach to pretty-print S-expressions. Here's how it works:
</p>

<ul>
  <li>For atoms, it simply returns the name of the atom.</li>
  <li>For empty lists, it returns "()".</li>
  <li>For non-empty lists, it formats the first item on the same line as the opening parenthesis, and each subsequent
    item on a new line with proper indentation.</li>
  <li>The indentation increases by two spaces for each level of nesting, making the structure clear and readable.</li>
  <li>The function uses Dafny's sequence comprehension to build the formatted string for each item in the list.</li>
</ul>

<p>
  This formatting approach is particularly useful for complex, nested S-expressions, as it makes the structure visually
  apparent.
</p>

<p>
  Finally, we can add a test method to verify our parser works correctly:
</p>

<pre><code>  method TestParser() {
    var input := "(define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1)))))";
    var result := parserSExpr.Apply(input);
    
    match result {
      case ParseSuccess(value, _) =>
        print "Parsed successfully: ", ToString(value), "\n";
      case ParseFailure(error, _) =>
        print "Parse error: ", error, "\n";
    }
  }</code></pre>



<!-- Load the required libraries and Dafny-compiled JavaScript -->
<script src="/blog/assets/js/bignumber.js"></script>
<script>
  // Mock require() function for browser compatibility
  window.require = function (module) {
    switch (module) {
      case 'bignumber.js':
        return window.BigNumber;
      case 'buffer':
        return { Buffer: window.Buffer || {} };
      case 'fs':
        return {};
      case 'path':
        return {};
      case 'process':
        return { argv: [] };
      default:
        console.warn('Unhandled require() call for module:', module);
        return {};
    }
  };
  window.process = {
    argv: [],
    stdout: {
      write: console.log
    }
  };
</script>
<script src="/blog/assets/js/parsers/parsers-combined.js"></script>
<script src="/blog/assets/js/parsers/parser-integration.js"></script>
</script>

<h2>Conclusion</h2>

<p>
  In this blog post, we've introduced Dafny's parser combinators library and demonstrated how to use it to build
  a parser and formatter for S-expressions. We've also shown how to compile Dafny code to JavaScript and integrate
  it into a web page to create an interactive demo.
</p>

<p>
  Parser combinators provide a powerful, modular approach to parsing that aligns well with functional programming
  principles.
  By using Dafny's standard library, you can leverage these techniques in your own projects, whether you're targeting
  JavaScript, C#, or other supported platforms.
</p>

<p>
  For more information on Dafny's standard libraries, including the parser combinators library, check out the
  <a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyStandardLibraries">Dafny Standard Libraries
    repository</a>.
</p>