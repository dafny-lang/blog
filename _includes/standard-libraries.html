<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.2.3" />
  <meta name="viewport" content="initial-scale=1.0" />
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote {
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013";
      position: absolute;
      margin-left: -1em;
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    text-align: left;
    white-space: pre;
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko span.math-rendering {
    display:inline-block;
    width:8em;
    overflow-x:auto;
    font-size:70%;
  }
  .madoko span.math-rendering::-webkit-scrollbar {
    width:4px;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 {
    margin-top: 1.22em;
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  {
    margin-top: 1ex;
  }
  .madoko h5, .madoko h6 {
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 {
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 {
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt,
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  
  <style>
    body.madoko {
        max-width: 100%;
        margin: 0;
        padding: 0;
      }
      .page-content {
        padding: 0;
      }
  </style>
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">

<p class="p noindent" data-line="19"><span data-line="19"></span>I am an engineer and I love Dafny. 
</p>
<p class="p indent" data-line="21"><span data-line="21"></span>Why? Because Dafny is a programming language designed from the ground up
to support expressing the behavior of code directly in the code itself.
Dafny lets you precisely specify what it means to sort a sequence of values,
not just as a giant comment on your sorting function you hope no-one misinterprets,
but as a machine-readible expression in the same language.
Even better, the Dafny tool can statically tell you whether your implementation is correct or not,
without ever running a single test.
</p>
<p class="p indent" data-line="29"><span data-line="29"></span>When I first learned about Dafny, this was mind-blowing.
Having worked as an engineer for decades,
I<span data-line="31"></span>&#39;<span data-line="31"></span>ve seen my share of subtle and catastrophic bugs in production,
and often thought it should be possible to catch more of them before they happen.
I<span data-line="33"></span>&#39;<span data-line="33"></span>ve always been passionate about inventing and building tools
to help more engineers do their job better, 
and now, getting to help maintain and contribute to Dafny every day
has been the definition of a dream job.
</p>
<p class="p indent" data-line="38"><span data-line="38"></span>At the same time, it<span data-line="38"></span>&#39;<span data-line="38"></span>s getting to the end of 2023
and I<span data-line="39"></span>&#39;<span data-line="39"></span>m <span data-line="39"></span><strong class="strong-star2">really</strong><span data-line="39"></span> looking forward to a break this year.
Having bought my son a Lego advent calendar
and my wife a crossword advent calendar
(always on the lookout for alternatives to candy),
I thought I would try my hand at<span data-line="43"></span>&nbsp;<a href="https://adventofcode.com/">Advent of Code</a><span data-line="43"></span>,
a popular code puzzle advent calendar
that<span data-line="45"></span>&#39;<span data-line="45"></span>s been around since 2015.
But to make it extra fun, I thought I<span data-line="46"></span>&#39;<span data-line="46"></span>d write my solutions in Dafny.
</p>
<p class="p indent" data-line="48"><span data-line="48"></span>I was pleased to hear several colleagues had the same idea in years past,
but also heard a common refrain that it seemed harder than it should be.
To be fair, Dafny is never going to be the best choice
if you<span data-line="51"></span>&#39;<span data-line="51"></span>re trying to solve the puzzles as fast as possible
and climb the leaderboard:
Dafny is built for carefully writing a verifiably-correct solution,
not a probably-correct solution as fast as possible.
But even though the Dafny language itself is easily expressive and full-featured enough,
it didn<span data-line="56"></span>&#39;<span data-line="56"></span>t give you much help with basic tasks
like parsing a number from its string representation.
</p>
<p class="p indent" data-line="59"><span data-line="59"></span>We<span data-line="59"></span>&#39;<span data-line="59"></span>ve been collecting lots of valuable reusable Dafny code in a separate 
<span data-line="60"></span><a href="https://github.com/dafny-lang/libraries"><code class="code code1">dafny-lang/libraries</code></a><span data-line="60"></span> repository for several years now.
I frequently pointed folks to this repository whenever I saw questions like
<span data-line="62"></span>&#8220;how do I map a function over a sequence in Dafny?&#8221;<span data-line="62"></span>, knowing that there was already
a <span data-line="63"></span><code class="code code1">Seq.Map</code><span data-line="63"></span> function just waiting there to be used.
But it was obvious users didn<span data-line="64"></span>&#39;<span data-line="64"></span>t naturally discover this code,
and not all projects could easily add it as a submodule
in order to access it.
</p>
<p class="p indent" data-line="68"><span data-line="68"></span>This is why I<span data-line="68"></span>&#39;<span data-line="68"></span>m so excited about the recent release of Dafny 4.4:
we spent months refactoring all these libraries and importing them into the Dafny distribution itself,
so that they are now available to any and all Dafny users out of the box.
</p>
<p class="p indent" data-line="72"><span data-line="72"></span>To show off what a difference this makes,
let<span data-line="73"></span>&#39;<span data-line="73"></span>s look at what it<span data-line="73"></span>&#39;<span data-line="73"></span>s like to solve the very first Advent of Code puzzle.
</p><h3 id="sec-getting-started" class="h2" data-line="75" data-heading-depth="2" style="display:block"><span data-line="75"></span>Getting started</h3>
<p class="p noindent" data-line="77"><span data-line="77"></span>The requirements for the first puzzle boil down to:
</p>
<blockquote data-line="79">

<p class="p noindent" data-line="79"><span data-line="79"></span>The newly-improved calibration document consists of lines of text; each line originally contained a specific <span data-line="79"></span><strong class="strong-star2">calibration value</strong><span data-line="79"></span> that the Elves now need to recover. On each line, the calibration value can be found by combining the <span data-line="79"></span><strong class="strong-star2">first digit</strong><span data-line="79"></span> and the <span data-line="79"></span><strong class="strong-star2">last digit</strong><span data-line="79"></span> (in that order) to form a single <span data-line="79"></span><strong class="strong-star2">two-digit number</strong><span data-line="79"></span>.
</p>
<p class="p indent" data-line="81"><span data-line="81"></span>&#8230;<span data-line="81"></span>
</p>
<p class="p indent" data-line="83"><span data-line="83"></span>Consider your entire calibration document. What is the sum of all of the calibration values?
</p></blockquote>
<p class="p noindent" data-line="85"><span data-line="85"></span>No problem, we can handle this!
</p>
<p class="p indent" data-line="87"><span data-line="87"></span>To ensure full backwards compatibility for existing Dafny projects,
Dafny 4.4 doesn<span data-line="88"></span>&#39;<span data-line="88"></span>t make the standard libraries available by default:
they are enabled by a <span data-line="89"></span><code class="code code1">--standard-libraries</code><span data-line="89"></span> option to the <span data-line="89"></span><code class="code code1">dafny</code><span data-line="89"></span> CLI.
But we can do better than that:
we can use a Dafny project file to indicate we want to use the standard libraries,
which will let the Dafny IDE understand that dependency.
</p>
<p class="p indent" data-line="94"><span data-line="94"></span>Start by<span data-line="94"></span>&nbsp;<a href="https://dafny.org/dafny/Installation">installing Dafny 4.4</a><span data-line="94"></span>, ideally
opting to<span data-line="95"></span>&nbsp;<a href="https://dafny.org/dafny/Installation#Visual-Studio-Code">use the VS Code extension</a><span data-line="95"></span> which will download its own copy automatically.
Create a new directory with an empty <span data-line="96"></span><code class="code code1">solution.dfy</code><span data-line="96"></span> file and a <span data-line="96"></span><code class="code code1">dfyconfig.toml</code><span data-line="96"></span> file with these contents:
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="98" data-line-first="99" style="display:block"><code data-line="99">[options]
standard-libraries = true</code></pre>
<p class="p noindent para-continued" data-line="103"><span data-line="103"></span>Now for the actual code. Let<span data-line="103"></span>&#39;<span data-line="103"></span>s start from the bottom-up:
we<span data-line="104"></span>&#39;<span data-line="104"></span>re clearly going to need a function to extract the calibration value as a number from a single line of text.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="106" data-line-first="107" style="display:block"><code data-line="107"><span style="color:blue">function</span> CalibrationValue(line: <span style="color:teal">string</span>): <span style="color:teal">nat</span> {
  <span style="color:darkgreen">// ...</span>
}</code></pre>
<p class="p noindent para-continued" data-line="112"><span data-line="112"></span>How do we find the first and last digits?
</p><h3 id="sec-sequences-and-wrappers" class="h2" data-line="114" data-heading-depth="2" style="display:block"><span data-line="114"></span>Sequences and Wrappers</h3>
<p class="p noindent" data-line="116"><span data-line="116"></span>Having a look at the<span data-line="116"></span>&nbsp;<a href="https://github.com/dafny-lang/dafny/tree/master/Source/DafnyStandardLibraries/README.md">top-level index of Dafny standard libraries</a><span data-line="116"></span>,
we notice there<span data-line="117"></span>&#39;<span data-line="117"></span>s a <span data-line="117"></span><code class="code code1">Std.Collections</code><span data-line="117"></span> library with<span data-line="117"></span>&nbsp;<a href="https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/src/Std/Collections/Seq.dfy">a submodule for <code class="code code1">Seq</code></a><span data-line="117"></span>, and sure enough, there are functions like <span data-line="117"></span><code class="code code1">IndexOf</code><span data-line="117"></span> and <span data-line="117"></span><code class="code code1">LastIndexOf</code><span data-line="117"></span>. Perfect!
</p>
<p class="p indent" data-line="119"><span data-line="119"></span>Or perhaps you were distracted by the <span data-line="119"></span><code class="code code1">Std.Strings</code><span data-line="119"></span> module, where you might expect these utilities to live.
But in Dafny, strings are really nothing more than sequences of characters:
the type <span data-line="121"></span><code class="code code1">string</code><span data-line="121"></span> is just an alias for <span data-line="121"></span><code class="code code1">seq&lt;char&gt;</code><span data-line="121"></span>.
This means many typical string operations are provided as general sequence operations instead.
Don<span data-line="123"></span>&#39;<span data-line="123"></span>t worry, we<span data-line="123"></span>&#39;<span data-line="123"></span>ll get to that library in a moment.
</p>
<p class="p indent" data-line="125"><span data-line="125"></span>Let<span data-line="125"></span>&#39;<span data-line="125"></span>s consider for a moment how you might want to use a function like <span data-line="125"></span><code class="code code1">IndexOf</code><span data-line="125"></span> in general.
Finding the index of an element in a sequence will certainly not always succeed,
since the sequence might not contain the element.
In most standard libraries, a function like <span data-line="128"></span><code class="code code1">IndexOf</code><span data-line="128"></span> may return an invalid sentinel index value,
like the length of the sequence or <span data-line="129"></span><code class="code code1">-1</code><span data-line="129"></span>.
But often you actually know the element is in the sequence
because of the way the rest of the program is structured.
Perhaps you just added the element to a list and then sorted it.
Because of the invariants of sorting, you know the element is still in there.
The great thing about Dafny is that it can actually understand this kind of reasoning,
and know when it is safe to assume an operation will succeed.
</p>
<p class="p indent" data-line="137"><span data-line="137"></span>Therefore a common pattern in the Dafny standard libraries
is to have two different versions of a function or method:
a partial version with preconditions,
and a complete version that may not succeed.
The <span data-line="141"></span><code class="code code1">Std.Wrappers</code><span data-line="141"></span> library provides a few extremely common datatypes for this:
<span data-line="142"></span><code class="code code1">Option&lt;T&gt;</code><span data-line="142"></span>, for a value that may not exist,
and <span data-line="143"></span><code class="code code1">Result&lt;T, E&gt;</code><span data-line="143"></span>, for the result of an operation that may fail with an error value instead.
The <span data-line="144"></span><code class="code code1">Seq</code><span data-line="144"></span> library and most of the other libraries use these datatypes all over the place
in order to define partial operations.
</p>
<p class="p indent" data-line="147"><span data-line="147"></span>In our specific case, there is both an <span data-line="147"></span><code class="code code1">IndexOf</code><span data-line="147"></span> function,
which requires the element is present in the sequence and returns a <span data-line="148"></span><code class="code code1">nat</code><span data-line="148"></span> that is always a valid index in the sequence,
and <span data-line="149"></span><code class="code code1">IndexOfOption</code><span data-line="149"></span>, which produces an <span data-line="149"></span><code class="code code1">Option&lt;nat&gt;</code><span data-line="149"></span> instead of a <span data-line="149"></span><code class="code code1">nat</code><span data-line="149"></span>.
The latter is the better match for our situation,
since we<span data-line="151"></span>&#39;<span data-line="151"></span>re eventually going to read our puzzle input from a file on disk,
and we don<span data-line="152"></span>&#39;<span data-line="152"></span>t actually <span data-line="152"></span><strong class="strong-star2">know</strong><span data-line="152"></span> that every line contains at least one digit.
</p>
<p class="p indent" data-line="154"><span data-line="154"></span>Note that in general we could get by with only the partial version of all these operations,
since we could always just explicitly check the precondition first
before invoking the operation.
The downside of that approach, though, is that there<span data-line="157"></span>&#39;<span data-line="157"></span>s a performance cost:
you end up iterating through the sequence twice, once to check if the element is there
and then again to actually fetch the element.
</p>
<p class="p indent" data-line="161"><span data-line="161"></span>Finally, in our case we<span data-line="161"></span>&#39;<span data-line="161"></span>re not looking for a specific concrete element,
we<span data-line="162"></span>&#39;<span data-line="162"></span>re looking for any digit.
In other words, we want to find the first and last index of elements
that satisfy a particular predicate.
Fortunately <span data-line="165"></span><code class="code code1">Seq</code><span data-line="165"></span> has us covered here too,
and the two functions we actually want to use are <span data-line="166"></span><code class="code code1">IndexByOption</code><span data-line="166"></span> and <span data-line="166"></span><code class="code code1">LastIndexByOption</code><span data-line="166"></span>.
</p><h3 id="sec-strings-and-numbers" class="h2" data-line="168" data-heading-depth="2" style="display:block"><span data-line="168"></span>Strings and Numbers</h3>
<p class="p noindent" data-line="170"><span data-line="170"></span>Let<span data-line="170"></span>&#39;<span data-line="170"></span>s see how much of our <span data-line="170"></span><code class="code code1">CalibrationValue</code><span data-line="170"></span> function we can write now.
We can import the <span data-line="171"></span><code class="code code1">Std.Collections.Seq</code><span data-line="171"></span> module into the default top-level module
with an <span data-line="172"></span><code class="code code1">import</code><span data-line="172"></span> statement.
In most Dafny codebases you<span data-line="173"></span>&#39;<span data-line="173"></span>ll see <span data-line="173"></span><code class="code code1">import opened</code><span data-line="173"></span> statements,
especially for very common modules like <span data-line="174"></span><code class="code code1">Std.Wrappers</code><span data-line="174"></span>:
these statements make the contents of the imported module directly available
in the importing module.
That lets you say things like <span data-line="177"></span><code class="code code1">Some(42)</code><span data-line="177"></span> and <span data-line="177"></span><code class="code code1">None</code><span data-line="177"></span>
rather than <span data-line="178"></span><code class="code code1">Wrappers.Some(42)</code><span data-line="178"></span> and <span data-line="178"></span><code class="code code1">Wrappers.None</code><span data-line="178"></span>.
For this exercise I<span data-line="179"></span>&#39;<span data-line="179"></span>m just using <span data-line="179"></span><code class="code code1">import</code><span data-line="179"></span> statements
so it<span data-line="180"></span>&#39;<span data-line="180"></span>s more obvious when we<span data-line="180"></span>&#39;<span data-line="180"></span>re using things from the standard libraries.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="182" data-line-first="183" style="display:block"><code data-line="183"><span style="color:blue">import</span> Std.Collections.Seq

<span style="color:blue">function</span> CalibrationValue(line: <span style="color:teal">string</span>): <span style="color:teal">nat</span> {
  <span style="color:blue">var</span> firstDigitIndex <span style="color:blue">:=</span> Seq.IndexByOption(line, <span style="color:darkgreen">/*</span><span style="color:darkgreen"> hmm... </span><span style="color:darkgreen">*/</span>);
  <span style="color:blue">var</span> lastDigitIndex <span style="color:blue">:=</span> Seq.LastIndexByOption(line, <span style="color:darkgreen">/*</span><span style="color:darkgreen"> hmm... </span><span style="color:darkgreen">*/</span>);

  <span style="color:blue">var</span> resultAsString <span style="color:blue">:=</span> [line[firstDigitIndex], line[lastDigitIndex]];

  <span style="color:darkgreen">// Still need to parse the result as a number...</span>
}</code></pre>
<p class="p noindent para-continued" data-line="195"><span data-line="195"></span>Progress! We<span data-line="195"></span>&#39;<span data-line="195"></span>ll figure out what to pass for the second arguments on the first two lines in a moment.
First, how do we convert our <span data-line="196"></span><code class="code code1">resultAsString</code><span data-line="196"></span> to a number, more specifically a <span data-line="196"></span><code class="code code1">nat</code><span data-line="196"></span>?
This is more specifically an operation on strings rather than generic sequences.
That means <span data-line="198"></span><strong class="strong-star2">now</strong><span data-line="198"></span> we can open our <span data-line="198"></span><code class="code code1">Std.Strings</code><span data-line="198"></span> present, 
and see that it contains a shiny new <span data-line="199"></span><code class="code code1">ToNat</code><span data-line="199"></span> function!
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="201" data-line-first="202" style="display:block"><code data-line="202"><span style="color:blue">import</span> Std.Collections.Seq
<span style="color:blue">import</span> Std.Strings

<span style="color:blue">function</span> CalibrationValue(line: <span style="color:teal">string</span>): <span style="color:teal">nat</span> {
  <span style="color:blue">var</span> firstDigitIndex <span style="color:blue">:=</span> Seq.IndexByOption(line, <span style="color:darkgreen">/*</span><span style="color:darkgreen"> hmm... </span><span style="color:darkgreen">*/</span>);
  <span style="color:blue">var</span> lastDigitIndex <span style="color:blue">:=</span> Seq.LastIndexByOption(line, <span style="color:darkgreen">/*</span><span style="color:darkgreen"> hmm... </span><span style="color:darkgreen">*/</span>);

  <span style="color:blue">var</span> resultAsString <span style="color:blue">:=</span> [line[firstDigitIndex], line[lastDigitIndex]];

  Strings.ToNat(resultStr)
}</code></pre>
<p class="p noindent para-continued" data-line="215"><span data-line="215"></span>Even better, digging into the implementation of <span data-line="215"></span><code class="code code1">ToNat</code><span data-line="215"></span> leads us to what we need
to plug the holes we skipped over:
the <span data-line="217"></span><code class="code code1">Strings.DecimalConversion.IsDigitChar</code><span data-line="217"></span> predicate tells us if a character is a digit.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="219" data-line-first="220" style="display:block"><code data-line="220"><span style="color:blue">import</span> Std.Collections.Seq
<span style="color:blue">import</span> Std.Strings
<span style="color:blue">import</span> Std.Strings.DecimalConversion

<span style="color:blue">function</span> CalibrationValue(line: <span style="color:teal">string</span>): <span style="color:teal">nat</span> {
  <span style="color:blue">var</span> firstDigitIndex <span style="color:blue">:=</span> Seq.IndexByOption(line, DecimalConversion.IsDigitChar);
  <span style="color:blue">var</span> lastDigitIndex <span style="color:blue">:=</span> Seq.LastIndexByOption(line, DecimalConversion.IsDigitChar);

  <span style="color:darkgreen">// Error: incorrect type for selection into string (got Option&lt;nat&gt;)</span>
  <span style="color:blue">var</span> resultAsString <span style="color:blue">:=</span> [line[firstDigitIndex], line[lastDigitIndex]];

  Strings.ToNat(resultAsString)
}</code></pre>
<p class="p noindent para-continued" data-line="235"><span data-line="235"></span>Before we pat ourselves on the back too hard, though,
we notice this program doesn<span data-line="236"></span>&#39;<span data-line="236"></span>t typecheck yet:
<span data-line="237"></span><code class="code code1">firstDigitIndex</code><span data-line="237"></span> and <span data-line="237"></span><code class="code code1">lastDigitIndex</code><span data-line="237"></span> are not plain <span data-line="237"></span><code class="code code1">nat</code><span data-line="237"></span> values but <span data-line="237"></span><code class="code code1">Option&lt;nat&gt;</code><span data-line="237"></span> values.
And if we think about that a bit more,
it means our <span data-line="239"></span><code class="code code1">CalibrationValue</code><span data-line="239"></span> function <span data-line="239"></span><strong class="strong-star2">also</strong><span data-line="239"></span> needs to produce an <span data-line="239"></span><code class="code code1">Option&lt;nat&gt;</code><span data-line="239"></span>
instead of a <span data-line="240"></span><code class="code code1">nat</code><span data-line="240"></span>, because if <span data-line="240"></span><code class="code code1">line</code><span data-line="240"></span> doesn<span data-line="240"></span>&#39;<span data-line="240"></span>t contain any digits
we can<span data-line="241"></span>&#39;<span data-line="241"></span>t succeed in producing a calibration value either.
</p>
<p class="p indent" data-line="243"><span data-line="243"></span>Thankfully another nice thing about <span data-line="243"></span><code class="code code1">Std.Wrappers</code><span data-line="243"></span> is that the types in that module
are<span data-line="244"></span>&nbsp;<a href="https://dafny.org/dafny/DafnyRef/DafnyRef#sec-failure-compatible-types"><em class="em-star1">failure-compatible types</em></a><span data-line="244"></span>.
That means they can be used with the <span data-line="245"></span><code class="code code1">:-</code><span data-line="245"></span> <span data-line="245"></span>&#8220;elephant operator&#8221;<span data-line="245"></span>, which is a convenient way to propogate failure.
Let<span data-line="246"></span>&#39;<span data-line="246"></span>s change our return type, change the two regular <span data-line="246"></span><code class="code code1">:=</code><span data-line="246"></span> assignment operators to elephants instead,
and wrap up our result as an <span data-line="247"></span><code class="code code1">Option&lt;nat&gt;</code><span data-line="247"></span> so it matches our new return type:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="249" data-line-first="250" style="display:block"><code data-line="250"><span style="color:blue">import</span> Std.Collections.Seq
<span style="color:blue">import</span> Std.Strings
<span style="color:blue">import</span> Std.Strings.DecimalConversion
<span style="color:blue">import</span> Std.Wrappers

<span style="color:blue">function</span> CalibrationValue(line: <span style="color:teal">string</span>): Wrappers.Option&lt;<span style="color:teal">nat</span>&gt; {
  <span style="color:blue">var</span> firstDigitIndex :- Seq.IndexByOption(line, DecimalConversion.IsDigitChar);
  <span style="color:blue">var</span> lastDigitIndex :- Seq.LastIndexByOption(line, DecimalConversion.IsDigitChar);

  <span style="color:blue">var</span> resultAsString <span style="color:blue">:=</span> [line[firstDigitIndex], line[lastDigitIndex]];

  Wrappers.Some(Strings.ToNat(resultAsString))
}</code></pre>
<p class="p noindent para-continued" data-line="265"><span data-line="265"></span>Now if either attempt to find a digit fails,
the execution of the function body will immediately stop,
and that failure will become the result of the whole function.
At this point we have a valid Dafny program, and the IDE should reward our hard work
with<span data-line="269"></span>&nbsp;<a href="https://dafny.org/blog/2023/04/19/making-verification-compelling-visual-verification-feedback-for-dafny">a festive green gutter</a><span data-line="269"></span>
to indicate that it verifies successfully too!
</p>
<p class="p indent" data-line="272"><span data-line="272"></span>But let<span data-line="272"></span>&#39;<span data-line="272"></span>s pause for a second, because something very cool happened we may not have even noticed:
there<span data-line="273"></span>&#39;<span data-line="273"></span>s a precondition on <span data-line="273"></span><code class="code code1">ToNat(str)</code><span data-line="273"></span>: <span data-line="273"></span><code class="code code1">forall c &lt;- str :: DecimalConversion.IsDigitChar(c)</code><span data-line="273"></span>.
In other words, <span data-line="274"></span><code class="code code1">str</code><span data-line="274"></span> has to be a string with only digits.
That<span data-line="275"></span>&#39;<span data-line="275"></span>s why the return type of <span data-line="275"></span><code class="code code1">ToNat</code><span data-line="275"></span> is just <span data-line="275"></span><code class="code code1">nat</code><span data-line="275"></span>
and not something like a <span data-line="276"></span><code class="code code1">Wrappers.Option&lt;nat&gt;</code><span data-line="276"></span> or a <span data-line="276"></span><code class="code code1">Wrappers.Result&lt;nat, string&gt;</code><span data-line="276"></span>,
because it always succeeds in parsing the string.
</p>
<p class="p indent" data-line="279"><span data-line="279"></span>How does Dafny know that <span data-line="279"></span><code class="code code1">resultStr</code><span data-line="279"></span> is always parsable as a non-negative integer?
Because of the post-conditions of <span data-line="280"></span><code class="code code1">Seq.IndexByOption</code><span data-line="280"></span> and <span data-line="280"></span><code class="code code1">Seq.LastIndexByOption</code><span data-line="280"></span>,
Dafny actually <span data-line="281"></span><strong class="strong-star2">knows</strong><span data-line="281"></span> that they return the indexes of elements that satisfy the <span data-line="281"></span>&#8220;by&#8221;<span data-line="281"></span> predicate,
and therefore deduces that <span data-line="282"></span><code class="code code1">[line[firstDigitIndex], line[lastDigitIndex]]</code><span data-line="282"></span>
is a string that only contains digits.
I don<span data-line="284"></span>&#39;<span data-line="284"></span>t know about you but I think that<span data-line="284"></span>&#39;<span data-line="284"></span>s super cool.
</p><h3 id="sec-bits-and-bytes" class="h2" data-line="286" data-heading-depth="2" style="display:block"><span data-line="286"></span>Bits and Bytes</h3>
<p class="p noindent" data-line="288"><span data-line="288"></span>So now that we<span data-line="288"></span>&#39;<span data-line="288"></span>ve solved the most interesting bit of the puzzle,
we just have to feed the actual puzzle input into our Dafny code.
Let<span data-line="290"></span>&#39;<span data-line="290"></span>s assume we<span data-line="290"></span>&#39;<span data-line="290"></span>ve downloaded the puzzle to <span data-line="290"></span><code class="code code1">input.txt</code><span data-line="290"></span> in the current directory.
How the heck do we read this with Dafny?
</p>
<p class="p indent" data-line="293"><span data-line="293"></span>Good news! There<span data-line="293"></span>&#39;<span data-line="293"></span>s a standard library for that too: <span data-line="293"></span><code class="code code1">Std.FileIO</code><span data-line="293"></span>.
This one is very basic for now, explicitly meant for simple cases of reading and writing
file data for these kinds of use cases, rather than modelling entire file systems.
Here<span data-line="296"></span>&#39;<span data-line="296"></span>s our first attempt at a reusable utility for reading Advent of Code puzzle input
(because after all we have another month<span data-line="297"></span>&#39;<span data-line="297"></span>s worth of puzzles to solve!)
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="299" data-line-first="300" style="display:block"><code data-line="300"><span style="color:darkgreen">// Just the imports we need for this snippet.</span>
<span style="color:blue">import</span> Std.FileIO
<span style="color:blue">import</span> Std.Wrappers

<span style="color:blue">method</span> ReadPuzzleInput() <span style="color:blue">returns</span> (input: Wrappers.Result&lt;<span style="color:teal">string</span>, <span style="color:teal">string</span>&gt;) {
  <span style="color:darkgreen">// Error: incorrect return type for method out-parameter &#39;res&#39;</span>
  input <span style="color:blue">:=</span> FileIO.ReadBytesFromFile(<span style="color:maroon">&quot;</span><span style="color:maroon">input.txt</span><span style="color:maroon">&quot;</span>);
}</code></pre>
<p class="p noindent para-continued" data-line="310"><span data-line="310"></span>Note that <span data-line="310"></span><code class="code code1">FileIO.ReadBytesFromFile</code><span data-line="310"></span> is a <span data-line="310"></span><code class="code code1">method</code><span data-line="310"></span> rather than a <span data-line="310"></span><code class="code code1">function</code><span data-line="310"></span>,
and so <span data-line="311"></span><code class="code code1">ReadPuzzleInput</code><span data-line="311"></span> has to be as well.
A <span data-line="312"></span><code class="code code1">function</code><span data-line="312"></span> has to behave like a pure mathematical function
in order for Dafny to reason about the behavior of programs:
it has to produce the same output every time it is given the same input.
This is clearly not true for an operation to read the contents of a file,
so <span data-line="316"></span><code class="code code1">ReadBytesFromFile</code><span data-line="316"></span> has to be a method, which is allowed to behave non-deterministically.
</p>
<p class="p indent" data-line="318"><span data-line="318"></span>Again we have a typechecking error: we want to get the puzzle input as a string,
but <span data-line="319"></span><code class="code code1">ReadBytesFromFile</code><span data-line="319"></span> produces bytes, more specifically a <span data-line="319"></span><code class="code code1">seq&lt;bv8&gt;</code><span data-line="319"></span>.
<span data-line="320"></span><code class="code code1">bv8</code><span data-line="320"></span> is short for <span data-line="320"></span>&#8220;bit vector of length 8&#8221;<span data-line="320"></span>, equivalent to a byte.
We need to convert the bytes to characters somehow.
</p>
<p class="p indent" data-line="323"><span data-line="323"></span>Realistically, we<span data-line="323"></span>&#39;<span data-line="323"></span>d assume that the puzzle input is in ASCII and just convert every byte directly
to its corresponding character.
But let<span data-line="325"></span>&#39;<span data-line="325"></span>s pretend we<span data-line="325"></span>&#39;<span data-line="325"></span>re writing Real Code for the moment so I can show off the <span data-line="325"></span><code class="code code1">Std.Unicode</code><span data-line="325"></span> library;
hey you never know, later puzzles might have proper UTF8 content!
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="328" data-line-first="329" style="display:block"><code data-line="329"><span style="color:blue">import</span> Std.BoundedInts
<span style="color:blue">import</span> Std.FileIO
<span style="color:blue">import</span> Std.Unicode.UnicodeStringsWithUnicodeChar
<span style="color:blue">import</span> Std.Wrappers

<span style="color:blue">method</span> ReadPuzzleInput() <span style="color:blue">returns</span> (input: Wrappers.Result&lt;<span style="color:teal">string</span>, <span style="color:teal">string</span>&gt;) {
  <span style="color:blue">var</span> bytesAsBVs :- FileIO.ReadBytesFromFile(<span style="color:maroon">&quot;</span><span style="color:maroon">input.txt</span><span style="color:maroon">&quot;</span>);
  
  <span style="color:blue">var</span> bytes <span style="color:blue">:=</span> <span style="color:teal">seq</span>(|bytesAsBVs|, i <span style="color:purple">requires</span> <span class="constant" style="color:purple">0</span> &lt;= i &lt; |bytesAsBVs| =&gt; bytesAsBVs[i] <span style="color:blue">as</span> BoundedInts.uint8);
  input <span style="color:blue">:=</span> UnicodeStringsWithUnicodeChar.FromUTF8Checked(bytes).ToResult(<span style="color:maroon">&quot;</span><span style="color:maroon">Invalid UTF8</span><span style="color:maroon">&quot;</span>);
}</code></pre>
<p class="p noindent para-continued" data-line="342"><span data-line="342"></span>A few notes:
</p>
<ul class="ul list-star compact" data-line="344">
<li class="li ul-li list-star-li compact-li" data-line="344"><span data-line="344"></span>The <span data-line="344"></span><code class="code code1">UnicodeStringsWithUnicodeChar</code><span data-line="344"></span> module is named that way to emphasize that it is only
correct to use with the <span data-line="345"></span><code class="code code1">unicode-char = true</code><span data-line="345"></span> option, which is<span data-line="345"></span>&nbsp;<a href="https://dafny.org/blog/2023/03/03/dafny-4-released/#unicode-strings">on by default in Dafny 4.x</a><span data-line="345"></span>. 
</li>
<li class="li ul-li list-star-li compact-li" data-line="346"><span data-line="346"></span>The <span data-line="346"></span><code class="code code1">FromUTF8Checked</code><span data-line="346"></span> function takes in a <span data-line="346"></span><code class="code code1">seq&lt;uint8&gt;</code><span data-line="346"></span>, where <span data-line="346"></span><code class="code code1">uint8</code><span data-line="346"></span> is a <span data-line="346"></span><code class="code code1">newtype</code><span data-line="346"></span> definition from <span data-line="346"></span><code class="code code1">Std.BoundedInts</code><span data-line="346"></span>.
This library defines lots of common fixed-bit-width integer types that the Dafny compiler will map to
the native integer types of the target language for improved efficiency and memory usage.
</li>
<li class="li ul-li list-star-li compact-li" data-line="349"><span data-line="349"></span>Because <span data-line="349"></span><code class="code code1">bv8</code><span data-line="349"></span> is a distinct type from <span data-line="349"></span><code class="code code1">uint8</code><span data-line="349"></span>, we have to explicitly convert between them.
This is a side effect of the Dafny standard libraries having multiple independent contributions from various
projects, and you can expect future versions of Dafny to provide more versions of common utilities
to make combining things a bit smoother.
</li>
<li class="li ul-li list-star-li compact-li" data-line="353"><span data-line="353"></span><code class="code code1">FromUTF8Checked</code><span data-line="353"></span> returns an <span data-line="353"></span><code class="code code1">Option&lt;string&gt;</code><span data-line="353"></span>, but <span data-line="353"></span><code class="code code1">FileIO.ReadBytesFrom</code><span data-line="353"></span> returns a <span data-line="353"></span><code class="code code1">Result&lt;seq&lt;bv8&gt;, string&gt;</code><span data-line="353"></span>.
To unify with a common result type, we use <span data-line="354"></span><code class="code code1">Option.ToResult</code><span data-line="354"></span> to convert the former value to a <span data-line="354"></span><code class="code code1">Result</code><span data-line="354"></span>,
which is a handy and common trick. See<span data-line="355"></span>&nbsp;<a href="https://github.com/dafny-lang/dafny/blob/master/Source/DafnyStandardLibraries/src/Std/Wrappers.md">the documentation for <code class="code code1">Std.Wrappers</code></a><span data-line="355"></span> for more details.
</li></ul>
<h3 id="sec-sprinting-to-the-finish" class="h2" data-line="357" data-heading-depth="2" style="display:block"><span data-line="357"></span>Sprinting to the finish</h3>
<p class="p noindent" data-line="359"><span data-line="359"></span>Now let<span data-line="359"></span>&#39;<span data-line="359"></span>s put it all together and write our main method:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="361" data-line-first="362" style="display:block"><code data-line="362"><span style="color:blue">method</span> Main() {
  <span style="color:blue">var</span> input :- expect ReadPuzzleInput();

  <span style="color:blue">var</span> lines <span style="color:blue">:=</span> Seq.Split(s, <span style="color:maroon">&#39;</span><span style="color:gray">\n</span><span style="color:maroon">&#39;</span>);

  <span style="color:blue">var</span> calibrationValues :- expect Seq.MapWithResult(CalibrationValue, lines);

  <span style="color:blue">var</span> total <span style="color:blue">:=</span> Seq.FoldLeft((x, y) =&gt; x + y, <span class="constant" style="color:purple">0</span>, calibrationValues);
  <span style="color:blue">print</span> total, <span style="color:maroon">&quot;</span><span style="color:gray">\n</span><span style="color:maroon">&quot;</span>;
}</code></pre>
<p class="p noindent para-continued" data-line="374"><span data-line="374"></span>We<span data-line="374"></span>&#39;<span data-line="374"></span>ve used one more trick with failure-compatible types in this method:
<span data-line="375"></span><code class="code code1">:- expect</code><span data-line="375"></span>, a variation on the elephant operator to make <span data-line="375"></span>&#8220;assign or halt&#8221;<span data-line="375"></span> statements.
<span data-line="376"></span><code class="code code1">ReadPuzzleInput</code><span data-line="376"></span> returns a <span data-line="376"></span><code class="code code1">Result</code><span data-line="376"></span>, but if it fails there<span data-line="376"></span>&#39;<span data-line="376"></span>s nothing more we can do
in the main method than printing an error and exiting.
<span data-line="378"></span><code class="code code1">:- expect</code><span data-line="378"></span> means that if the right-hand side of the statement is a failure,
Dafny will immediately halt and print the failure value to the console.
This is particularly valuable for writing tests in Dafny.
Note also that the <span data-line="381"></span><code class="code code1">Seq</code><span data-line="381"></span> library continues to work hard for us,
splitting the input into lines,
mapping our <span data-line="383"></span><code class="code code1">CalibrationValue</code><span data-line="383"></span> function over the sequence of lines,
and summing the results into the final answer.
<span data-line="385"></span><code class="code code1">MapWithResult</code><span data-line="385"></span> is a short-circuiting variation of <span data-line="385"></span><code class="code code1">Map</code><span data-line="385"></span> where the mapped function can fail.
</p>
<p class="p indent" data-line="387"><span data-line="387"></span>If we put the sample input from the puzzle description into <span data-line="387"></span><code class="code code1">input.txt</code><span data-line="387"></span>
(not the actual puzzle input<span data-line="388"></span> <span data-line="388"></span>- I draw the line at publishing the answer in this blog post,
you<span data-line="389"></span>&#39;<span data-line="389"></span>re just going to have to run the solution yourself to get that!),
we can run our project and get<span data-line="390"></span>&#8230;<span data-line="390"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="392" data-line-first="393" style="display:block"><code data-line="393">% dafny run dfyconfig.toml

Dafny program verifier finished with <span class="constant" style="color:purple">3</span> verified, <span class="constant" style="color:purple">0</span> errors
<span class="constant" style="color:purple">142</span></code></pre>
<p class="p noindent para-continued" data-line="399"><span data-line="399"></span>Huzzah! We have a working solution to the first puzzle in less than 40 lines of Dafny code
(see below for the complete program),
all thanks to the Dafny standard libraries.
</p><!-- inline-dafny solution/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="405" data-line-first="406" style="display:block"><code data-line="406"><span style="color:blue">import</span> Std.BoundedInts
<span style="color:blue">import</span> Std.Collections.Seq
<span style="color:blue">import</span> Std.FileIO
<span style="color:blue">import</span> Std.Strings
<span style="color:blue">import</span> Std.Strings.DecimalConversion
<span style="color:blue">import</span> Std.Unicode.UnicodeStringsWithUnicodeChar
<span style="color:blue">import</span> Std.Wrappers

<span style="color:blue">method</span> Main() {
  <span style="color:blue">var</span> input :- expect ReadPuzzleInput();

  <span style="color:blue">var</span> lines := Seq.Split(input, <span style="color:maroon">&#39;</span><span style="color:gray">\n</span><span style="color:maroon">&#39;</span>);

  <span style="color:blue">var</span> calibrationValues :- expect Seq.MapWithResult(CalibrationValue, lines);

  <span style="color:blue">var</span> total := Seq.FoldLeft((x, y) =&gt; x + y, <span class="constant" style="color:purple">0</span>, calibrationValues);
  <span style="color:blue">print</span> total, <span style="color:maroon">&quot;</span><span style="color:gray">\n</span><span style="color:maroon">&quot;</span>;</code></pre><h3 id="sec-looking-back-and-looking-ahead" class="h2" data-line="426" data-heading-depth="2" style="display:block"><span data-line="426"></span>Looking back and looking ahead</h3>
<p class="p noindent" data-line="428"><span data-line="428"></span>The standard libraries are made possible by the recent support for
<span data-line="429"></span><a href="https://dafny.org/dafny/DafnyRef/DafnyRef#sec-doo-files">Dafny build artifacts</a><span data-line="429"></span>: 
compressed files containing the contents of an entire Dafny library along with metadata about how it was verified.
These files use the extension <span data-line="431"></span><code class="code code1">.doo</code><span data-line="431"></span> for Dafny Output Object<span data-line="431"></span><sup id="back-fn-1" ><a href="#fn-1" title="1.This is true, but the real reason for the name is a nod to the other Daphne from Scooby Doo.
&#8617;" class="footnote-ref localref" ><span class="footnote-label">1</span></a></sup><span data-line="431"></span>.
They play much the same role as <span data-line="432"></span><code class="code code1">.jar</code><span data-line="432"></span> files do for Java packages.
Internally, the standard libraries are packaged up as multiple <span data-line="433"></span><code class="code code1">.doo</code><span data-line="433"></span> files
and embedded as resources in the Dafny tool.
When <span data-line="435"></span><code class="code code1">--standard-libraries</code><span data-line="435"></span> is switched on,
the appropriate set of <span data-line="436"></span><code class="code code1">.doo</code><span data-line="436"></span> files are added as additional program source.
</p>
<p class="p indent" data-line="440"><span data-line="440"></span>This means the standard library source isn<span data-line="440"></span>&#39;<span data-line="440"></span>t re-verified every time your verify your Dafny project,
but the tool checks to make sure the options they were previously verified with
are compatible with the objects in your project.
In particular, this means if you try to use them with the older <span data-line="443"></span><code class="code code1">unicode-char = false</code><span data-line="443"></span> option,
you<span data-line="444"></span>&#39;<span data-line="444"></span>ll get an explicit error right away,
rather than potentially misusing code not meant for this mode.
</p>
<p class="p indent" data-line="447"><span data-line="447"></span>As excited as I am about having standard libraries in Dafny,
I<span data-line="448"></span>&#39;<span data-line="448"></span>ve also been nervous about having them for a long time:
I<span data-line="449"></span>&#39;<span data-line="449"></span>d be sad in the future if anyone gave Dafny a pass
because its footprint had grown too bloated for their environment.
Part of the reason the code is labelled as <span data-line="451"></span>&#8220;standard libraries&#8221;<span data-line="451"></span>, plural,
is to hint at the fact that they may be split up into different packages in the future.
Now that we have standard libraries in Dafny,
we<span data-line="454"></span>&#39;<span data-line="454"></span>re also setting our sights on helping Dafny users create their own shared libraries
and distributing them as pre-verified <span data-line="455"></span><code class="code code1">.doo</code><span data-line="455"></span> files in the future,
so such libraries also get this layer of protection against misuse.
</p>
<p class="p indent" data-line="458"><span data-line="458"></span>Another great improvement over the old <span data-line="458"></span><code class="code code1">dafny-lang/libraries</code><span data-line="458"></span> repository
is that the Dafny standard libraries are well-tested for all of the programming languages
that Dafny currently compiles to: C<span data-line="460"></span>#<span data-line="460"></span>, Go, Python, Java and JavaScript.
That means even libraries that depend on target language details
such as <span data-line="462"></span><code class="code code1">Std.FileIO</code><span data-line="462"></span> and <span data-line="462"></span><code class="code code1">Std.Concurrent</code><span data-line="462"></span>
are safe to use in multi-target Dafny projects.
</p><h3 id="sec-until-next-year" class="h2" data-line="465" data-heading-depth="2" style="display:block"><span data-line="465"></span>Until next year</h3>
<p class="p noindent" data-line="467"><span data-line="467"></span>I<span data-line="467"></span>&#39;<span data-line="467"></span>ll leave this post at that, as I<span data-line="467"></span>&#39;<span data-line="467"></span>ve got some catching up to do in the Advent of Code challenge before time runs out!
In the meantime, install Dafny 4.4, take the standard libraries for a test drive, 
and<span data-line="469"></span>&nbsp;<a href="https://github.com/dafny-lang/dafny/issues/new/choose">feel free to cut an issue</a><span data-line="469"></span> if you run into speed bumps.
Even better, if you have your own spiffy reusable Dafny code you keep in your back pocket,
<span data-line="471"></span><a href="https://github.com/dafny-lang/dafny/blob/master/CONTRIBUTING.md">create a pull request</a><span data-line="471"></span> and get it into the standard libraries!
</p><span data-line=""></span>
<div class="footnotes madoko">
<hr >

<div id="fn-1" class="footnote" data-line="438" style="line-adjust:0">
<p class="p noindent" data-line="438"><span data-line="438"></span><span class="footnote-before"><sup><span class="footnote-label">1</span>.</sup></span><span data-line="438"></span>This is true, but the real reason for the name is a nod to the other Daphne from Scooby Doo.
<span data-line="439"></span><span data-line="439"></span><a href="#back-fn-1" class="footnote-backref localref">&#8617;</a></p></div></div></div>
</body>

</html>
