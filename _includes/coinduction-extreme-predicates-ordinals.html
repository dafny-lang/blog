<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.2.3" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="author" content="K. Rustan M. Leino and Jean-Baptiste Tristan" />
  <meta name="description" content="Leino mode: Start numbering at 0" />
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote {
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013";
      position: absolute;
      margin-left: -1em;
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    text-align: left;
    white-space: pre;
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko span.math-rendering {
    display:inline-block;
    width:8em;
    overflow-x:auto;
    font-size:70%;
  }
  .madoko span.math-rendering::-webkit-scrollbar {
    width:4px;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 {
    margin-top: 1.22em;
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  {
    margin-top: 1ex;
  }
  .madoko h5, .madoko h6 {
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 {
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 {
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt,
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$']]},
       TeX: { 
         Macros: { mathid: ['\\mathit{#1\\hspace{0.1ex}}',1],
                   mathkw: ['\\mathsf{#1}',1],
                   mdmathindent: ['\\hspace{#1ex}',1],
                   mathpre: ['#1',1],
                 },
  
       }
    });
    MathJax.Hub.Register.StartupHook('TeX AMSmath Ready',function () { 
      MathJax.InputJax.TeX.Definitions.environment['mdmathpre'] = ['AMSarray',null,null,null,'l','0em','0em'];
    });
  </script>
  <script type="text/javascript" class="preview"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  
  <style>
    .pre-indented { margin-left: 20pt; }
        .pre-fenced { margin-left: 20pt; }
  </style>
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">
<p class="p noindent" data-line="65"><span data-line="65"></span><span data-line="65"></span> This blog post is a tutorial case study that formalizes and
proves a simple result in abstract interpretation, with applications
in compilation and program analysis.  The formalization uses several
advanced features in Dafny, including coinductive datatypes and least
and greatest predicates (so-called <span data-line="69"></span><em class="em-low1">extreme</em><span data-line="69"></span> predicates) that we
introduce along with some basic results in fixpoint theory.  The
presentation is aimed at users who have little or no prior experience
with these features in Dafny, or who may be users of such features in
other proof assistants.</p></div><h2 id="sec-overview" class="h1" data-line="76" data-heading-depth="1" style="display:block"><span data-line="76"></span><span class="heading-before"><span class="heading-label">0</span>.&#8194;</span><span data-line="76"></span>Introduction</h2>
<p class="p noindent" data-line="78"><span data-line="78"></span>The purpose of this tutorial is to show the use of two advanced features
in Dafny: coinductive datatypes and extreme predicates.  We do this by
considering a concrete problem that is of importance in compiler
construction and static analysis of programs and whose solution is an
instance of abstract interpretation
<span data-line="83"></span><span class="citations" style="target-element:bibitem">[<a href="#cousotcousot:abstractinterpretation" title="Patrick Cousot and Rhadia Cousot. 
Abstract interpretation: a unified lattice model for static analysis of programs by construction or approximation of fixpoints. 
In Conference Record of the Fourth Annual ACM Symposium on Principles of Programming Languages, pages 238&#8211;252. ACM, January 1977." class="bibref localref" style="target-element:bibitem"><span class="cite-number">1</span></a>]</span><span data-line="83"></span>. We choose this example because
its underlying theory is the same as that of coinductive datatypes and
extreme predicates: fixpoint theory.  Note that the presentation that
follows is informal, even though we use Dafny<span data-line="86"></span>&#39;<span data-line="86"></span>s syntax for
clarity. The complete details will be provided in the note as needed.
</p>
<p class="p indent" data-line="89"><span data-line="89"></span>Assume that we have some abstract type <span data-line="89"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="89"></span> equipped with some relation
<span data-line="90"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le</code><span data-line="90"></span> and a constant <span data-line="90"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="90"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="92" data-line-first="93" style="display:block"><code data-line="93"><span style="color:blue">type</span> A

<span style="color:blue">predicate</span> le(x: A, y: A)

<span style="color:blue">const</span> bot: A</code></pre>
<p class="p noindent para-continued" data-line="100"><span data-line="100"></span>We make the assumption that <span data-line="100"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="100"></span> is smaller than any other element of <span data-line="100"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="100"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="102" data-line-first="103" style="display:block"><code data-line="103"><span style="color:blue">lemma</span> BotSmallest(x: A)
  <span style="color:purple">ensures</span> le(bot, x)</code></pre>
<p class="p noindent para-continued" data-line="107"><span data-line="107"></span>Let <span data-line="107"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="107"></span> be a monotonic function on <span data-line="107"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="107"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="109" data-line-first="110" style="display:block"><code data-line="110"><span style="color:blue">function</span> F(x: A): A

<span style="color:blue">lemma</span> FMonotonic(x: A, y: A)
  <span style="color:purple">requires</span> le(x, y)
  <span style="color:purple">ensures</span> le(F(x), F(y))</code></pre>
<p class="p noindent para-continued" data-line="117"><span data-line="117"></span>A fixpoint of <span data-line="117"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="117"></span> is a solution to the mathematical equation
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="118" data-line-first="119" style="display:block"><code data-line="119">  x = F(x)</code></pre>
<p class="p noindent para-continued" data-line="122"><span data-line="122"></span>We can define it as a Dafny predicate
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="124" data-line-first="125" style="display:block"><code data-line="125"><span style="color:blue">predicate</span> IsFixpoint(x: A) {
  x == F(x)
}</code></pre>
<p class="p noindent para-continued" data-line="130"><span data-line="130"></span>An important result in fixpoint theory, a variant of the famous
Knaster-Tarski theorem<span data-line="131"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#knastertarski" title="A.&#160;Tarski. 
A lattice theoretical fixed point theorem and its applications." class="bibref localref" style="target-element:bibitem"><span class="cite-number">9</span></a>]</span><span data-line="131"></span>, tells us that if <span data-line="131"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">(A,le)</code><span data-line="131"></span> has no infinite
ascending chains (which we will formalize later) and since <span data-line="132"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="132"></span> is
monotonic, a fixpoint exists and can be obtained iteratively from the
value <span data-line="134"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="134"></span>.  Therefore, we would like to define the following
function in Dafny:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="137" data-line-first="138" style="display:block"><code data-line="138"><span style="color:blue">function</span> FindFixpoint(x: A): A {
  <span style="color:blue">if</span> IsFixpoint() <span style="color:blue">then</span>
    x
  <span style="color:blue">else</span>
    FindFixpoint(F(x))
}</code></pre>
<p class="p noindent para-continued" data-line="146"><span data-line="146"></span>where <span data-line="146"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint(bot)</code><span data-line="146"></span> computes the least fixpoint.
</p><!--
In the following, I think `value` should be `\bot`.
-->



<p class="p indent" data-line="152"><span data-line="152"></span>In practice, the type <span data-line="152"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="152"></span> is often defined as some abstract domain
that captures some, but not all, the information about the actual
values of a program. For example, one might consider an abstract
domain where all we know about a variable is whether its content stays
constant or not, whether it will eventually be used, or its possible
range of values.  In this context, <span data-line="157"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="157"></span> correspond to the absence
of information (before any collection of information has taken place)
and <span data-line="159"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="159"></span> is a function that captures how the program transforms the
abstract domain. For example, if the abstract domain is designed to
track if a variable is constant and with what value, and assuming a
statement of the form
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="164" data-line-first="165" style="display:block"><code data-line="165">y := x + <span class="constant" style="color:purple">1</span>;</code></pre>
<p class="p noindent para-continued" data-line="168"><span data-line="168"></span>if the abstract domain before the execution of this statement
associates <span data-line="169"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="169"></span> with some constant <span data-line="169"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="169"></span>, then we can extend the abstract
domain to include that <span data-line="170"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">y</code><span data-line="170"></span> is also a constant, with value <span data-line="170"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k + <span class="constant" style="color:purple">1</span></code><span data-line="170"></span>.
</p>
<p class="p indent" data-line="172"><span data-line="172"></span>What makes this example particularly interesting to define in Dafny is
that even though we know that the function terminates, we cannot
define it as easily as we might like, precisely because we need to
convince Dafny that it does terminate. Before we explain how to define
such a function, it is useful to step back and ask: why do functions
usually need to terminate in Dafny?  The fundamental reason is that we
want to ensure that we do not postulate the existence of functions
that do not actually exist. For example, if we were to postulate the
existence of a function <span data-line="180"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bad</code><span data-line="180"></span> from <span data-line="180"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:teal">nat</span></code><span data-line="180"></span> to <span data-line="180"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:teal">nat</span></code><span data-line="180"></span> that satisfies
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="182" data-line-first="183" style="display:block"><code data-line="183">bad(s)    ==    bad(s) + <span class="constant" style="color:purple">1</span></code></pre>
<p class="p noindent para-continued" data-line="186"><span data-line="186"></span>then we can prove that <span data-line="186"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="constant" style="color:purple">0</span> == <span class="constant" style="color:purple">1</span></code><span data-line="186"></span>. The net result of this postulate is
that Dafny<span data-line="187"></span>&#39;<span data-line="187"></span>s logic is now inconsistent.
</p>
<p class="p indent" data-line="189"><span data-line="189"></span>One way to ensure that we do not postulate the existence of functions
that do not actually exist is to ensure that they terminate on all of
their inputs. In most cases, this can be done by hinting to Dafny
(using a <span data-line="192"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:purple">decreases</span></code><span data-line="192"></span> clause) that there is a well-founded order and
that recursive calls yield progressively smaller values in that order.
But in the case of
function <span data-line="195"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="195"></span>, the problem is more abstract and we know that
it terminates because of some abstract mathematical theorem. Even if
we were to prove this theorem in Dafny, then we might be able to show
that the function <span data-line="198"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="198"></span> exists, but that is not good enough:
we want to be able to define this function in such a way that it can
be compiled to actual code and executed.
</p>
<p class="p indent" data-line="202"><span data-line="202"></span>Note that termination is just a means to an end: we know that
functions that terminate will not make the logic inconsistent. There
are other ways to define functions and guarantee that they are
consistent, for example by defining them as<span data-line="205"></span>&#8230;<span data-line="205"></span> fixpoints! Thankfully,
Dafny has everything we need to do this for predicates. To define our
function, we will use two key ideas.
</p>
<p class="p indent" data-line="209"><span data-line="209"></span>First, function <span data-line="209"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="209"></span> will not return the fixpoint. Instead,
we will use a coinductive datatype to define a potentially infinite
sequence of values, also known as a stream, and define <span data-line="211"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="211"></span>
as producing the sequence of its iterates
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="214" data-line-first="215" style="display:block"><code data-line="215">x, F(x), F(F(x)), F<span class="code-escaped"><sup>3</sup></span>(x), F<span class="code-escaped"><sup>4</sup></span>(x), ...</code></pre>
<p class="p noindent para-continued" data-line="218"><span data-line="218"></span>Second, we will show how we can work and reason over such potentially
infinite streams using extreme predicates. As mentioned previously,
the theory underlying coinductive datatypes and extreme predicates is
the same as the theory behind the termination of function
<span data-line="222"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="222"></span> and we will now introduce just enough to provide a
solid understanding of these features and the solution to our problem.
</p><h3 id="sec-prerequisites" class="h2" data-line="225" data-heading-depth="2" style="display:block"><span data-line="225"></span><span class="heading-before"><span class="heading-label">0.0</span>.&#8194;</span><span data-line="225"></span>Prerequisites</h3>
<p class="p noindent" data-line="227"><span data-line="227"></span>In this note, we assume that you have some familiarity with
Dafny. In particular, you should have some experience defining
and using predicates, functions, lemmas, datatypes, type parameters,
type parameter characteristics, the ghost modifier, and
Skolemization. This information can be found in the reference manual
and previous Dafny Power User notes.
</p><h2 id="sec-background" class="h1" data-line="234" data-heading-depth="1" style="display:block"><span data-line="234"></span><span class="heading-before"><span class="heading-label">1</span>.&#8194;</span><span data-line="234"></span>Background</h2><h3 id="sec-the-knaster-tarski-theorem" class="h2" data-line="236" data-heading-depth="2" style="display:block"><span data-line="236"></span><span class="heading-before"><span class="heading-label">1.0</span>.&#8194;</span><span data-line="236"></span>The Knaster-Tarski Theorem</h3>
<p class="p noindent" data-line="238"><span data-line="238"></span>To understand coinductive datatypes and extreme predicates, it is
useful to understand a special case of the Knaster-Tarski theorem<span data-line="239"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#knastertarski" title="A.&#160;Tarski. 
A lattice theoretical fixed point theorem and its applications." class="bibref localref" style="target-element:bibitem"><span class="cite-number">9</span></a>]</span><span data-line="239"></span>.
Recall that the powerset of a set <span data-line="240"></span><span class="math-inline">$U$</span><span data-line="240"></span>, written <span data-line="240"></span><span class="math-inline">$2^U$</span><span data-line="240"></span>, is the set of
all subsets of <span data-line="241"></span><span class="math-inline">$U$</span><span data-line="241"></span>. It contains at least the empty set <span data-line="241"></span><span class="math-inline">$\emptyset$</span><span data-line="241"></span> and
the set <span data-line="242"></span><span class="math-inline">$U$</span><span data-line="242"></span> itself and can be equipped with all the usual set
operations: union (<span data-line="243"></span><span class="math-inline">$\cup$</span><span data-line="243"></span>), intersection (<span data-line="243"></span><span class="math-inline">$\cap$</span><span data-line="243"></span>), and set inclusion
<span data-line="244"></span><span class="math-inline">$\subseteq$</span><span data-line="244"></span>.  Moreover, it has the following properties:
</p>
<ul class="ul list-star compact" data-line="246">
<li class="li ul-li list-star-li compact-li" data-line="246"><span data-line="246"></span>Set inclusion <span data-line="246"></span><span class="math-inline">$\subseteq$</span><span data-line="246"></span> makes <span data-line="246"></span><span class="math-inline">$2^U$</span><span data-line="246"></span> a partially ordered set
</li>
<li class="li ul-li list-star-li compact-li" data-line="247"><span data-line="247"></span><span class="math-inline">$\emptyset$</span><span data-line="247"></span> is smaller than any other set in <span data-line="247"></span><span class="math-inline">$2^U$</span><span data-line="247"></span>
</li>
<li class="li ul-li list-star-li compact-li" data-line="248"><span data-line="248"></span><span class="math-inline">$U$</span><span data-line="248"></span> is greater than any other set in <span data-line="248"></span><span class="math-inline">$2^U$</span><span data-line="248"></span>
</li>
<li class="li ul-li list-star-li compact-li" data-line="249"><span data-line="249"></span><span class="math-inline">$A \cup B$</span><span data-line="249"></span> is the smallest set that contains the elements of <span data-line="249"></span><span class="math-inline">$A$</span><span data-line="249"></span> and the elements of <span data-line="249"></span><span class="math-inline">$B$</span><span data-line="249"></span>
</li>
<li class="li ul-li list-star-li compact-li" data-line="250"><span data-line="250"></span><span class="math-inline">$A \cap B$</span><span data-line="250"></span> is the largest set that contains the elements that belong to both <span data-line="250"></span><span class="math-inline">$A$</span><span data-line="250"></span> and <span data-line="250"></span><span class="math-inline">$B$</span><span data-line="250"></span>
</li></ul>

<p class="p noindent para-continue" data-line="252"><span data-line="252"></span>The Knaster-Tarski theorem implies that for any set <span data-line="252"></span><span class="math-inline">$U$</span><span data-line="252"></span> and monotonic
function <span data-line="253"></span><span class="math-inline">$F \colon 2^U \to 2^U$</span><span data-line="253"></span>, <span data-line="253"></span><span class="math-inline">$F$</span><span data-line="253"></span> has a unique least fixpoint (that
is, smaller than any other fixpoint) defined as
</p>
<div class="math para-block" data-line="256">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="257" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\bigcap \left\{ x \in 2^U \mid F(x) \subseteq x \right\}
\]</span></div></div>
<p class="p noindent para-continued para-continue" data-line="260"><span data-line="260"></span>and a unique greatest fixpoint (that is, bigger than any other
fixpoint) defined as
</p>
<div class="math para-block" data-line="263">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="264" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\bigcup \left\{ x \in 2^U \mid x \subseteq F(x) \right\}
\]</span></div></div><h3 id="sec-coinductive-datatypes" class="h2" data-line="267" data-heading-depth="2" style="display:block"><span data-line="267"></span><span class="heading-before"><span class="heading-label">1.1</span>.&#8194;</span><span data-line="267"></span>Coinductive Datatypes</h3>
<p class="p noindent" data-line="269"><span data-line="269"></span>Before we explain coinductive datatypes, it is useful to review the
classic inductive datatypes that you should be familiar with.  When we
define a datatype such as
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="273" data-line-first="274" style="display:block"><code data-line="274"><span style="color:blue">datatype</span> List&lt;X&gt; = Nil | Cons(head: X, tail: List&lt;X&gt;)</code></pre>
<p class="p noindent para-continued" data-line="277"><span data-line="277"></span>where <span data-line="277"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">X</code><span data-line="277"></span> is a type parameter, we usually intuitively interpret
the type <span data-line="278"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">List&lt;X&gt;</code><span data-line="278"></span> as the set of all finite lists that carry values of
type <span data-line="279"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">X</code><span data-line="279"></span>, it is useful to take a more formal point of view. The
constructors <span data-line="280"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Nil</code><span data-line="280"></span> and <span data-line="280"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Cons</code><span data-line="280"></span> introduce an alphabet, and the typing
rules a grammar. These induce a set of possible strings. Let <span data-line="281"></span><span class="math-inline">$U$</span><span data-line="281"></span> be
the set of all such valid strings.  By defining <span data-line="282"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">List&lt;X&gt;</code><span data-line="282"></span> as a
datatype, we define a monotonic function <span data-line="283"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="283"></span> from <span data-line="283"></span><span class="math-inline">$2^U$</span><span data-line="283"></span> to <span data-line="283"></span><span class="math-inline">$2^U$</span><span data-line="283"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="285" data-line-first="286" style="display:block"><code data-line="286">F(S)  =  {Nil} + {Cons(v,l) | v <span style="color:blue">in</span> X and l <span style="color:blue">in</span> S}</code></pre>
<p class="p noindent para-continued para-continue" data-line="289"><span data-line="289"></span>and also specify that out of all the possible solutions of this
equation, if any, we are interested in the smallest one.  By the
Knaster-Tarski theorem, we indeed know that the least fixpoint of <span data-line="291"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="291"></span>
exists and is unique, and we define type <span data-line="292"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">List&lt;X&gt;</code><span data-line="292"></span> as
</p>
<div class="math para-block" data-line="294">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="295" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\bigcap \left\{ x \in 2^U \mid F(x) \subseteq x \right\}
\]</span></div></div>
<p class="p noindent para-continued" data-line="298"><span data-line="298"></span>and it is possible to prove that this corresponds to the natural
interpretation of <span data-line="299"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">List&lt;X&gt;</code><span data-line="299"></span> as the set of all finite lists where we
know that <span data-line="300"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Nil</code><span data-line="300"></span> belongs to that set, and that if some value <span data-line="300"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">l</code><span data-line="300"></span>
belongs to that set, so does <span data-line="301"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Cons(v,l)</code><span data-line="301"></span> for any value <span data-line="301"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">v</code><span data-line="301"></span> of type
<span data-line="302"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">X</code><span data-line="302"></span>.
</p>
<p class="p indent" data-line="304"><span data-line="304"></span>A coinductive datatype is defined essentially like an inductive one,
with the keyword <span data-line="305"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">codatatype</span></code><span data-line="305"></span> instead of <span data-line="305"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">datatype</span></code><span data-line="305"></span>.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="307" data-line-first="308" style="display:block"><code data-line="308"><span style="color:blue">codatatype</span> Stream&lt;X&gt; = Nil | Cons(head: X, tail: Stream&lt;X&gt;)</code></pre>
<p class="p noindent para-continued" data-line="311"><span data-line="311"></span>Coinductive datatypes also define a monotonic function <span data-line="311"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="311"></span> from <span data-line="311"></span><span class="math-inline">$2^U$</span><span data-line="311"></span>
to <span data-line="312"></span><span class="math-inline">$2^U$</span><span data-line="312"></span>, in this case the same one as <span data-line="312"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">List&lt;X&gt;</code><span data-line="312"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="314" data-line-first="315" style="display:block"><code data-line="315">F(S)  =  {Nil} + {Cons(v,l) | v <span style="color:blue">in</span> X and l <span style="color:blue">in</span> S}</code></pre>
<p class="p noindent para-continued para-continue" data-line="318"><span data-line="318"></span>However, in this case, we are interested in the largest solution to
this equation. Again, by the Knaster-Tarski theorem, we know that the
greatest fixpoint of <span data-line="320"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="320"></span> exists and is unique, and we define type
<span data-line="321"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Stream&lt;X&gt;</code><span data-line="321"></span> as
</p>
<div class="math para-block" data-line="323">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="324" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\bigcup \left\{ x \in 2^U \mid x \subseteq F(x) \right\}
\]</span></div></div>
<p class="p noindent para-continued" data-line="327"><span data-line="327"></span>and it is possible to prove that this set contains not only the finite
values, but also all the infinite values.
</p>
<p class="p indent" data-line="330"><span data-line="330"></span>In conclusion, even though the definitions of <span data-line="330"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">List</code><span data-line="330"></span> and <span data-line="330"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Stream</code><span data-line="330"></span> use
the same constructors and define the same monotonic function <span data-line="331"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="331"></span>, we
interpret them differently as either the least fixpoint of <span data-line="332"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="332"></span>
(datatypes) or the greatest fixpoint of <span data-line="333"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="333"></span> (codatatypes). In
general, the difference between these two interpretations is that the
datatype will only contain finite values, whereas the codatatype will
also contain infinite values.
</p>
<p class="p indent" data-line="338"><span data-line="338"></span>Finally, an important point of terminology. The codatatype <span data-line="338"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Stream</code><span data-line="338"></span> that
we use in this note should not be considered as the only possible
definition of the concept of a stream. The concept of a stream takes
on slightly different interpretation in object-oriented programming,
reactive programming, functional programming, or CS theory. 
</p><h3 id="sec-extreme-predicates" class="h2" data-line="344" data-heading-depth="2" style="display:block"><span data-line="344"></span><span class="heading-before"><span class="heading-label">1.2</span>.&#8194;</span><span data-line="344"></span>Extreme Predicates</h3>
<p class="p noindent" data-line="346"><span data-line="346"></span>Recall that when we define a recursive predicate, we are implicitly
postulating its existence. Obviously, to prevent logical
inconsistencies, we want to make sure that such predicates actually do
exist. One way to do this is to ensure that the predicate always
terminates. In some cases, this restriction is too strong.  For
example, we would like to be able to define the following predicate,
which even though it does not terminate, postulates the existence of a
function that does exist:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="355" data-line-first="356" style="display:block"><code data-line="356"><span style="color:blue">predicate</span> IsFinite(s: Stream) {
  s == Nil || IsFinite(s.tail)  <span style="color:darkgreen">// error: recursive call may not terminate</span>
}</code></pre>
<p class="p noindent para-continued" data-line="361"><span data-line="361"></span>The Knaster-Tarski theorem provides us with an alternative way to
define recursive predicates while ensuring consistency of the
logic. To understand why, recall that a predicate <span data-line="363"></span><span class="math-inline">$P(x)$</span><span data-line="363"></span> on some
domain <span data-line="364"></span><span class="math-inline">$X$</span><span data-line="364"></span> can be understood as the set of values for which it is
true: <span data-line="365"></span><span class="math-inline">$\{ x \in X \mid P(x) \}$</span><span data-line="365"></span>. The definition of a recursive
predicate can be understood not as a predicate directly, but first as
a function from <span data-line="367"></span><span class="math-inline">$2^X$</span><span data-line="367"></span> to <span data-line="367"></span><span class="math-inline">$2^X$</span><span data-line="367"></span>, and it is monotonic.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="369" data-line-first="370" style="display:block"><code data-line="370">IsFinite(S) == {Nil} + {Cons(v,l) | v <span style="color:blue">in</span> X and l <span style="color:blue">in</span> IsFinite(S)}</code></pre>
<p class="p noindent para-continued" data-line="373"><span data-line="373"></span>By the Knaster-Tarski theorem, we know that this equation has both
a unique least fixpoint and a unique greatest fixpoint, and these sets
correspond to predicates that exist and can be used without creating
inconsistencies. In the same way that we use two keywords, <span data-line="376"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">datatype</span></code><span data-line="376"></span>
and <span data-line="377"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">codatatype</span></code><span data-line="377"></span>, to indicate whether we are interested in the least
predicate or greatest predicate fixpoint solution, we use two keyword
phrases, <span data-line="379"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span> <span style="color:blue">predicate</span></code><span data-line="379"></span> and <span data-line="379"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">predicate</span></code><span data-line="379"></span> to denote which
solution we are interested in. In conclusion, we can define predicate
<span data-line="381"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite</code><span data-line="381"></span> as
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="383" data-line-first="384" style="display:block"><code data-line="384"><span style="color:blue">least</span> <span style="color:blue">predicate</span> IsFinite(s: Stream) { s == Nil || IsFinite(s.tail) }</code></pre><h3 id="sec-ordinal-numbers-and-transfinite-recursioninduction" class="h2" data-line="387" data-heading-depth="2" style="display:block"><span data-line="387"></span><span class="heading-before"><span class="heading-label">1.3</span>.&#8194;</span><span data-line="387"></span>Ordinal Numbers and Transfinite Recursion/Induction</h3>
<p class="p noindent" data-line="389"><span data-line="389"></span>Now that we have seen how to define coinductive datatypes and extreme
predicates, we need to explain how to effectively work with them, in
particular to define executable code.  To do this, we will introduce a
constructive variant of the Knaster-Tarski theorem. This theorem makes
use of the concept of ordinal numbers and we need to introduce
them. Ordinals are a somewhat abstract topic and it would not be
appropriate to provide a comprehensive and rigorous introduction in
these notes. Instead, we will try to provide an intuitive
understanding of what ordinals are, and concretely explain how to use
them.
</p>
<p class="p indent" data-line="400"><span data-line="400"></span>Recall that natural numbers have two fundamental usages: they can be
used to count (cardinal numbers), but also to order (ordinal
numbers). This is reflected in English with cardinals being named zero, one,
two, etc<span data-line="403"></span>&#8230;<span data-line="403"></span> while ordinals are named first, second, third,
etc<span data-line="404"></span>&#8230;<span data-line="404"></span> As long as we are counting or ordering a finite number of
objects, there is no difference between cardinals and ordinals, and we
think mostly in terms of the more abstract concept of natural
number. However, once you start counting or ordering an infinite
number of objects, cardinals and ordinals start to have a very
different behavior.
</p>
<p class="p indent" data-line="411"><span data-line="411"></span>In Dafny, you can effectively use ordinals with only a very limited
amount of knowledge about them. In fact, Dafny itself has a very
limited amount of knowledge about ordinals. Nevertheless, it can be
difficult (and unpleasant) to work with a concept for which we have no
intuition whatsover, so we will attempt to provide some explanation
based on the work of Per Martin-L<span data-line="416"></span>"<span data-line="416"></span>{o}f.<span data-line="416"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#martinlof:constructivemath" title="Per Martin-L&#246;f. 
Notes on Constructive Mathematics." class="bibref localref" style="target-element:bibitem"><span class="cite-number">8</span></a>]</span><span data-line="416"></span>
</p>
<p class="p indent" data-line="418"><span data-line="418"></span>All natural numbers are ordinal numbers, including 0. To use analogy,
you can think of these ordinals as waiting lines to some goal. 0 is a
waiting line with noone in it. 1 is a waiting line with one person in
it, etc<span data-line="421"></span>&#8230;<span data-line="421"></span>  Now, imagine that to get to your goal, you have to first
go through the waiting line with noone in it (0), then through the
waiting line with one person in it (1), then through the waiting line
with two persons in it (2), and so on, for every possible line that
corresponds to a natural number. This new <span data-line="425"></span>&#8220;meta&#8221;<span data-line="425"></span> line is made of an
infinite number of lines, and this is the ordinal number <span data-line="426"></span><span class="math-inline">$\omega$</span><span data-line="426"></span>. You
could also consider a waiting line where you start with the <span data-line="427"></span><span class="math-inline">$\omega$</span><span data-line="427"></span>
waiting line, followed by a waiting line with one person, and so
on<span data-line="429"></span>&#8230;<span data-line="429"></span> When we take existing waiting lines to create a <span data-line="429"></span>&#8220;meta&#8221;<span data-line="429"></span> line like
we did for <span data-line="430"></span><span class="math-inline">$\omega$</span><span data-line="430"></span>, we are creating what is called a <span data-line="430"></span><em class="em-low1">limit</em><span data-line="430"></span> ordinal,
written in general using the letter <span data-line="431"></span><span class="math-inline">$\lambda$</span><span data-line="431"></span>. Note that we have three
different kinds of waiting lines corresponding to three important
categories of ordinals: 0, limit ordinals, and all the other ordinals
such as <span data-line="434"></span><span class="math-inline">$3$</span><span data-line="434"></span>, <span data-line="434"></span><span class="math-inline">$\omega + 3$</span><span data-line="434"></span>, <span data-line="434"></span><span class="math-inline">$2 \omega + 4$</span><span data-line="434"></span>, etc<span data-line="434"></span>&#8230;<span data-line="434"></span>
Actually, there are only two cases, because 0 can be viewed as a limit
ordinal (namely, the limit of the empty set of things that precede it).
An ordinal that is not a limit ordinal is called a <span data-line="437"></span><em class="em-low1">successor</em><span data-line="437"></span> ordinal.
</p>
<p class="p indent" data-line="439"><span data-line="439"></span>Again, you don<span data-line="439"></span>&#39;<span data-line="439"></span>t need to know much more about ordinals to use them in
Dafny.  To summarize, every ordinal has the form <span data-line="440"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span> + n</code><span data-line="440"></span>, where
<span data-line="441"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span></code><span data-line="441"></span> is a <span data-line="441"></span><em class="em-low1">limit ordinal</em><span data-line="441"></span> and <span data-line="441"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">n</code><span data-line="441"></span> is a natural number. The
smallest limit ordinal is <span data-line="442"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="constant" style="color:purple">0</span></code><span data-line="442"></span>, so the ordinals include all the natural
numbers. Indeed, the natural numbers are the smallest ordinals, and
the smallest ordinal that is not a natural number is in mathematics
called <span data-line="445"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#969;</span></code><span data-line="445"></span>. In layman<span data-line="445"></span>&#39;<span data-line="445"></span>s terms, <span data-line="445"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#969;</span></code><span data-line="445"></span> is known as
<span data-line="446"></span>&#8220;infinity&#8221;<span data-line="446"></span>, but the there are far larger ordinals than this
<span data-line="447"></span>&#8220;infinity&#8221;<span data-line="447"></span>. Here<span data-line="447"></span>&#39;<span data-line="447"></span>s a small visualization of the <span data-line="447"></span>&#8220;ordinal number line&#8221;<span data-line="447"></span>
that may be helpful in understanding ordinals:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="450" data-line-first="451" style="display:block"><code data-line="451"><span class="constant" style="color:purple">0</span>, <span class="constant" style="color:purple">1</span>, <span class="constant" style="color:purple">2</span>, ..., <span class="code-escaped">&#969;</span>, <span class="code-escaped">&#969;</span>+<span class="constant" style="color:purple">1</span>, <span class="code-escaped">&#969;</span>+<span class="constant" style="color:purple">2</span>, ..., <span class="code-escaped">&#969;</span>*<span class="constant" style="color:purple">2</span>, <span class="code-escaped">&#969;</span>*<span class="constant" style="color:purple">2</span>+<span class="constant" style="color:purple">1</span>, <span class="code-escaped">&#969;</span>*<span class="constant" style="color:purple">2</span>+<span class="constant" style="color:purple">2</span>, ..., <span class="code-escaped">&#955;</span>, <span class="code-escaped">&#955;</span>+<span class="constant" style="color:purple">1</span>, <span class="code-escaped">&#955;</span>+<span class="constant" style="color:purple">2</span>, ...</code></pre>
<div class="remark para-end note" data-line="454" style="display:block;margin:1ex 0pt;padding-left:1em;border-left:0.25em teal solid;breakable:true">
<p class="p noindent" data-line="455"><span data-line="455"></span><span class="remark-before"><strong class="strong-star2">Remark&#160;<span class="remark-label">0</span>.</strong></span><span data-line="455"></span><br>
<span data-line="456"></span>Dafny doesn<span data-line="456"></span>&#39;<span data-line="456"></span>t actually know many properties of the built-in type <span data-line="456"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:teal">ORDINAL</span></code><span data-line="456"></span>. It
only knows enough to enable working with extreme predicates and their
prefix predicates. In fact, there<span data-line="458"></span>&#39;<span data-line="458"></span>s not even any syntax for writing
down ordinals other than the ordinals that are natural numbers. The
notation <span data-line="460"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#969;</span></code><span data-line="460"></span> and <span data-line="460"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span></code><span data-line="460"></span> we used above is not Dafny
syntax.</p></div>
<p class="p indent" data-line="463"><span data-line="463"></span>In the same way that it is possible to define a function by recursion
over the naturals or prove a property by induction over the naturals,
it is possible to define a function by recursion over the ordinals and
prove properties by induction over the ordinals. These
recursion/induction principles generalize that of the natural and you
need to consider three cases: 0, limit ordinals, and all the other
ordinals that have predecessors. Unlike with naturals where every
decreasing sequence ends at 0 in the worst-case, ordinals can decrease
to any limit ordinal, and this is why we need to define a function or
prove a property by considering not just 0 as a base case, but every
possible limit ordinal. That is, the ordinals are <span data-line="473"></span><em class="em-low1">well-founded</em><span data-line="473"></span>, and
really this is all we need to know about them in principle. In
practice, you need to know that there are 3 instead of two cases to
consider, and we will show a detailed example later in that
note. Finally, a point of terminology: recursion and induction on
ordinals are called transfinite recursion and transfinite induction.
</p><h3 id="sec-the-constructive-knaster-tarski-theorem" class="h2" data-line="480" data-heading-depth="2" style="display:block"><span data-line="480"></span><span class="heading-before"><span class="heading-label">1.4</span>.&#8194;</span><span data-line="480"></span>The Constructive Knaster-Tarski Theorem</h3>
<p class="p noindent" data-line="482"><span data-line="482"></span>The Knaster-Tarski theorem tells us under what conditions a fixpoint exists, and even
characterizes the least and greatest fixpoints. This is key to the introduction of codatatypes
and extreme predicates in the Dafny language, but of no help to a Dafny programmer who
wants to effectively compute a fixpoint. Fortunately, there is a constructive version
of the Knaster-Tarski theorem<span data-line="486"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#cousotcousot:constructivetarski" title="P. Cousot and R. Cousot. 
Constructive versions of Tarski&#39;s fixed point theorems." class="bibref localref" style="target-element:bibitem"><span class="cite-number">0</span></a>]</span><span data-line="486"></span>. Stating it formally would require too much formalism,
but in essence, it states that if <span data-line="487"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="487"></span> is a monotonic
function, then the least fixpoint of <span data-line="488"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="488"></span> can be obtained by iteration of <span data-line="488"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="488"></span> over the ordinals.
</p>
<p class="p indent" data-line="490"><span data-line="490"></span>Our explanations will once again use the definition of <span data-line="490"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite</code><span data-line="490"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="492" data-line-first="493" style="display:block"><code data-line="493"><span style="color:blue">least</span> <span style="color:blue">predicate</span> IsFinite(s: Stream) {
  s == Nil || IsFinite(s.tail)  
}</code></pre>
<p class="p noindent para-continued" data-line="498"><span data-line="498"></span>which can be understood as a monotonic recursive function from <span data-line="498"></span><span class="math-inline">$2^X$</span><span data-line="498"></span> to <span data-line="498"></span><span class="math-inline">$2^X$</span><span data-line="498"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="499" data-line-first="500" style="display:block"><code data-line="500">  IsFinite(S) == {Nil} + {Cons(v,l) | v <span style="color:blue">in</span> X and l <span style="color:blue">in</span> IsFinite(S)}</code></pre>
<p class="p noindent para-continued" data-line="503"><span data-line="503"></span>which itself corresponds to the proposition
</p><table class="columns block" data-line="505">
<tbody><tr><td class="column" data-line="506">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="507" data-line-first="508" style="display:block"><code data-line="508">IsFinite(s)</code></pre></td><td class="column" data-line="511">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="512" data-line-first="513" style="display:block"><code data-line="513">&lt;==&gt;    s == Nil || IsFinite(s.tail)</code></pre></td></tr></tbody></table>
<p class="p noindent" data-line="518"><span data-line="518"></span>In order to express transfinite iterations (or inductions for proofs), 
Dafny defines a <span data-line="519"></span><em class="em-low1">prefix predicate</em><span data-line="519"></span> <span data-line="519"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="519"></span>. The prefix predicate takes
one more parameter than the least predicate does, and this parameter can
be understood as an upper bound on the number of times the left-hand side
of the recurrence equation can be rewritten into the right-hand side.
This is easier to understand in symbols. For any <span data-line="523"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">n</code><span data-line="523"></span>, we have
</p><table class="columns block" data-line="525">
<tbody><tr><td class="column" data-line="526">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="527" data-line-first="528" style="display:block"><code data-line="528">IsFinite#<span class="code-escaped"><sup>0</sup></span>(s)
IsFinite#<span class="code-escaped"><sup>n+1</sup></span>(s)</code></pre></td><td class="column" data-line="532">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="533" data-line-first="534" style="display:block"><code data-line="534">&lt;==&gt;    <span style="color:blue">false</span>
&lt;==&gt;    s == Nil || IsFinite#<span class="code-escaped"><sup>n</sup></span>(s.tail)</code></pre></td></tr></tbody></table>
<p class="p noindent" data-line="541"><span data-line="541"></span>Here, we<span data-line="541"></span>&#39;<span data-line="541"></span>ve written the extra parameter as a superscript, to suggest
applying the function some number of times. For a limit ordinal <span data-line="542"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span></code><span data-line="542"></span>, we define <span data-line="542"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#<span class="code-escaped"><sup>&#955;</sup></span></code><span data-line="542"></span>
as the disjunction over all smaller ordinals. Here<span data-line="543"></span>&#39;<span data-line="543"></span>s our new definition,
where <span data-line="544"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">o</code><span data-line="544"></span> is any ordinal and <span data-line="544"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span></code><span data-line="544"></span> is any limit ordinal:
</p><table class="columns block" data-line="546">
<tbody><tr><td class="column" data-line="547">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="548" data-line-first="549" style="display:block"><code data-line="549">IsFinite#<span class="code-escaped"><sup>0</sup></span>(s)
IsFinite#<span class="code-escaped"><sup>o+1</sup></span>(s)
IsFinite#<span class="code-escaped"><sup>&#955;</sup></span>(s)</code></pre></td><td class="column" data-line="554">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="555" data-line-first="556" style="display:block"><code data-line="556">&lt;==&gt;    <span style="color:blue">false</span>
&lt;==&gt;    s == Nil || IsFinite#<span class="code-escaped"><sup>o</sup></span>(s.tail)
&lt;==&gt;    <span class="code-escaped"><span class="math-inline">$\bigvee$</span><sub>o &lt; &#955;</sub></span> (s == Nil || IsFinite#<span class="code-escaped"><sup>o</sup></span>(s.tail))</code></pre></td></tr></tbody></table>
<p class="p noindent" data-line="563"><span data-line="563"></span>Since <span data-line="563"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="constant" style="color:purple">0</span></code><span data-line="563"></span> is a limit ordinal and there is no ordinal that<span data-line="563"></span>&#39;<span data-line="563"></span>s smaller,
the first line is a special case of the third line. Also, it is useful to
realize that another way to write a large disjunction is to write <span data-line="565"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped"><span class="math-inline">$\exists$</span></span></code><span data-line="565"></span>
instead of <span data-line="566"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped"><span class="math-inline">$\bigvee$</span></span></code><span data-line="566"></span>. Thus, we can use a more Dafny-like notation to write
the definition of <span data-line="567"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="567"></span>:
</p><table class="columns block" data-line="569">
<tbody><tr><td class="column" data-line="570">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="571" data-line-first="572" style="display:block"><code data-line="572">IsFinite#<span class="code-escaped"><sup>o+1</sup></span>(s)
IsFinite#<span class="code-escaped"><sup>&#955;</sup></span>(s)</code></pre></td><td class="column" data-line="576">
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="577" data-line-first="578" style="display:block"><code data-line="578">&lt;==&gt;    s == Nil || IsFinite#<span class="code-escaped"><sup>o</sup></span>(s.tail)
&lt;==&gt;    <span style="color:blue">exists</span> o :: o &lt; <span class="code-escaped">&#955;</span> &amp;&amp; (s == Nil || IsFinite#<span class="code-escaped"><sup>o</sup></span>(s.tail))</code></pre></td></tr></tbody></table>
<p class="p noindent" data-line="584"><span data-line="584"></span>Using the same notation to write <span data-line="584"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite</code><span data-line="584"></span> in terms of <span data-line="584"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="584"></span>, we have
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="586" data-line-first="587" style="display:block"><code data-line="587">IsFinite(s)    &lt;==&gt;    <span style="color:blue">exists</span> o :: IsFinite#<span class="code-escaped"><sup>o</sup></span>(s)</code></pre><h2 id="sec-streams" class="h1" data-line="590" data-heading-depth="1" style="display:block"><span data-line="590"></span><span class="heading-before"><span class="heading-label">2</span>.&#8194;</span><span data-line="590"></span>Streams</h2>
<p class="p noindent" data-line="592"><span data-line="592"></span>The type <span data-line="592"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Stream</code><span data-line="592"></span>, parameterized by a type <span data-line="592"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">X</code><span data-line="592"></span> that stands for the payload of the
stream, has a familiar shape:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="595" data-line-first="596" style="display:block"><code data-line="596"><span style="color:blue">codatatype</span> Stream&lt;X&gt; = Nil | Cons(head: X, tail: Stream&lt;X&gt;)</code></pre>
<p class="p noindent para-continued" data-line="599"><span data-line="599"></span>In order to solve our simple abstract interpretation problem, we will need but the simplest
stream operations:
</p>
<ul class="ul list-star compact" data-line="602">
<li class="li ul-li list-star-li compact-li" data-line="602"><span data-line="602"></span>A predicate to distinguish finite from infinite streams
</li>
<li class="li ul-li list-star-li compact-li" data-line="603"><span data-line="603"></span>A function that computes the Length of a finite stream
</li>
<li class="li ul-li list-star-li compact-li" data-line="604"><span data-line="604"></span>A function that returns the last value of a nonempty, finite stream
</li></ul>
<h3 id="sec-isfinite" class="h2" data-line="606" data-heading-depth="2" style="display:block"><span data-line="606"></span><span class="heading-before"><span class="heading-label">2.0</span>.&#8194;</span><span data-line="606"></span>Distinguishing Finite and Infinite Streams</h3>
<p class="p noindent" data-line="608"><span data-line="608"></span>A stream is finite if it eventually contains <span data-line="608"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Nil</code><span data-line="608"></span>; otherwise, it is infinite.
As explained previously, if we were to attempt to define this predicate as a standard predicate
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="611" data-line-first="612" style="display:block"><code data-line="612"><span style="color:blue">predicate</span> IsFinite(s: Stream) {
  s == Nil || IsFinite(s.tail)  <span style="color:darkgreen">// error: recursive call may not terminate</span>
}</code></pre>
<p class="p noindent para-continued" data-line="617"><span data-line="617"></span>Dafny would report an error, because it<span data-line="617"></span>&#39;<span data-line="617"></span>s unable to prove termination of the
recursive call. Indeed, if <span data-line="618"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s</code><span data-line="618"></span> is an infinite stream, the recursive call would
fail to terminate. Therefore, predicate <span data-line="619"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite</code><span data-line="619"></span> must be defined as an extreme predicate:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="621" data-line-first="622" style="display:block"><code data-line="622"><span style="color:blue">least</span> <span style="color:blue">predicate</span> IsFinite(s: Stream) {
  s == Nil || IsFinite(s.tail)
}</code></pre>
<div id="ex-isfinite-prime" class="exercise para-end" data-line="627" style="display:block;margin:1ex 0pt;padding-left:1em;border-left:0.25em blue solid;breakable:true">
<p class="p noindent" data-line="628"><span data-line="628"></span><span class="exercise-before"><strong class="strong-star2">Exercise&#160;<span class="exercise-label">0</span>.</strong> <span class="theorem-caption"></span><br>
</span><span data-line="628"></span>Definite <span data-line="628"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite&#39;</code><span data-line="628"></span> like <span data-line="628"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite</code><span data-line="628"></span> above, but using <span data-line="628"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">predicate</span></code><span data-line="628"></span>.
Then, prove that <span data-line="629"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite&#39;(s)</code><span data-line="629"></span> holds for any stream <span data-line="629"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s</code><span data-line="629"></span> (which strongly
suggests that <span data-line="630"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite&#39;</code><span data-line="630"></span> does not match our understanding of what being
finite means). You may need to read more of this note before you know how to
prove this property, but we give the answer in Appendix<span data-line="632"></span>&nbsp;<a href="#app-answers" title="A.&#8194;Answer to Exercises" class="localref" style="target-element:h1"><span class="heading-label">A</span></a><span data-line="632"></span>.</p></div><h3 id="sec-streams" class="h2" data-line="635" data-heading-depth="2" style="display:block"><span data-line="635"></span><span class="heading-before"><span class="heading-label">2.1</span>.&#8194;</span><span data-line="635"></span>Computing the Length of a Finite Stream</h3>
<p class="p noindent" data-line="637"><span data-line="637"></span>If a stream is finite, we would like to be able to compute its length. 
This is not as simple as it might seem at first glance, and provides an
interesting use case to better understand the use of ordinals. The specification
of the <span data-line="640"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="640"></span> function is given by
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="642" data-line-first="643" style="display:block"><code data-line="643"><span style="color:blue">function</span> Length(s: Stream): <span style="color:teal">nat</span>
  <span style="color:purple">requires</span> IsFinite(s)</code></pre>
<p class="p noindent para-continued" data-line="647"><span data-line="647"></span>It uses the predicate <span data-line="647"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite</code><span data-line="647"></span> as part of its <span data-line="647"></span><em class="em-low1">precondition</em><span data-line="647"></span>, as indicated
by the <span data-line="648"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:purple">requires</span></code><span data-line="648"></span> keyword. Since Dafny enforces preconditions at call sites,
there is no way that <span data-line="649"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="649"></span> could ever be invoked on an infinite stream.
</p>
<p class="p indent" data-line="651"><span data-line="651"></span>We<span data-line="651"></span>&#39;<span data-line="651"></span>re not going to use the body of <span data-line="651"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="651"></span> directly. Instead, we will use
the properties of <span data-line="652"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="652"></span> that are stated by the following lemma:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="654" data-line-first="655" style="display:block"><code data-line="655"><span style="color:blue">lemma</span> AboutLength(s: Stream)
  <span style="color:purple">requires</span> s != Nil &amp;&amp; IsFinite(s)
  <span style="color:purple">ensures</span> Length(s) == <span class="constant" style="color:purple">1</span> + Length(s.tail)</code></pre>
<p class="p noindent para-continued" data-line="660"><span data-line="660"></span>For a nonempty, finite stream <span data-line="660"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s</code><span data-line="660"></span>, this lemma says that <span data-line="660"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s.tail</code><span data-line="660"></span> is also
finite and that <span data-line="661"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(s)</code><span data-line="661"></span> is <span data-line="661"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="constant" style="color:purple">1</span></code><span data-line="661"></span> more than <span data-line="661"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(s.tail)</code><span data-line="661"></span>. To obtain
these properties, simply call the lemma. In fact, in Dafny, you <span data-line="662"></span><em class="em-low1">have</em><span data-line="662"></span> to
call the lemma explicitly to make use of what it states<span data-line="663"></span>&#8212;<span data-line="663"></span>there is no
<span data-line="664"></span>&#8220;automatically applied&#8221;<span data-line="664"></span> lemma, as there is in some other proof assistants
(see Dafny Power User note<span data-line="665"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#krml265:callinglemmasautomatically" title="K.&#160;Rustan&#160;M. Leino. 
Dafny power user: Calling lemmas automatically." class="bibref localref" style="target-element:bibitem"><span class="cite-number">6</span></a>]</span><span data-line="665"></span> for more
information).
</p>
<p class="p indent" data-line="668"><span data-line="668"></span>A first attempt at defining <span data-line="668"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="668"></span> might be
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="670" data-line-first="671" style="display:block"><code data-line="671"><span style="color:blue">function</span> Length(s: Stream): <span style="color:teal">nat</span>
  <span style="color:purple">requires</span> IsFinite(s)
{
  <span style="color:blue">if</span> s == Nil <span style="color:blue">then</span> <span class="constant" style="color:purple">0</span> <span style="color:blue">else</span> <span class="constant" style="color:purple">1</span> + Length(s.tail) <span style="color:darkgreen">// error: cannot prove termination</span>
}</code></pre>
<p class="p noindent para-continued" data-line="678"><span data-line="678"></span>Alas, despite the precondition <span data-line="678"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite(s)</code><span data-line="678"></span>, the termination proof for the
recursive call does not go through. To sort this out will take some effort.
</p><h4 id="sec-defining-length-from-a-prefix-predicate" class="h3" data-line="681" data-heading-depth="3" style="display:block"><span data-line="681"></span><span class="heading-before"><span class="heading-label">2.1.0</span>.&#8194;</span><span data-line="681"></span>Defining <span data-line="681"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="681"></span> from a prefix predicate</h4>
<p class="p noindent" data-line="683"><span data-line="683"></span>The problem with writing a straightforward
definition of <span data-line="684"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="684"></span> is that we need to prove termination. Since for
the precondition <span data-line="685"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite(s)</code><span data-line="685"></span> there is an ordinal <span data-line="685"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="685"></span> such that <span data-line="685"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#<span class="code-escaped"><sup>k</sup></span></code><span data-line="685"></span>,
we can hope to use that <span data-line="686"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="686"></span> to prove termination.
</p>
<p class="p indent" data-line="688"><span data-line="688"></span>Our next attempt is therefore to define a function <span data-line="688"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="688"></span> as follows:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="690" data-line-first="691" style="display:block"><code data-line="691"><span style="color:blue">function</span> Length&#39;(<span style="color:blue">ghost</span> k: <span style="color:teal">ORDINAL</span>, s: Stream): <span style="color:teal">nat</span>
  <span style="color:purple">requires</span> IsFinite#[k](s)
{
  <span style="color:blue">if</span> s == Nil <span style="color:blue">then</span>
    <span class="constant" style="color:purple">0</span>
  <span style="color:blue">else</span> <span style="color:blue">if</span> k.Offset != <span class="constant" style="color:purple">0</span> <span style="color:blue">then</span>
    <span class="constant" style="color:purple">1</span> + Length&#39;(k - <span class="constant" style="color:purple">1</span>, s.tail)
  <span style="color:blue">else</span>
    <span style="color:blue">var</span> k&#39; :| k&#39; &lt; k &amp;&amp; IsFinite#[k&#39;](s);
    Length&#39;(k&#39;, s)
}</code></pre>
<p class="p noindent para-continued" data-line="704"><span data-line="704"></span>There are several things to explain.
</p>
<p class="p indent" data-line="706"><span data-line="706"></span>In our explanations in the background section, we notated the extra parameter
of the prefix predicate as a superscript. In Dafny syntax, the extra parameter
also has a special notation, but rather than putting it in a superscript, it
is given in square brackets. You see this in the precondition of <span data-line="709"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="709"></span>.
</p>
<p class="p indent" data-line="711"><span data-line="711"></span>We intend the function to be one that can be compiled and run, but the
parameter <span data-line="712"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="712"></span> is used only in the proof of termination. Therefore, we declare
<span data-line="713"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="713"></span> to be a ghost parameter. All specifications in Dafny are ghost, so they
don<span data-line="714"></span>&#39;<span data-line="714"></span>t cost anything at run time. Moreover, lemmas, extreme predicates, and
prefix predicates are always ghost.
</p>
<p class="p indent" data-line="717"><span data-line="717"></span>After the <span data-line="717"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s == Nil</code><span data-line="717"></span> case, we proceed according to the two cases of the definition
of the prefix predicate <span data-line="718"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="718"></span>. That is, we take one action if <span data-line="718"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="718"></span> is
not a limit ordinal and another action if <span data-line="719"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="719"></span> is a limit ordinal. Since every
ordinal has the form <span data-line="720"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span> + n</code><span data-line="720"></span> for some limit ordinal <span data-line="720"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span class="code-escaped">&#955;</span></code><span data-line="720"></span> and natural
number <span data-line="721"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">n</code><span data-line="721"></span>, we can tell if an ordinal is a limit ordinal or not by inspecting
the <span data-line="722"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">n</code><span data-line="722"></span> part. In Dafny, you obtain this <span data-line="722"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">n</code><span data-line="722"></span> part using the member <span data-line="722"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Offset</code><span data-line="722"></span> of
an ordinal. Thus, the test <span data-line="723"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k.Offset != <span class="constant" style="color:purple">0</span></code><span data-line="723"></span> says that <span data-line="723"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="723"></span> is not a limit ordinal.
</p>
<p class="p indent" data-line="725"><span data-line="725"></span>In the final case (where <span data-line="725"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="725"></span> is limit ordinal), the definition of <span data-line="725"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#<span class="code-escaped"><sup>k</sup></span></code><span data-line="725"></span>
tells us that there is a smaller ordinal <span data-line="726"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="726"></span> for which <span data-line="726"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#<span class="code-escaped"><sup>k&#39;</sup></span></code><span data-line="726"></span> holds.
To obtain the smaller ordinal, we introduce a local variable <span data-line="727"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="727"></span> and (using
the assign-such-that operator <span data-line="728"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="728"></span>) assign to it a value such that the condition
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="730" data-line-first="731" style="display:block"><code data-line="731">k&#39; &lt; k &amp;&amp; IsFinite#[k&#39;](s)</code></pre>
<p class="p noindent para-continued" data-line="734"><span data-line="734"></span>holds. There is a proof obligation that a value for such a <span data-line="734"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="734"></span> exists, but
that proof obligation follows directly from the definition of <span data-line="735"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="735"></span>
and the fact that <span data-line="736"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="736"></span> is a limit ordinal whenever the last <span data-line="736"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">else</span></code><span data-line="736"></span> branch is
taken.
</p>
<p class="p indent" data-line="739"><span data-line="739"></span>Our definition of <span data-line="739"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="739"></span> is straightforward but problematic.
The function<span data-line="740"></span>&#39;<span data-line="740"></span>s body uses <span data-line="740"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="740"></span>, which is ghost. Moreover, even if we
changed <span data-line="741"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="741"></span> to make it be a non-ghost (that is, compiled) parameter, then the
use of <span data-line="742"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="742"></span> in the assignment to <span data-line="742"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="742"></span> makes <span data-line="742"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="742"></span> ghost, so we can<span data-line="742"></span>&#39;<span data-line="742"></span>t
use it in a compiled function body. If we change <span data-line="743"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="743"></span> to be a ghost
function, like:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="746" data-line-first="747" style="display:block"><code data-line="747"><span style="color:blue">ghost</span> <span style="color:blue">function</span> Length&#39;(k: <span style="color:teal">ORDINAL</span>, s: Stream): <span style="color:teal">nat</span></code></pre>
<p class="p noindent para-continued" data-line="750"><span data-line="750"></span>then the definition we gave is fine. For the purposes of the program-analysis
theorem we will prove in this note, we don<span data-line="751"></span>&#39;<span data-line="751"></span>t need the <span data-line="751"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="751"></span> function to
be compiled, so this would be alright. However, for a general library for
streams, we really ought to provide a compiled <span data-line="753"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="753"></span> function.
</p>
<p class="p indent" data-line="755"><span data-line="755"></span>So, let<span data-line="755"></span>&#39;<span data-line="755"></span>s rewrite the body of <span data-line="755"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="755"></span>.
</p><h4 id="sec-reducing-k-to-a-sufficiently-small-value" class="h3" data-line="757" data-heading-depth="3" style="display:block"><span data-line="757"></span><span class="heading-before"><span class="heading-label">2.1.1</span>.&#8194;</span><span data-line="757"></span>Reducing <span data-line="757"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="757"></span> to a sufficiently small value</h4>
<p class="p noindent" data-line="759"><span data-line="759"></span>We can write a compiling body for <span data-line="759"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="759"></span> from the realization that any
recursion in our first attempt only reduces the value of <span data-line="760"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="760"></span>. Let<span data-line="760"></span>&#39;<span data-line="760"></span>s do that
in a separate function, <span data-line="761"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK</code><span data-line="761"></span>. The idea is that <span data-line="761"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK(k, s)</code><span data-line="761"></span>
first follows smaller limit ordinals that don<span data-line="762"></span>&#39;<span data-line="762"></span>t affect the value of
<span data-line="763"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#[k]</code><span data-line="763"></span>, and then returns <span data-line="763"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k - <span class="constant" style="color:purple">1</span></code><span data-line="763"></span>.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="765" data-line-first="766" style="display:block"><code data-line="766"><span style="color:blue">ghost</span> <span style="color:blue">function</span> ReduceK(k: <span style="color:teal">ORDINAL</span>, s: Stream): (k&#39;: <span style="color:teal">ORDINAL</span>)
  <span style="color:purple">requires</span> s != Nil &amp;&amp; IsFinite#[k](s)
  <span style="color:purple">ensures</span> k&#39; &lt; k &amp;&amp; IsFinite#[k&#39;](s.tail)
{
  <span style="color:blue">if</span> k.Offset != <span class="constant" style="color:purple">0</span> <span style="color:blue">then</span>
    k - <span class="constant" style="color:purple">1</span>
  <span style="color:blue">else</span>
    <span style="color:blue">var</span> k&#39; :| k&#39; &lt; k &amp;&amp; IsFinite#[k&#39;](s);
    ReduceK(k&#39;, s)
}</code></pre>
<p class="p noindent para-continued" data-line="778"><span data-line="778"></span>There are several things to observe about this function.
First, since we don<span data-line="779"></span>&#39;<span data-line="779"></span>t intend for the function to present at run time, we declare it as ghost.
</p>
<p class="p indent" data-line="781"><span data-line="781"></span>Since functions in Dafny are transparent<span data-line="781"></span>&#8212;<span data-line="781"></span>meaning, their bodies are available
to callers<span data-line="782"></span>&#8212;<span data-line="782"></span>most functions do not have a declared postcondition. For a recursive
function, like <span data-line="783"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK</code><span data-line="783"></span>, a property about the function<span data-line="783"></span>&#39;<span data-line="783"></span>s result may not be immediately
obvious from the function body. In those cases, a postcondition can be a good idea,
because the proof of the postcondition can then make use of the postcondition of any
recursive call.
</p>
<p class="p indent" data-line="788"><span data-line="788"></span>One way for <span data-line="788"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK</code><span data-line="788"></span> to mention its result in the postcondition is to write
<span data-line="789"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK(k, s)</code><span data-line="789"></span>, that is, the function itself with the given arguments. However,
since our postcondition above needs to mention the result twice, it is more convenient
to give the result value a name. That<span data-line="791"></span>&#39;<span data-line="791"></span>s why we introduced the name <span data-line="791"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="791"></span> in the function
signature. (The identifier <span data-line="792"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="792"></span> can only be used in the postcondition of the function.)
</p>
<p class="p indent" data-line="794"><span data-line="794"></span>Using <span data-line="794"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK</code><span data-line="794"></span>, we can rewrite <span data-line="794"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="794"></span> as a compiled function that uses <span data-line="794"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="794"></span> to
prove termination but does not need <span data-line="795"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="795"></span> at run time:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="797" data-line-first="798" style="display:block"><code data-line="798"><span style="color:blue">function</span> Length&#39;(<span style="color:blue">ghost</span> k: <span style="color:teal">ORDINAL</span>, s: Stream): <span style="color:teal">nat</span>
  <span style="color:purple">requires</span> IsFinite#[k](s)
{
  <span style="color:blue">if</span> s == Nil <span style="color:blue">then</span>
    <span class="constant" style="color:purple">0</span>
  <span style="color:blue">else</span>
    <span class="constant" style="color:purple">1</span> + Length&#39;(ReduceK(k, s), s.tail)
}</code></pre>
<p class="p noindent para-continued" data-line="808"><span data-line="808"></span>And with <span data-line="808"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="808"></span> in place, we define <span data-line="808"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="808"></span>:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="810" data-line-first="811" style="display:block"><code data-line="811"><span style="color:blue">function</span> Length(s: Stream): <span style="color:teal">nat</span>
  <span style="color:purple">requires</span> IsFinite(s)
{
  <span style="color:blue">var</span> k :| IsFinite#[k](s);
  Length&#39;(k, s)
}</code></pre>
<p class="p noindent para-continued" data-line="819"><span data-line="819"></span>Since the prefix predicate <span data-line="819"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite#</code><span data-line="819"></span> is ghost, the variable <span data-line="819"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="819"></span> is automatically
made a ghost. If we wanted to make this more explicit in the program text, we
can write
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="823" data-line-first="824" style="display:block"><code data-line="824">  <span style="color:blue">ghost</span> <span style="color:blue">var</span> k :| IsFinite#[k](s);</code></pre>
<p class="p noindent para-continued" data-line="827"><span data-line="827"></span>However, there is an issue with assign-such-that construct in the function. The
issue won<span data-line="828"></span>&#39;<span data-line="828"></span>t be apparent until we start proving properties about the function,
but since we know it<span data-line="829"></span>&#39;<span data-line="829"></span>s coming, we<span data-line="829"></span>&#39;<span data-line="829"></span>ll address it right away. As used here, the
<span data-line="830"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="830"></span> operator has many possible values it can pick for <span data-line="830"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="830"></span>. Which one you get
it underspecified, but Dafny promises to be consistent about which value it picks.
This is necessary in order for expressions to be deterministic (see
<span data-line="833"></span><span class="citations" style="target-element:bibitem">[<a href="#lpar-20:compiling_hilberts_epsilon_operator" title="K.&#160;Rustan&#160;M. Leino. 
Compiling Hilbert&#39;s epsilon operator." class="bibref localref" style="target-element:bibitem"><span class="cite-number">5</span></a>]</span><span data-line="833"></span> for more information). More
precisely, Dafny promises to be consistent for each textual occurrence of <span data-line="834"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="834"></span>.
This means that if you write this very same <span data-line="835"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="835"></span> construct somewhere else, like
in a proof about <span data-line="836"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="836"></span>, then the other <span data-line="836"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="836"></span> operator may pick a different <span data-line="836"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="836"></span>.
To prevent this, we need to make sure that these use the same textual occurrence
of <span data-line="838"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="838"></span>, so we put it in a function:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="840" data-line-first="841" style="display:block"><code data-line="841"><span style="color:blue">function</span> Length(s: Stream): <span style="color:teal">nat</span>
  <span style="color:purple">requires</span> IsFinite(s)
{
  <span style="color:blue">ghost</span> <span style="color:blue">var</span> k := PickK(s);
  Length&#39;(k, s)
}

<span style="color:blue">ghost</span> <span style="color:blue">function</span> PickK(s: Stream): <span style="color:teal">ORDINAL</span>
  <span style="color:purple">requires</span> IsFinite(s)
{
  <span style="color:blue">var</span> k :| IsFinite#[k](s); k
}</code></pre><h4 id="sec-proving-the-lemma-about-length" class="h3" data-line="855" data-heading-depth="3" style="display:block"><span data-line="855"></span><span class="heading-before"><span class="heading-label">2.1.2</span>.&#8194;</span><span data-line="855"></span>Proving the lemma about <span data-line="855"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code></h4>
<p class="p noindent" data-line="857"><span data-line="857"></span>Finally, we can prove the lemma about <span data-line="857"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="857"></span>:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="859" data-line-first="860" style="display:block"><code data-line="860"><span style="color:blue">lemma</span> AboutLength(s: Stream)
  <span style="color:purple">requires</span> s != Nil &amp;&amp; IsFinite(s)
  <span style="color:purple">ensures</span> Length(s) == <span class="constant" style="color:purple">1</span> + Length(s.tail)</code></pre>
<p class="p noindent para-continued" data-line="865"><span data-line="865"></span>In the previous section, we addressed the termination of <span data-line="865"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="865"></span> by explicitly
keeping track of the prefix-predicate index <span data-line="866"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="866"></span>. We added an auxiliary function,
<span data-line="867"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;</code><span data-line="867"></span>, and let that function take <span data-line="867"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="867"></span> as a parameter. Let<span data-line="867"></span>&#39;<span data-line="867"></span>s consider what
happens when <span data-line="868"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="868"></span> is called for a non-<span data-line="868"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Nil</code><span data-line="868"></span> stream. The call <span data-line="868"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(s)</code><span data-line="868"></span>
will call <span data-line="869"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;(PickK(s), s)</code><span data-line="869"></span>, which in turn will call
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="871" data-line-first="872" style="display:block"><code data-line="872">Length&#39;(ReduceK(PickK(s), s), s.tail)</code></pre>
<p class="p noindent para-continued" data-line="875"><span data-line="875"></span>In the postcondition of the lemma, we also have to reason about <span data-line="875"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(s.tail)</code><span data-line="875"></span>.
When it gets called, it will end up calling
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="878" data-line-first="879" style="display:block"><code data-line="879">Length&#39;(PickK(s.tail), s.tail)</code></pre>
<p class="p noindent para-continued" data-line="882"><span data-line="882"></span>If we<span data-line="882"></span>&#39;<span data-line="882"></span>re going to show a connection between <span data-line="882"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(s)</code><span data-line="882"></span> and <span data-line="882"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(s.tail)</code><span data-line="882"></span>,
we would wish that the first parameter to the two <span data-line="883"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;(..., s.tail)</code><span data-line="883"></span>
calls above are the same. Unfortunately, we have no such guarantee.
Fortunately, we can prove a lemma that says the value of the first parameter
does not matter<span data-line="886"></span>&#8212;<span data-line="886"></span>provided the value is one that is allowed by the precondition:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="888" data-line-first="889" style="display:block"><code data-line="889"><span style="color:blue">lemma</span> Length&#39;AnyK(k0: <span style="color:teal">ORDINAL</span>, k1: <span style="color:teal">ORDINAL</span>, s: Stream)
  <span style="color:purple">requires</span> IsFinite#[k0](s) &amp;&amp; IsFinite#[k1](s)
  <span style="color:purple">ensures</span> Length&#39;(k0, s) == Length&#39;(k1, s)
{
}</code></pre>
<p class="p noindent para-continued" data-line="896"><span data-line="896"></span>This lemma is proved automatically (using Dafny<span data-line="896"></span>&#39;<span data-line="896"></span>s automatic induction),
so there is nothing we need to write between the curly braces of the body
of this lemma.
</p>
<p class="p indent" data-line="900"><span data-line="900"></span>Using the <span data-line="900"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;AnyK</code><span data-line="900"></span> lemma, the proof of <span data-line="900"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AboutLength</code><span data-line="900"></span> is straightforward:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="902" data-line-first="903" style="display:block"><code data-line="903"><span style="color:blue">lemma</span> AboutLength(s: Stream)
  <span style="color:purple">requires</span> s != Nil &amp;&amp; IsFinite(s)
  <span style="color:purple">ensures</span> Length(s) == <span class="constant" style="color:purple">1</span> + Length(s.tail)
{
  <span style="color:blue">calc</span> {
    Length(s);
  ==  <span style="color:darkgreen">// def. Length</span>
    Length&#39;(PickK(s), s);
  ==  <span style="color:darkgreen">// def. Length&#39;</span>
    <span class="constant" style="color:purple">1</span> + Length&#39;(ReduceK(PickK(s), s), s.tail);
  ==  { Length&#39;AnyK(ReduceK(PickK(s), s), PickK(s.tail), s.tail); }
    <span class="constant" style="color:purple">1</span> + Length&#39;(PickK(s.tail), s.tail);
  ==  <span style="color:darkgreen">// def. Length</span>
    <span class="constant" style="color:purple">1</span> + Length(s.tail);
  }
}</code></pre>
<p class="p noindent para-continued" data-line="921"><span data-line="921"></span>This proof uses a proof calculation (<span data-line="921"></span>&quot;<span data-line="921"></span>the <span data-line="921"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">calc</span></code><span data-line="921"></span> statement<span data-line="921"></span>&quot;<span data-line="921"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#leinopolikarpova:calc" title="K.&#160;Rustan&#160;M. Leino and Nadia Polikarpova. 
Verified calculations." class="bibref localref" style="target-element:bibitem"><span class="cite-number">7</span></a>]</span><span data-line="921"></span>).
The steps of the proof calculation are proved automatically, except the
step where we need to call the <span data-line="923"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length&#39;AnyK</code><span data-line="923"></span> lemma.
</p>
<p class="p indent" data-line="925"><span data-line="925"></span>A shorter way to write the proof of <span data-line="925"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AboutLength</code><span data-line="925"></span> is to include just the
call to the salient lemma:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="928" data-line-first="929" style="display:block"><code data-line="929"><span style="color:blue">lemma</span> AboutLength(s: Stream)
  <span style="color:purple">requires</span> s != Nil &amp;&amp; IsFinite(s)
  <span style="color:purple">ensures</span> Length(s) == <span class="constant" style="color:purple">1</span> + Length(s.tail)
{
  Length&#39;AnyK(ReduceK(PickK(s), s), PickK(s.tail), s.tail);
}</code></pre>
<p class="p noindent para-continued" data-line="937"><span data-line="937"></span>This proof is shorter, but perhaps less illuminating to a human reader.
Dafny is happy with either, so take your pick.
</p><h3 id="sec-returning-the-last-value-of-a-finite-stream" class="h2" data-line="940" data-heading-depth="2" style="display:block"><span data-line="940"></span><span class="heading-before"><span class="heading-label">2.2</span>.&#8194;</span><span data-line="940"></span>Returning the Last Value of a Finite Stream</h3>
<p class="p noindent" data-line="942"><span data-line="942"></span>Lastly, we define a function that returns the last element of a nonempty,
finite stream:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="945" data-line-first="946" style="display:block"><code data-line="946"><span style="color:blue">function</span> Last&lt;X&gt;(s: Stream&lt;X&gt;): X
  <span style="color:purple">requires</span> s != Nil &amp;&amp; IsFinite(s)
  <span style="color:purple">decreases</span> Length(s)
{
  <span style="color:blue">match</span> s
  <span style="color:blue">case</span> Cons(x, Nil) =&gt;
    x
  <span style="color:blue">case</span> _ =&gt;
    AboutLength(s);
    Last(s.tail)
}</code></pre><h2 id="sec-application-to-simple-abstract-interpretation" class="h1" data-line="959" data-heading-depth="1" style="display:block"><span data-line="959"></span><span class="heading-before"><span class="heading-label">3</span>.&#8194;</span><span data-line="959"></span>Application to Simple Abstract Interpretation</h2><h3 id="sec-problem-statement" class="h2" data-line="961" data-heading-depth="2" style="display:block"><span data-line="961"></span><span class="heading-before"><span class="heading-label">3.0</span>.&#8194;</span><span data-line="961"></span>Problem Statement</h3>
<p class="p noindent" data-line="963"><span data-line="963"></span>We assume an opaque type <span data-line="963"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="963"></span> to stand for the elements of our abstract domain.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="965" data-line-first="966" style="display:block"><code data-line="966"><span style="color:blue">type</span> A(==,<span class="constant" style="color:purple">0</span>,!<span style="color:blue">new</span>)</code></pre>
<p class="p noindent para-continued" data-line="969"><span data-line="969"></span>Recall that a type declaration can be equipped with <span data-line="969"></span><em class="em-low1">type characteristics</em><span data-line="969"></span>, and in this case, we
require type <span data-line="970"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="970"></span> to support equality comparison <span data-line="970"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">(==)</code><span data-line="970"></span>, to be nonempty <span data-line="970"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">(<span class="constant" style="color:purple">0</span>)</code><span data-line="970"></span>, and to be in the purely
functional fragment of Dafny, without references <span data-line="971"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">(!<span style="color:blue">new</span>)</code><span data-line="971"></span>.
</p>
<p class="p indent" data-line="973"><span data-line="973"></span>Type <span data-line="973"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="973"></span> is equipped with a predicate <span data-line="973"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le</code><span data-line="973"></span>. For now, we do not make any assumptions about this predicate,
but intuitively, it will induce some ordering on <span data-line="974"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="974"></span> and can be read as <span data-line="974"></span><em class="em-low1">less or equal</em><span data-line="974"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="976" data-line-first="977" style="display:block"><code data-line="977"><span style="color:blue">predicate</span> le(x: A, y: A)</code></pre>
<p class="p noindent para-continued" data-line="980"><span data-line="980"></span>We can define its counterpart, <span data-line="980"></span><em class="em-low1">less than</em><span data-line="980"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="982" data-line-first="983" style="display:block"><code data-line="983"><span style="color:blue">predicate</span> lt(x: A, y: A) {
  le(x, y) &amp;&amp; x != y
}</code></pre>
<p class="p noindent para-continued" data-line="988"><span data-line="988"></span>We need <span data-line="988"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="988"></span> to have a bottom element that is smaller than any other element.
To that avail, we declare a constant <span data-line="989"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="989"></span> and state the property of <span data-line="989"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="989"></span>
as a lemma:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="992" data-line-first="993" style="display:block"><code data-line="993"><span style="color:blue">const</span> bot: A

<span style="color:blue">lemma</span> BotSmallest(x: A)
  <span style="color:purple">ensures</span> le(bot, x)</code></pre>
<p class="p noindent para-continued" data-line="999"><span data-line="999"></span>We omit the body of this lemma, since we don<span data-line="999"></span>&#39;<span data-line="999"></span>t intend to prove it. In effect,
this makes the lemma an axiom. 
</p>
<div class="remark para-end note" data-line="1002" style="display:block;margin:1ex 0pt;padding-left:1em;border-left:0.25em teal solid;breakable:true">
<p class="p noindent" data-line="1003"><span data-line="1003"></span><span class="remark-before"><strong class="strong-star2">Remark&#160;<span class="remark-label">1</span>.</strong></span><span data-line="1003"></span><br>
<span data-line="1004"></span>To use this abstract library and write code that compiles and runs, you will have
to refine <span data-line="1005"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="1005"></span> into a concrete type, define <span data-line="1005"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="1005"></span>, and prove <span data-line="1005"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">BotSmallest</code><span data-line="1005"></span>. </p></div>
<p class="p indent" data-line="1007"><span data-line="1007"></span>Finally, we assume the existence of a monotonic function on <span data-line="1007"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="1007"></span>. Let<span data-line="1007"></span>&#39;<span data-line="1007"></span>s call it <span data-line="1007"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1007"></span>
and declare it here:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1010" data-line-first="1011" style="display:block"><code data-line="1011"><span style="color:blue">function</span> F(x: A): A</code></pre>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1014" data-line-first="1015" style="display:block"><code data-line="1015"><span style="color:blue">lemma</span> FMonotonic(x: A, y: A)
 <span style="color:purple">requires</span> le(x, y)
    <span style="color:purple">ensures</span> le(F(x), F(y))</code></pre>
<p class="p noindent para-continued" data-line="1020"><span data-line="1020"></span>Our goal is to define a function <span data-line="1020"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">iterates</code><span data-line="1020"></span> that will effectively compute the least fixpoint
of <span data-line="1021"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1021"></span>, starting from <span data-line="1021"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="1021"></span>, where the fixpoint is formally defined as
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1023" data-line-first="1024" style="display:block"><code data-line="1024"><span style="color:blue">predicate</span> IsFixpoint(x: A) {
  x == F(x)
}</code></pre><h3 id="sec-ascending-chain-condition" class="h2" data-line="1029" data-heading-depth="2" style="display:block"><span data-line="1029"></span><span class="heading-before"><span class="heading-label">3.1</span>.&#8194;</span><span data-line="1029"></span>Ascending Chain Condition</h3>
<p class="p noindent" data-line="1031"><span data-line="1031"></span>We do need to make some assumptions about <span data-line="1031"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le</code><span data-line="1031"></span> to guarantee the existence of a fixpoint.
In general, <span data-line="1032"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le</code><span data-line="1032"></span> is expected to be a partial order, but in this simple example, all we
need about <span data-line="1033"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">(A, le)</code><span data-line="1033"></span> is that it has no infinite ascending
sequences. We define what it means for all ascending sequences starting at an
element <span data-line="1035"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1035"></span> to be finite. This is elegantly stated using a least predicate:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1037" data-line-first="1038" style="display:block"><code data-line="1038"><span style="color:blue">least</span> <span style="color:blue">predicate</span> Acc(x: A) {
  <span style="color:blue">forall</span> y :: lt(x, y) ==&gt; Acc(y)
}</code></pre>
<p class="p noindent para-continued" data-line="1043"><span data-line="1043"></span>Here<span data-line="1043"></span>&#39;<span data-line="1043"></span>s a way to think about this predicate. For any maximal element <span data-line="1043"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1043"></span>, the
quantifier is trivially <span data-line="1044"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">true</span></code><span data-line="1044"></span>. Thus, <span data-line="1044"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc(x)</code><span data-line="1044"></span> holds for any such <span data-line="1044"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1044"></span>. Also,
for any element <span data-line="1045"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1045"></span> whose only larger elements are maximal elements, <span data-line="1045"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc(x)</code><span data-line="1045"></span>
holds. More generally, the definition says that <span data-line="1046"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc(x)</code><span data-line="1046"></span> holds for any element
<span data-line="1047"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1047"></span> whose only larger elements are ones that we have already determined to
satisfy <span data-line="1048"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc</code><span data-line="1048"></span>. But since we declared <span data-line="1048"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc</code><span data-line="1048"></span> to be a <span data-line="1048"></span><em class="em-low1">least</em><span data-line="1048"></span> predicate, the
<span data-line="1049"></span>&#8220;already determined&#8221;<span data-line="1049"></span> means <span data-line="1049"></span>&#8220;determined in a finite number of steps&#8221;<span data-line="1049"></span>. For all
other elements <span data-line="1050"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1050"></span>, <span data-line="1050"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc(x)</code><span data-line="1050"></span> is <span data-line="1050"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">false</span></code><span data-line="1050"></span>.
</p>
<p class="p indent" data-line="1052"><span data-line="1052"></span>We state as an axiom that all ascending sequences from <span data-line="1052"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="1052"></span> are finite:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1054" data-line-first="1055" style="display:block"><code data-line="1055"><span style="color:blue">lemma</span> BotAcc()
  <span style="color:purple">ensures</span> Acc(bot)</code></pre>
<div class="remark para-end note" data-line="1059" style="display:block;margin:1ex 0pt;padding-left:1em;border-left:0.25em teal solid;breakable:true">
<p class="p noindent" data-line="1060"><span data-line="1060"></span><span class="remark-before"><strong class="strong-star2">Remark&#160;<span class="remark-label">2</span>.</strong></span><span data-line="1060"></span><br>
<span data-line="1061"></span>From <span data-line="1061"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc(bot)</code><span data-line="1061"></span>, it follows that every ascending sequence in <span data-line="1061"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="1061"></span> is finite.
Here<span data-line="1062"></span>&#39;<span data-line="1062"></span>s a proof thereof:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1064" data-line-first="1065" style="display:block"><code data-line="1065"><span style="color:blue">lemma</span> WellFounded(x: A)
  <span style="color:purple">ensures</span> Acc(x)
{
  <span style="color:blue">calc</span> {
    <span style="color:blue">true</span>;
  ==&gt; { BotSmallest(x); }
    le(bot, x);
  ==&gt; <span style="color:darkgreen">// def. lt</span>
    bot == x || lt(bot, x);
  ==&gt; { BotAcc(); }
    Acc(x);
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1080"><span data-line="1080"></span>The last step of this proof calculation also uses the definition of <span data-line="1080"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc</code><span data-line="1080"></span>.
Since Dafny automatically unfolds functions and predicates once, we don<span data-line="1081"></span>&#39;<span data-line="1081"></span>t need
to mention that fact.
</p>
<p class="p indent" data-line="1084"><span data-line="1084"></span>The proof calculation is quite readable, but with less pomp and circumstance,
it also possible to prove the lemma by just calling other other two lemmas:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1087" data-line-first="1088" style="display:block"><code data-line="1088">  BotSmallest(x);
  BotAcc();</code></pre></div><h3 id="sec-ascending-streams" class="h2" data-line="1092" data-heading-depth="2" style="display:block"><span data-line="1092"></span><span class="heading-before"><span class="heading-label">3.2</span>.&#8194;</span><span data-line="1092"></span>Ascending Streams</h3>
<p class="p noindent" data-line="1094"><span data-line="1094"></span>With the ordering on <span data-line="1094"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">A</code><span data-line="1094"></span>, we can define what it means for a stream to be
ascending. We<span data-line="1095"></span>&#39;<span data-line="1095"></span>ll use a greatest predicate for that:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1097" data-line-first="1098" style="display:block"><code data-line="1098"><span style="color:blue">greatest</span> <span style="color:blue">predicate</span> Ascending(s: Stream&lt;A&gt;) {
  <span style="color:blue">match</span> s
  <span style="color:blue">case</span> Nil =&gt; <span style="color:blue">true</span>
  <span style="color:blue">case</span> Cons(x, Nil) =&gt; <span style="color:blue">true</span>
  <span style="color:blue">case</span> Cons(x, Cons(y, _)) =&gt; lt(x, y) &amp;&amp; Ascending(s.tail)
}</code></pre>
<p class="p noindent para-continued" data-line="1106"><span data-line="1106"></span>Since we chose a greatest predicate, this definition considers both finite
and infinite streams to be ascending, provided any adjacent elements <span data-line="1107"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1107"></span> and
<span data-line="1108"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">y</code><span data-line="1108"></span> satisfy <span data-line="1108"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">lt(x, y)</code><span data-line="1108"></span>.
</p>
<div id="ex-finiteandascending" class="exercise para-end" data-line="1110" style="display:block;margin:1ex 0pt;padding-left:1em;border-left:0.25em blue solid;breakable:true">
<p class="p noindent" data-line="1111"><span data-line="1111"></span><span class="exercise-before"><strong class="strong-star2">Exercise&#160;<span class="exercise-label">1</span>.</strong> <span class="theorem-caption"></span><br>
</span><span data-line="1111"></span>Declare a predicate <span data-line="1111"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FiniteAndAscending(s: Stream&lt;A&gt;)</code></p></div>
<p class="p indent" data-line="1114"><span data-line="1114"></span>In a lattice that satisfies the ascending chain condition, there are no
infinite ascending streams. If we want to prove a lemma whose antecedent
contains a least predicate, then we can use a <span data-line="1116"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span> <span style="color:blue">lemma</span></code><span data-line="1116"></span>. That provides
some scaffolding that lets us focus on the main ingredients of the proof.
Dually, if we want to prove a lemma whose conclusion contains a greatest
predicate, then we can use a <span data-line="1119"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span></code><span data-line="1119"></span> (that<span data-line="1119"></span>&#39;<span data-line="1119"></span>s a hint for doing
Exercise<span data-line="1120"></span>&nbsp;<a href="#ex-isfinite-prime" class="localref" style="target-element:exercise"><span class="exercise-label">0</span></a><span data-line="1120"></span>).
</p>
<p class="p indent" data-line="1122"><span data-line="1122"></span>Here we go:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1124" data-line-first="1125" style="display:block"><code data-line="1125"><span style="color:blue">least</span> <span style="color:blue">lemma</span> AscendingIsFinite(s: Stream&lt;A&gt;)
  <span style="color:purple">requires</span> (s == Nil || Acc(s.head)) &amp;&amp; Ascending(s)
  <span style="color:purple">ensures</span> IsFinite(s)
{
}</code></pre>
<p class="p noindent para-continued" data-line="1132"><span data-line="1132"></span>Dafny completes this proof automatically!
</p>
<p class="p indent" data-line="1134"><span data-line="1134"></span>That was too easy. Let<span data-line="1134"></span>&#39;<span data-line="1134"></span>s manually introduce more and more detail into this
proof to see what Dafny does under the hood. To start with, let<span data-line="1135"></span>&#39;<span data-line="1135"></span>s turn
off Dafny<span data-line="1136"></span>&#39;<span data-line="1136"></span>s automatic induction, which we do by marking the lemma with
the attribute <span data-line="1137"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">{<span style="color:purple">:induction</span> <span style="color:blue">false</span>}</code><span data-line="1137"></span>. We can then write the proof as follows:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1139" data-line-first="1140" style="display:block"><code data-line="1140"><span style="color:blue">least</span> <span style="color:blue">lemma</span> {<span style="color:purple">:induction</span> <span style="color:blue">false</span>} AscendingIsFinite(s: Stream&lt;A&gt;)
  <span style="color:purple">requires</span> (s == Nil || Acc(s.head)) &amp;&amp; Ascending(s)
  <span style="color:purple">ensures</span> IsFinite(s)
{
  <span style="color:blue">if</span> s == Nil {
  } <span style="color:blue">else</span> {
    AscendingIsFinite(s.tail);
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1151"><span data-line="1151"></span>This proof straightforwardly introduces two cases: either <span data-line="1151"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s == Nil</code><span data-line="1151"></span>
or <span data-line="1152"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s != Nil</code><span data-line="1152"></span>. In the first case, <span data-line="1152"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite(s)</code><span data-line="1152"></span> follows directly.
In the second case, we call the lemma recursively to obtain <span data-line="1153"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite(s.tail)</code><span data-line="1153"></span>,
from which <span data-line="1154"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite(s)</code><span data-line="1154"></span> follows. Calling a lemma recursively is
what in mathematics we usually refer to as <span data-line="1155"></span>&#8220;invoking the induction
hypothesis&#8221;<span data-line="1156"></span>.
</p>
<p class="p indent" data-line="1158"><span data-line="1158"></span>We can add more details to this proof by considering whether or not
<span data-line="1159"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s.tail == Nil</code><span data-line="1159"></span>. If it is, we can easily justify calling the induction
hypothesis. If it is not, we unfold the definitions of <span data-line="1160"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Ascending</code><span data-line="1160"></span>
and <span data-line="1161"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc</code><span data-line="1161"></span> before we call the induction hypothesis. We then have:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1163" data-line-first="1164" style="display:block"><code data-line="1164"><span style="color:blue">least</span> <span style="color:blue">lemma</span> {<span style="color:purple">:induction</span> <span style="color:blue">false</span>} AscendingIsFinite(s: Stream&lt;A&gt;)
  <span style="color:purple">requires</span> (s == Nil || Acc(s.head)) &amp;&amp; Ascending(s)
  <span style="color:purple">ensures</span> IsFinite(s)
{
  <span style="color:blue">if</span> s == Nil {
  } <span style="color:blue">else</span> <span style="color:blue">if</span> s.tail == Nil {
    AscendingIsFinite(s.tail);
  } <span style="color:blue">else</span> {
    <span style="color:blue">assert</span> lt(s.head, s.tail.head) &amp;&amp; Ascending(s.tail); <span style="color:darkgreen">// by Ascending(s)</span>
    <span style="color:blue">assert</span> <span style="color:blue">forall</span> y :: lt(s.head, y) ==&gt; Acc(y); <span style="color:darkgreen">// by Acc(s.head)</span>
    <span style="color:blue">assert</span> Acc(s.tail.head); <span style="color:darkgreen">// by the previous two lines</span>
    AscendingIsFinite(s.tail);
  }</code></pre>
<p class="p noindent para-continued" data-line="1179"><span data-line="1179"></span>This manual proof is rather carefree. For example, what makes sure the
recursive calls terminate? If we want to find the answer to that, we<span data-line="1180"></span>&#39;<span data-line="1180"></span>ll
need to understand what makes a lemma a <span data-line="1181"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span></code><span data-line="1181"></span> lemma. Dafny turns such
an extreme lemma into a <span data-line="1182"></span><em class="em-low1">prefix lemma</em><span data-line="1182"></span>, similar to how an extreme
predicate is turned into a prefix predicate. The prefix lemma gives
some scaffolding into which it places a rewritten version of the body
we wrote for the extreme lemma. The following gives you an idea of what
that looks like:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1188" data-line-first="1189" style="display:block"><code data-line="1189"><span style="color:blue">lemma</span> {<span style="color:purple">:induction</span> <span style="color:blue">false</span>} AscendingIsFinite#[_k: <span style="color:teal">ORDINAL</span>](s: Stream&lt;A&gt;)
  <span style="color:purple">requires</span> (s == Nil || Acc#[_k](s.head)) &amp;&amp; Ascending(s)
  <span style="color:purple">ensures</span> IsFinite(s)
{
  <span style="color:blue">if</span> _k.Offset != <span class="constant" style="color:purple">0</span> {
    <span style="color:blue">if</span> s == Nil {
    } <span style="color:blue">else</span> <span style="color:blue">if</span> s.tail == Nil {
      AscendingIsFinite#[_k - <span class="constant" style="color:purple">1</span>](s.tail);
    } <span style="color:blue">else</span> {
      <span style="color:blue">assert</span> lt(s.head, s.tail.head) &amp;&amp; Ascending(s.tail); <span style="color:darkgreen">// by Ascending(s)</span>
      <span style="color:blue">assert</span> <span style="color:blue">forall</span> y :: lt(s.head, y) ==&gt; Acc#[_k - <span class="constant" style="color:purple">1</span>](y); <span style="color:darkgreen">// by Acc(s.head)</span>
      <span style="color:blue">assert</span> Acc#[_k - <span class="constant" style="color:purple">1</span>](s.tail.head); <span style="color:darkgreen">// by the previous two lines</span>
      AscendingIsFinite#[_k - <span class="constant" style="color:purple">1</span>](s.tail);
    }
  } <span style="color:blue">else</span> {
    <span style="color:blue">forall</span> k&#39; | k&#39; &lt; _k &amp;&amp; (s == Nil || Acc#[k&#39;](s.head)) &amp;&amp; Ascending(s) {
      AscendingIsFinite#[k&#39;](s);
    }
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1211"><span data-line="1211"></span>Note that, like prefix predicates, the prefix lemma places the implicit
<span data-line="1212"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1212"></span> parameter in square brackets.
The <span data-line="1213"></span>&#8220;then&#8221;<span data-line="1213"></span> branch of the lemma<span data-line="1213"></span>&#39;<span data-line="1213"></span>s body applies when
<span data-line="1214"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1214"></span> is a successor ordinal and the <span data-line="1214"></span>&#8220;else&#8221;<span data-line="1214"></span> branch applies when <span data-line="1214"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1214"></span> is a
limit ordinal. The <span data-line="1215"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1215"></span> statement in the <span data-line="1215"></span>&#8220;else&#8221;<span data-line="1215"></span> branch has the effect
of calling <span data-line="1216"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AscendingIsFinite#[k&#39;](s)</code><span data-line="1216"></span> on every <span data-line="1216"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k&#39;</code><span data-line="1216"></span> that is both smaller
than <span data-line="1217"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1217"></span> and satisfies the precondition (this is what Dafny<span data-line="1217"></span>&#39;<span data-line="1217"></span>s automatic
induction does<span data-line="1218"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#leino:induction" title="K.&#160;Rustan&#160;M. Leino. 
Automating induction with an SMT solver." class="bibref localref" style="target-element:bibitem"><span class="cite-number">3</span></a>]</span><span data-line="1218"></span>). Finally, note that all occurrences
of <span data-line="1219"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc</code><span data-line="1219"></span> and <span data-line="1219"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AscendingIsFinite</code><span data-line="1219"></span> in the body of the original <span data-line="1219"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span> <span style="color:blue">lemma</span></code><span data-line="1219"></span>
have been automatically rewritten into <span data-line="1220"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc#[_k - <span class="constant" style="color:purple">1</span>]</code><span data-line="1220"></span> and
<span data-line="1221"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AscendingIsFinite#[_k - <span class="constant" style="color:purple">1</span>]</code><span data-line="1221"></span>, respectively, and occurrences of <span data-line="1221"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc</code><span data-line="1221"></span> in
the precondition have been rewritten into <span data-line="1222"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Acc#[_k]</code><span data-line="1222"></span>.
</p>
<p class="p indent" data-line="1224"><span data-line="1224"></span>Dafny<span data-line="1224"></span>&#39;<span data-line="1224"></span>s syntax does not allow you to declare a lemma with square brackets
like we showed up. But if we change the name of the lemma to, say,
<span data-line="1226"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AscendingIsFinite&#39;</code><span data-line="1226"></span>, rename <span data-line="1226"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1226"></span> to <span data-line="1226"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="1226"></span>, and declare <span data-line="1226"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">k</code><span data-line="1226"></span> as an ordinary
parameter, then we get a lemma that is syntactically valid:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1229" data-line-first="1230" style="display:block"><code data-line="1230"><span style="color:blue">lemma</span> {<span style="color:purple">:induction</span> <span style="color:blue">false</span>} AscendingIsFinite&#39;(k: <span style="color:teal">ORDINAL</span>, s: Stream&lt;A&gt;)
  <span style="color:purple">requires</span> (s == Nil || Acc#[k](s.head)) &amp;&amp; Ascending(s)
  <span style="color:purple">ensures</span> IsFinite(s)
{
  <span style="color:blue">if</span> k.Offset != <span class="constant" style="color:purple">0</span> {
    <span style="color:blue">if</span> s == Nil {
    } <span style="color:blue">else</span> <span style="color:blue">if</span> s.tail == Nil {
      AscendingIsFinite&#39;(k - <span class="constant" style="color:purple">1</span>, s.tail);
    } <span style="color:blue">else</span> {
      <span style="color:blue">assert</span> lt(s.head, s.tail.head) &amp;&amp; Ascending(s.tail); <span style="color:darkgreen">// by Ascending(s)</span>
      <span style="color:blue">assert</span> <span style="color:blue">forall</span> y :: lt(s.head, y) ==&gt; Acc#[k - <span class="constant" style="color:purple">1</span>](y); <span style="color:darkgreen">// by Acc(s.head)</span>
      <span style="color:blue">assert</span> Acc#[k - <span class="constant" style="color:purple">1</span>](s.tail.head); <span style="color:darkgreen">// by the previous two lines</span>
      AscendingIsFinite&#39;(k - <span class="constant" style="color:purple">1</span>, s.tail);
    }
  } <span style="color:blue">else</span> {
    <span style="color:blue">forall</span> k&#39; | k&#39; &lt; k &amp;&amp; (s == Nil || Acc#[k&#39;](s.head)) &amp;&amp; Ascending(s) {
      AscendingIsFinite&#39;(k&#39;, s);
    }
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1252"><span data-line="1252"></span>This lemma verifies as well.
</p><h3 id="sec-iterates-of-f" class="h2" data-line="1256" data-heading-depth="2" style="display:block"><span data-line="1256"></span><span class="heading-before"><span class="heading-label">3.3</span>.&#8194;</span><span data-line="1256"></span>Iterates of <span data-line="1256"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code></h3>
<p class="p noindent" data-line="1258"><span data-line="1258"></span>The <span data-line="1258"></span><em class="em-low1">iterates</em><span data-line="1258"></span> of a function from an initial element <span data-line="1258"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1258"></span> is a stream
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1260" data-line-first="1261" style="display:block"><code data-line="1261">x, F(x), F(F(x)), F<span class="code-escaped"><sup>3</sup></span>(x), F<span class="code-escaped"><sup>4</sup></span>(x), ...</code></pre>
<p class="p noindent para-continued" data-line="1264"><span data-line="1264"></span>The stream ends if the next element would be a repeat of the previous.
That is, the stream is finite if and only if the last element is a fixpoint
of the function.
Here is a function for generating iterates:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1269" data-line-first="1270" style="display:block"><code data-line="1270"><span style="color:blue">function</span> Iterates(x: A): Stream&lt;A&gt; {
  <span style="color:blue">if</span> x == F(x) <span style="color:blue">then</span>
    Cons(x, Nil)
  <span style="color:blue">else</span>
    Cons(x, Iterates(F(x)))
}</code></pre>
<p class="p noindent para-continued" data-line="1278"><span data-line="1278"></span>Dafny accepts this function without any complaints about termination.
Indeed, the function results in an infinite stream if the iterates never
reach a fixpoint. The reason is that the self-call is placed immediately
inside the constructor of a codatatype. In this case, the self-call can
be referred to as a <span data-line="1282"></span><em class="em-low1">corecursive call</em><span data-line="1282"></span> and Dafny deems it to be
<span data-line="1283"></span><em class="em-low1">productive</em><span data-line="1283"></span>. Productivity ensures that the function definition is
mathematically consistent, so Dafny is satisfied with the function definition
even if the self-call never terminates.
</p>
<p class="p indent" data-line="1287"><span data-line="1287"></span>In Dafny, the definition of a function can include both recursive and
corecursive calls. (For example, see the <span data-line="1288"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Filter</code><span data-line="1288"></span> function in<span data-line="1288"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#leino:itp2013" title="K.&#160;Rustan&#160;M. Leino. 
Automating theorem proving with SMT." class="bibref localref" style="target-element:bibitem"><span class="cite-number">4</span></a>]</span><span data-line="1288"></span>.)
So, technically, being <span data-line="1289"></span>&#8220;corecursive&#8221;<span data-line="1289"></span> is a property of a call, not of a function.
</p>
<p class="p indent" data-line="1291"><span data-line="1291"></span>At run time, a corecursive call is evaluated lazily, like functions in
Haskell.
</p>
<p class="p indent" data-line="1294"><span data-line="1294"></span>Let<span data-line="1294"></span>&#39;<span data-line="1294"></span>s prove our claim that the last element of a finite stream of iterates
is a fixpoint. Because the antecedent of this lemma is a least predicate, we
write the proof using a <span data-line="1296"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span> <span style="color:blue">lemma</span></code><span data-line="1296"></span>:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1298" data-line-first="1299" style="display:block"><code data-line="1299"><span style="color:blue">least</span> <span style="color:blue">lemma</span> LastIterateIsFixpoint(x: A)
  <span style="color:purple">requires</span> IsFinite(Iterates(x))
  <span style="color:purple">ensures</span> IsFixpoint(Last(Iterates(x)))
{
  <span style="color:blue">if</span> Iterates(x).tail != Nil {
    LastIterateIsFixpoint(F(x));
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1309"><span data-line="1309"></span>If <span data-line="1309"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates(x)</code><span data-line="1309"></span> is a singleton stream, then the postcondition
follows directly. Otherwise, the least lemma is called again with <span data-line="1310"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F(x)</code><span data-line="1310"></span>
as the initial element of the iterates.
</p>
<p class="p indent" data-line="1313"><span data-line="1313"></span>An easy mistake is to conclude from the monotonicity of <span data-line="1313"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1313"></span>
that the iterates of <span data-line="1314"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1314"></span> are ascending. This may not be true, but it is true
if the first two elements of the iterates are ascending. Let<span data-line="1315"></span>&#39;<span data-line="1315"></span>s state and
prove this property. Since the conclusion contains a greatest predicate
(<span data-line="1317"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Ascending</code><span data-line="1317"></span>), we<span data-line="1317"></span>&#39;<span data-line="1317"></span>ll be helped by using a <span data-line="1317"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span></code><span data-line="1317"></span>:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1319" data-line-first="1320" style="display:block"><code data-line="1320"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span> IteratesAreAscending(x: A)
  <span style="color:purple">requires</span> le(x, F(x))
  <span style="color:purple">ensures</span> Ascending(Iterates(x))
{
  <span style="color:blue">if</span> x != F(x) {
    FMonotonic(x, F(x));
    IteratesAreAscending(F(x));
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1331"><span data-line="1331"></span>Note how the automatic adaption of this lemma into the prefix lemma gives
us the illusion of writing a proof without concern about termination.
Yet, it will be instructive to write out this particular proof in more detail,
because it will show a subtlety of the encoding of greatest lemmas. Here is the same
lemma, but with more detail:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1337" data-line-first="1338" style="display:block"><code data-line="1338"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span> IteratesAreAscending(x: A)
  <span style="color:purple">requires</span> le(x, F(x))
  <span style="color:purple">ensures</span> Ascending(Iterates(x))
{
  <span style="color:blue">if</span> x != F(x) {
    <span style="color:blue">calc</span> {
      le(x, F(x));
    ==&gt; { FMonotonic(x, F(x)); }
      le(x, F(x)) &amp;&amp; le(F(x), F(F(x)));
    ==&gt; { IteratesAreAscending(F(x)); }
      le(x, F(x)) &amp;&amp; Ascending(Iterates(F(x)));
    ==&gt; <span style="color:darkgreen">// def. Ascending</span>
      Ascending#[_k](Iterates(x));
    }
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1356"><span data-line="1356"></span>In the last line of this proof, we had to explicitly give the index to <span data-line="1356"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Ascending#</code><span data-line="1356"></span>.
The reason is that Dafny rewrites every occurrence of <span data-line="1357"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Ascending</code><span data-line="1357"></span> in the body
of given <span data-line="1358"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span></code><span data-line="1358"></span> into <span data-line="1358"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Ascending#[_k - <span class="constant" style="color:purple">1</span>]</code><span data-line="1358"></span>. But in order for the
last line to follow from the prior line, the index needs to be <span data-line="1359"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1359"></span> (since the
prior line is the last line unfolded once). Moreover, when the postcondition is
adapted for the prefix lemma, it is rewritten into
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1363" data-line-first="1364" style="display:block"><code data-line="1364">  <span style="color:purple">ensures</span> Ascending#[_k](Iterates(x))</code></pre>
<p class="p noindent para-continued" data-line="1367"><span data-line="1367"></span>The good thing is that the body of an extreme lemma allows us to use <span data-line="1367"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1367"></span> directly,
so we can write <span data-line="1368"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Ascending#[_k]</code><span data-line="1368"></span> when we need it.
</p>
<div class="remark para-end note" data-line="1370" style="display:block;margin:1ex 0pt;padding-left:1em;border-left:0.25em teal solid;breakable:true">
<p class="p noindent" data-line="1371"><span data-line="1371"></span><span class="remark-before"><strong class="strong-star2">Remark&#160;<span class="remark-label">3</span>.</strong></span><span data-line="1371"></span><br>
<span data-line="1372"></span>To summarize this subtle point, suppose <span data-line="1372"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">P(x)</code><span data-line="1372"></span> is a least predicate. Then, note
that the rewrite into the prefix lemma uses <span data-line="1373"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1373"></span> in the specification and
<span data-line="1374"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k - <span class="constant" style="color:purple">1</span></code><span data-line="1374"></span> in the body:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1376" data-line-first="1377" style="display:block"><code data-line="1377"><span style="color:blue">least</span> <span style="color:blue">lemma</span> L(x: X)
  <span style="color:purple">requires</span> P(x) <span style="color:darkgreen">// adapted for prefix lemma by automatic rewrite into P#[_k]</span>
  <span style="color:darkgreen">// ...</span>
{
  <span style="color:blue">assert</span> P(x); <span style="color:darkgreen">// adapted for prefix lemma by automatic rewrite into P#[_k - 1]</span>
  <span style="color:darkgreen">// ...</span>
}</code></pre>
<p class="p noindent para-continued" data-line="1386"><span data-line="1386"></span>Dually, if <span data-line="1386"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Q(x)</code><span data-line="1386"></span> is a greatest predicate, then we have:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1388" data-line-first="1389" style="display:block"><code data-line="1389"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span> G(x: X)
  <span style="color:darkgreen">// ...</span>
  <span style="color:purple">ensures</span> Q(x) <span style="color:darkgreen">// adapted for prefix lemma by automatic rewrite into Q#[_k]</span>
{
  <span style="color:darkgreen">// ...</span>
  <span style="color:blue">assert</span> Q(x); <span style="color:darkgreen">// adapted for prefix lemma by automatic rewrite into Q#[_k - 1]</span>
}</code></pre></div>
<p class="p indent" data-line="1398"><span data-line="1398"></span>As a final lemma in this section, we combine the <span data-line="1398"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IteratesAreAscending</code><span data-line="1398"></span>
and <span data-line="1399"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">AscendingIsFinite</code><span data-line="1399"></span> to prove
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1401" data-line-first="1402" style="display:block"><code data-line="1402"><span style="color:blue">lemma</span> IteratesAreFinite(x: A)
  <span style="color:purple">requires</span> Acc(x) &amp;&amp; le(x, F(x))
  <span style="color:purple">ensures</span> IsFinite(Iterates(x))
{
  IteratesAreAscending(x);
  AscendingIsFinite(Iterates(x));
}</code></pre>
<p class="p noindent para-continued" data-line="1411"><span data-line="1411"></span>Note that this is an ordinary lemma (not an extreme lemma), since our proof
simply uses other lemmas without any need to introduce the <span data-line="1412"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1412"></span> index.
</p><h3 id="sec-computing-the-least-fixpoint" class="h2" data-line="1414" data-heading-depth="2" style="display:block"><span data-line="1414"></span><span class="heading-before"><span class="heading-label">3.4</span>.&#8194;</span><span data-line="1414"></span>Computing the Least Fixpoint</h3>
<p class="p noindent" data-line="1416"><span data-line="1416"></span>We<span data-line="1416"></span>&#39;<span data-line="1416"></span>ve finally arrived at where we can write a function that computes the
least fixpoint of <span data-line="1417"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1417"></span>. We<span data-line="1417"></span>&#39;<span data-line="1417"></span>ll do it in two different way, first via our
<span data-line="1418"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates</code><span data-line="1418"></span> function:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1420" data-line-first="1421" style="display:block"><code data-line="1421"><span style="color:blue">function</span> LFP(): A {
  AboutIteratesOfBot();
  Last(Iterates(bot))
}</code></pre>
<p class="p noindent para-continued" data-line="1427"><span data-line="1427"></span>The compiled function body is just <span data-line="1427"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Last(Iterates(bot))</code><span data-line="1427"></span>. However, to use
function <span data-line="1428"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Last</code><span data-line="1428"></span>, we must meet its precondition that the given stream is finite.
We gather that information by calling a lemma, which we state and prove thus:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1431" data-line-first="1432" style="display:block"><code data-line="1432"><span style="color:blue">lemma</span> AboutIteratesOfBot()
  <span style="color:purple">ensures</span> IsFinite(Iterates(bot))
{
  BotAcc();
  BotSmallest(F(bot));
  IteratesAreFinite(bot);
}</code></pre>
<p class="p noindent para-continued" data-line="1441"><span data-line="1441"></span>Dafny accepts the <span data-line="1441"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFP()</code><span data-line="1441"></span> function, and running it will terminate and return,
uh, the last element of the finite stream <span data-line="1442"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates(bot)</code><span data-line="1442"></span>. But what says
that element is the least fixpoint? Indeed, what says a least fixpoint exists,
let along any fixpoint at all? Here is a lemma that addresses all of those
points:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1447" data-line-first="1448" style="display:block"><code data-line="1448"><span style="color:blue">lemma</span> LFPIsLeastFixpoint()
  <span style="color:purple">ensures</span> <span style="color:blue">var</span> lfp := LFP();
    IsFixpoint(lfp) &amp;&amp;
    <span style="color:blue">forall</span> y :: IsFixpoint(y) ==&gt; le(lfp, y)</code></pre>
<p class="p noindent para-continued" data-line="1454"><span data-line="1454"></span>Let<span data-line="1454"></span>&#39;<span data-line="1454"></span>s build up the proof.
</p>
<p class="p indent" data-line="1456"><span data-line="1456"></span>First, just like in the postcondition of the lemma, it will be convenient in the
proof to have a name for the result of <span data-line="1457"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFP()</code><span data-line="1457"></span>. So, let<span data-line="1457"></span>&#39;<span data-line="1457"></span>s assign it to a local
variable:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1460" data-line-first="1461" style="display:block"><code data-line="1461">{
  <span style="color:blue">var</span> lfp := LFP();</code></pre>
<p class="p noindent para-continued" data-line="1465"><span data-line="1465"></span>We<span data-line="1465"></span>&#39;<span data-line="1465"></span>ll need to know, just like in the body of <span data-line="1465"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFP()</code><span data-line="1465"></span> that the iterates from
<span data-line="1466"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">bot</code><span data-line="1466"></span> form a finite stream, so let<span data-line="1466"></span>&#39;<span data-line="1466"></span>s call the lemma that gives us this information:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1468" data-line-first="1469" style="display:block"><code data-line="1469">  AboutIteratesOfBot();</code></pre>
<p class="p noindent para-continued" data-line="1472"><span data-line="1472"></span>Next, let<span data-line="1472"></span>&#39;<span data-line="1472"></span>s prove <span data-line="1472"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">lfp</code><span data-line="1472"></span> to be a fixpoint. We<span data-line="1472"></span>&#39;<span data-line="1472"></span>ll structure this part of the proof using
an <span data-line="1473"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">assert</span> <span style="color:blue">by</span></code><span data-line="1473"></span> statement, which first states what we intend to prove and then, in curly
braces, gives the proof:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1476" data-line-first="1477" style="display:block"><code data-line="1477">  <span style="color:blue">assert</span> IsFixpoint(lfp) <span style="color:blue">by</span> {
    LastIterateIsFixpoint(bot);
  }</code></pre>
<p class="p noindent para-continued" data-line="1482"><span data-line="1482"></span>This shows that a fixpoint of <span data-line="1482"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1482"></span> exists, because <span data-line="1482"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFP()</code><span data-line="1482"></span> returns one.
</p>
<p class="p indent" data-line="1484"><span data-line="1484"></span>The other proof obligation is to show the universal quantification
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1486" data-line-first="1487" style="display:block"><code data-line="1487"><span style="color:blue">forall</span> y :: IsFixpoint(y) ==&gt; le(lfp, y)</code></pre>
<p class="p noindent para-continued" data-line="1490"><span data-line="1490"></span>We<span data-line="1490"></span>&#39;<span data-line="1490"></span>ll use the <span data-line="1490"></span>&#8220;universal introduction&#8221;<span data-line="1490"></span> rule from logic, which says that proving the body
of the quantifier for an arbitrary <span data-line="1491"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">y</code><span data-line="1491"></span> is enough to establish it for all <span data-line="1491"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">y</code><span data-line="1491"></span>. In Dafny, universal
introduction is done using a <span data-line="1492"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1492"></span> statement:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1494" data-line-first="1495" style="display:block"><code data-line="1495">  <span style="color:blue">forall</span> y | IsFixpoint(y)
    <span style="color:purple">ensures</span> le(lfp, y)
  {
    <span style="color:darkgreen">// proof of le(lfp, y) goes here...</span>
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1503"><span data-line="1503"></span>All we have left to do now is fill in the body of the <span data-line="1503"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1503"></span> statement.
The basic idea of this proof is to follow each successive element <span data-line="1504"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1504"></span> of <span data-line="1504"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates(bot)</code><span data-line="1504"></span>
and show, for each one, that <span data-line="1505"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le(x, y)</code><span data-line="1505"></span>. Let<span data-line="1505"></span>&#39;<span data-line="1505"></span>s write the proof in two different ways.
</p><h3 id="sec-a-proof-by-recursion" class="h2" data-line="1507" data-heading-depth="2" style="display:block"><span data-line="1507"></span><span class="heading-before"><span class="heading-label">3.5</span>.&#8194;</span><span data-line="1507"></span>A Proof by Recursion</h3>
<p class="p noindent" data-line="1509"><span data-line="1509"></span>Our first proof uses an auxiliary lemma that we prove by induction. That is, the lemma
calls itself recursively to form a proof. The core specification of the lemma is
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1512" data-line-first="1513" style="display:block"><code data-line="1513"><span style="color:blue">lemma</span> IteratesDon&#39;tSkipAnyFixpoint(x: A, y: A)
  <span style="color:purple">requires</span> IsFixpoint(y)
  <span style="color:purple">ensures</span> le(Last(Iterates(x)), y)</code></pre>
<p class="p noindent para-continued" data-line="1518"><span data-line="1518"></span>which would let us call the lemma as <span data-line="1518"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IteratesDon&#39;tSkipAnyFixpoint(bot, y)</code><span data-line="1518"></span> from inside
the <span data-line="1519"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1519"></span> statement of <span data-line="1519"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFPIsLeastFixpoint()</code><span data-line="1519"></span>. But there are three problems with
this specification. You would discover these if you<span data-line="1520"></span>&#39;<span data-line="1520"></span>d attempt the proof, but we<span data-line="1520"></span>&#39;<span data-line="1520"></span>ll just
state them here:
</p>
<p class="p indent" data-line="1523"><span data-line="1523"></span>The first problem is that calling <span data-line="1523"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Last</code><span data-line="1523"></span> requires its argument to be finite. The simplest
solution to this problem is to add <span data-line="1524"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite(Iterates(x))</code><span data-line="1524"></span> as a lemma precondition.
</p>
<p class="p indent" data-line="1526"><span data-line="1526"></span>The second problem is that the lemma doesn<span data-line="1526"></span>&#39;<span data-line="1526"></span>t hold for an arbitrary <span data-line="1526"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1526"></span>. It can hold
only if <span data-line="1527"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">x</code><span data-line="1527"></span> is below <span data-line="1527"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">y</code><span data-line="1527"></span> to begin with. To correct this, we add the precondition <span data-line="1527"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le(x, y)</code><span data-line="1527"></span>.
</p>
<p class="p indent" data-line="1529"><span data-line="1529"></span>The third problem is that we<span data-line="1529"></span>&#39;<span data-line="1529"></span>ll need a termination metric for the lemma<span data-line="1529"></span>&#39;<span data-line="1529"></span>s recursive
call. Since the basic idea of the proof is to follow the successive iterates, we<span data-line="1530"></span>&#39;<span data-line="1530"></span>ll
use the length of the finite iterate stream as the decreasing measure.
</p>
<p class="p indent" data-line="1533"><span data-line="1533"></span>Here<span data-line="1533"></span>&#39;<span data-line="1533"></span>s the result:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1535" data-line-first="1536" style="display:block"><code data-line="1536"><span style="color:blue">lemma</span> IteratesDon&#39;tSkipAnyFixpoint(x: A, y: A)
  <span style="color:purple">requires</span> IsFinite(Iterates(x))
  <span style="color:purple">requires</span> le(x, y) &amp;&amp; IsFixpoint(y)
  <span style="color:purple">ensures</span> le(Last(Iterates(x)), y)
  <span style="color:purple">decreases</span> Length(Iterates(x))
{
  <span style="color:blue">if</span> Iterates(x) == Cons(x, Nil) {
    <span style="color:darkgreen">// we&#39;re done</span>
  } <span style="color:blue">else</span> {
    AboutLength(Iterates(x));
    FMonotonic(x, y);
    IteratesDon&#39;tSkipAnyFixpoint(F(x), y);
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1552"><span data-line="1552"></span>The <span data-line="1552"></span>&#8220;else&#8221;<span data-line="1552"></span> branch of the proof, which invokes the induction hypothesis, also
needs some information about <span data-line="1553"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="1553"></span> as well as the monotonicity of <span data-line="1553"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">F</code><span data-line="1553"></span>.
</p>
<p class="p indent" data-line="1555"><span data-line="1555"></span>To call this lemma from the <span data-line="1555"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1555"></span> statement in <span data-line="1555"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFPIsLeastFixpoint()</code><span data-line="1555"></span>,
we also need the information <span data-line="1556"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">le(bot, y)</code><span data-line="1556"></span>, so we write
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1558" data-line-first="1559" style="display:block"><code data-line="1559">    BotSmallest(y);
    IteratesDon&#39;tSkipAnyFixpoint(bot, y);</code></pre>
<p class="p noindent para-continued" data-line="1563"><span data-line="1563"></span>That concludes the proof and the definition of our iterator.
</p><h2 id="sec-alternative-solutions" class="h1" data-line="1565" data-heading-depth="1" style="display:block"><span data-line="1565"></span><span class="heading-before"><span class="heading-label">4</span>.&#8194;</span><span data-line="1565"></span>Alternative Solutions</h2><h3 id="sec-a-proof-by-iteration" class="h2" data-line="1567" data-heading-depth="2" style="display:block"><span data-line="1567"></span><span class="heading-before"><span class="heading-label">4.0</span>.&#8194;</span><span data-line="1567"></span>A Proof by Iteration</h3>
<p class="p noindent" data-line="1569"><span data-line="1569"></span>Every programmer knows that many problems can be solved either recursively or
iteratively (that is, using a loop). But not every mathematician exercises this
same choice when it comes to proofs. To show how it<span data-line="1571"></span>&#39;<span data-line="1571"></span>s done, let<span data-line="1571"></span>&#39;<span data-line="1571"></span>s write an
iterative proof of <span data-line="1572"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFPIsLeastFixpoint()</code><span data-line="1572"></span>&#39;<span data-line="1572"></span>s <span data-line="1572"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1572"></span> statement here. This proof
will go inside the curly braces of the <span data-line="1573"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1573"></span> statement.
</p>
<p class="p indent" data-line="1575"><span data-line="1575"></span>We<span data-line="1575"></span>&#39;<span data-line="1575"></span>ll use a local variable <span data-line="1575"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ii</code><span data-line="1575"></span> to hold the iterates that we have yet to
loop over. To say that <span data-line="1576"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ii</code><span data-line="1576"></span> is indeed a stream of iterates, we use the loop
invariant
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1579" data-line-first="1580" style="display:block"><code data-line="1580">ii == Iterates(ii.head)</code></pre>
<p class="p noindent para-continued" data-line="1583"><span data-line="1583"></span>Talking about <span data-line="1583"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ii.head</code><span data-line="1583"></span> requires knowing <span data-line="1583"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ii != Nil</code><span data-line="1583"></span>, so we<span data-line="1583"></span>&#39;<span data-line="1583"></span>ll add
<span data-line="1584"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ii != Nil</code><span data-line="1584"></span> to the loop invariant, too. Like in the precondition of the recursive
lemma in the previous section, we<span data-line="1585"></span>&#39;<span data-line="1585"></span>ll use
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1587" data-line-first="1588" style="display:block"><code data-line="1588">IsFinite(ii) &amp;&amp; le(ii.head, y)</code></pre>
<p class="p noindent para-continued" data-line="1591"><span data-line="1591"></span>as part of the loop invariant, and we<span data-line="1591"></span>&#39;<span data-line="1591"></span>ll use <span data-line="1591"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length(ii)</code><span data-line="1591"></span> as the measure that
proves termination. Since we<span data-line="1592"></span>&#39;<span data-line="1592"></span>re writing the loop inside the <span data-line="1592"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">forall</span></code><span data-line="1592"></span> statement,
we don<span data-line="1593"></span>&#39;<span data-line="1593"></span>t need to repeat the condition <span data-line="1593"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFixpoint(y)</code><span data-line="1593"></span>, like we had to do in the
recursive proof. Instead, we need to keep track of that <span data-line="1594"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Last(ii)</code><span data-line="1594"></span> remains equal
to <span data-line="1595"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">lfp</code><span data-line="1595"></span>, which is not necessary in the recursive lemma<span data-line="1595"></span>&#39;<span data-line="1595"></span>s postcondition, since
that proof does not involve any variable that changes values.
</p>
<p class="p indent" data-line="1598"><span data-line="1598"></span>All in all, our iterative version of <span data-line="1598"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFPIsLeastFixpoint</code><span data-line="1598"></span> looks like this:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1600" data-line-first="1601" style="display:block"><code data-line="1601"><span style="color:blue">lemma</span> LFPIsLeastFixpoint()
  <span style="color:purple">ensures</span> <span style="color:blue">var</span> lfp := LFP();
    IsFixpoint(lfp) &amp;&amp;
    <span style="color:blue">forall</span> y :: IsFixpoint(y) ==&gt; le(lfp, y)
{
  <span style="color:blue">var</span> lfp := LFP();
  AboutIteratesOfBot();

  <span style="color:blue">assert</span> IsFixpoint(lfp) <span style="color:blue">by</span> {
    LastIterateIsFixpoint(bot);
  }

  <span style="color:blue">forall</span> y | IsFixpoint(y)
    <span style="color:purple">ensures</span> le(lfp, y)
  {
    BotSmallest(y);
    <span style="color:blue">var</span> ii := Iterates(bot);
    <span style="color:blue">while</span> ii.tail != Nil
      <span style="color:purple">invariant</span> ii != Nil &amp;&amp; ii == Iterates(ii.head)
      <span style="color:purple">invariant</span> IsFinite(ii)
      <span style="color:purple">invariant</span> le(ii.head, y)
      <span style="color:purple">invariant</span> lfp == Last(ii)
      <span style="color:purple">decreases</span> Length(ii)
    {
      AboutLength(ii);
      FMonotonic(ii.head, y);
      ii := ii.tail;
    }
  }
}</code></pre><h3 id="sec-omitting-the-stream-of-iterates" class="h2" data-line="1633" data-heading-depth="2" style="display:block"><span data-line="1633"></span><span class="heading-before"><span class="heading-label">4.1</span>.&#8194;</span><span data-line="1633"></span>Omitting the Stream of Iterates</h3>
<p class="p noindent" data-line="1635"><span data-line="1635"></span>We used streams in development, because it was convenient to define <span data-line="1635"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates(x)</code><span data-line="1635"></span>
without concern about termination. Function <span data-line="1636"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFP()</code><span data-line="1636"></span> above computes <span data-line="1636"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates(bot)</code><span data-line="1636"></span>
and then selects its final element. Space-wise, this would be okay at run time,
because the elements of the stream are computed lazily. For this reason, there<span data-line="1638"></span>&#39;<span data-line="1638"></span>s
never a time when the running program needs to hold on to the stream of all
iterates. For the same reason, streams are unnecessary for the running program.
Let<span data-line="1641"></span>&#39;<span data-line="1641"></span>s write a function that (like <span data-line="1641"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="1641"></span> back in Section<span data-line="1641"></span>&nbsp;<a href="#sec-overview" title="0.&#8194;Introduction" class="localref" style="target-element:h1"><span class="heading-label">0</span></a><span data-line="1641"></span>)
computes a fixpoint without using streams.
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1644" data-line-first="1645" style="display:block"><code data-line="1645"><span style="color:blue">function</span> FindFixpoint(x: A): A
  <span style="color:purple">requires</span> IsFinite(Iterates(x))
  <span style="color:purple">decreases</span> Length(Iterates(x))
{
  <span style="color:blue">var</span> y := F(x);
  <span style="color:blue">if</span> x == y <span style="color:blue">then</span>
    x
  <span style="color:blue">else</span>
    AboutLength(Iterates(x));
    FindFixpoint(y)
}</code></pre>
<p class="p noindent para-continued" data-line="1658"><span data-line="1658"></span>As you can see, this function uses <span data-line="1658"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates</code><span data-line="1658"></span> in its proof of termination, but doesn<span data-line="1658"></span>&#39;<span data-line="1658"></span>t
use <span data-line="1659"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates</code><span data-line="1659"></span> for any non-ghost purpose. Moreover, the function is tail recursive,
so Dafny will compile it efficiently into a loop.
</p>
<p class="p indent" data-line="1662"><span data-line="1662"></span>Let<span data-line="1662"></span>&#39;<span data-line="1662"></span>s not forget to prove the connection between <span data-line="1662"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint</code><span data-line="1662"></span> and <span data-line="1662"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">LFP()</code><span data-line="1662"></span>. We<span data-line="1662"></span>&#39;<span data-line="1662"></span>ll
start with a lemma that shows that <span data-line="1663"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FindFixpoint(x)</code><span data-line="1663"></span> does indeed follow <span data-line="1663"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Iterates(x)</code><span data-line="1663"></span>:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1665" data-line-first="1666" style="display:block"><code data-line="1666"><span style="color:blue">lemma</span> FindFixpointFollowsIterates(x: A)
  <span style="color:purple">requires</span> IsFinite(Iterates(x))
  <span style="color:purple">ensures</span> FindFixpoint(x) == Last(Iterates(x))
  <span style="color:purple">decreases</span> Length(Iterates(x))
{
  <span style="color:blue">if</span> Iterates(x).tail != Nil {
    AboutLength(Iterates(x));
    FindFixpointFollowsIterates(F(x));
  }
}</code></pre>
<p class="p noindent para-continued" data-line="1678"><span data-line="1678"></span>With that lemma in hand, here<span data-line="1678"></span>&#39;<span data-line="1678"></span>s our final function for computing the least fixpoint:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1680" data-line-first="1681" style="display:block"><code data-line="1681"><span style="color:blue">function</span> FindLeastFixpoint(): (lfp: A)
  <span style="color:purple">ensures</span> IsFixpoint(lfp)
  <span style="color:purple">ensures</span> <span style="color:blue">forall</span> y :: IsFixpoint(y) ==&gt; le(lfp, y)
{
  AboutIteratesOfBot();
  FindFixpointFollowsIterates(bot);
  LFPIsLeastFixpoint();
  FindFixpoint(bot)
}</code></pre><h2 id="sec-conclusion" class="h1" data-line="1692" data-heading-depth="1" style="display:block"><span data-line="1692"></span><span class="heading-before"><span class="heading-label">5</span>.&#8194;</span><span data-line="1692"></span>Conclusion</h2>
<p class="p noindent" data-line="1694"><span data-line="1694"></span>If you<span data-line="1694"></span>&#39;<span data-line="1694"></span>ve forgotten the motivation for our main theorem, review the first few paragraphs
of Section<span data-line="1695"></span>&nbsp;<a href="#sec-overview" title="0.&#8194;Introduction" class="localref" style="target-element:h1"><span class="heading-label">0</span></a><span data-line="1695"></span>. Some of the words in those paragraphs may make more sense now.
</p>
<p class="p indent" data-line="1697"><span data-line="1697"></span>Our tutorial journey took us through the definition and use of <span data-line="1697"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">codatatype</span></code><span data-line="1697"></span>s, <span data-line="1697"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span> <span style="color:blue">predicate</span></code><span data-line="1697"></span>s
and <span data-line="1698"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">predicate</span></code><span data-line="1698"></span>s (together known as <span data-line="1698"></span><em class="em-low1">extreme</em><span data-line="1698"></span> predicates), and ordinals. We saw how such
definitions are automatically adapted into corresponding definitions of prefix predicates.
It<span data-line="1700"></span>&#39;<span data-line="1700"></span>s most convenient when a program can use the extreme predicates directly, but the
prefix predicates are also available for when they are needed.
</p>
<p class="p indent" data-line="1703"><span data-line="1703"></span>Establishing the truth of a least predicate and making use of a greatest predicate
are the same as for any predicate. Making use of a least predicate and establishing
the truth of a greatest predicate are done via prefix predicates, for which a
<span data-line="1706"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">least</span> <span style="color:blue">lemma</span></code><span data-line="1706"></span> and <span data-line="1706"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span></code><span data-line="1706"></span>, respectively, provides the scaffolding. The
proof of an extreme lemma looks like a proof where the author forgot to worry about
termination. Kozen and Silva have argued for a similar, carefree way of writing
coinductive proofs<span data-line="1709"></span>&nbsp;<span class="citations" style="target-element:bibitem">[<a href="#kozensilva:practicalcoinduction" title="Dexter Kozen and Alexandra Silva. 
Practical coinduction." class="bibref localref" style="target-element:bibitem"><span class="cite-number">2</span></a>]</span><span data-line="1709"></span>. Dafny adapts extreme lemmas
into prefix lemmas using some rewriting. Fragments of this rewriting can be seen as
hover text in the Dafny IDE.
</p>
<p class="p indent" data-line="1713"><span data-line="1713"></span>Our journey also made use of a <span data-line="1713"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">codatatype</span></code><span data-line="1713"></span>, whose values can be infinite structures.
We started off by writing some useful functions on and lemmas about possibly infinite streams.
</p>
<p class="p indent" data-line="1716"><span data-line="1716"></span>We also saw a number of tricks and techniques. For examples, we declared a
function <span data-line="1717"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">PickK</code><span data-line="1717"></span> to make sure the definition and proofs about <span data-line="1717"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">Length</code><span data-line="1717"></span> used the same
textual occurrences of <span data-line="1718"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">:|</code><span data-line="1718"></span> (since each occurrence gives rise to its own
Hilbert<span data-line="1719"></span>&#39;<span data-line="1719"></span>s-<span data-line="1719"></span>&#949;<span data-line="1719"></span> operator). We used a function <span data-line="1719"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">ReduceK</code><span data-line="1719"></span> to combine the
successor-ordinal and limit-ordinal cases in a compiled function. And we used a
loop to write a proof, as an alternative to using recursion.
</p>
<p class="p indent" data-line="1723"><span data-line="1723"></span>As a final remark, if you have previous experience using other proof systems, you
will notice a difference in what a least predicate is. Other systems tend to define
a least predicate as an inductive data structure that <span data-line="1725"></span>&#8220;remembers&#8221;<span data-line="1725"></span> how the least-predicate
proof term was constructed. Thus, a lemma whose antecedent is a least predicate
is done by induction over that data structure. In Dafny, a least predicate has no
associated data (unless the user defines a separate data structure for this, using
a <span data-line="1729"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">datatype</span></code><span data-line="1729"></span> for a least predicate or a <span data-line="1729"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized"><span style="color:blue">codatatype</span></code><span data-line="1729"></span> for a greatest predicate).
The only clue to how a least predicate was established is the index <span data-line="1730"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">_k</code><span data-line="1730"></span> of the
prefix predicate, which gives (an ordinal) bound on the size of that derivation.
One consequence of this design is that extreme predicates can be used as any other
ghost function in a program.
</p><h2 id="app-answers" class="h1" data-line="1739" data-heading-depth="1" style="display:block"><span data-line="1739"></span><span class="heading-before"><span class="heading-label">A</span>.&#8194;</span><span data-line="1739"></span>Answer to Exercises</h2><h5 id="sec-answer-to-exercise-ex-isfinite-prime" class="h4" data-line="1741" data-heading-depth="4" style="display:block"><span data-line="1741"></span>Answer to Exercise<span data-line="1741"></span>&nbsp;<a href="#ex-isfinite-prime" class="localref" style="target-element:exercise"><span class="exercise-label">0</span></a></h5>
<p class="p noindent" data-line="1743"><span data-line="1743"></span>Here is the (dubious) definition of <span data-line="1743"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite&#39;</code><span data-line="1743"></span> as a greatest predicate:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1745" data-line-first="1746" style="display:block"><code data-line="1746"><span style="color:blue">greatest</span> <span style="color:blue">predicate</span> IsFinite&#39;(s: Stream) {
  s == Nil || IsFinite&#39;(s.tail)
}</code></pre>
<p class="p noindent para-continued" data-line="1751"><span data-line="1751"></span>To show that <span data-line="1751"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">IsFinite&#39;(s)</code><span data-line="1751"></span> holds for any stream <span data-line="1751"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">s</code><span data-line="1751"></span>, we declare the following
greatest lemma:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1754" data-line-first="1755" style="display:block"><code data-line="1755"><span style="color:blue">greatest</span> <span style="color:blue">lemma</span> IsFinite&#39;True(s: Stream)
  <span style="color:purple">ensures</span> IsFinite&#39;(s)
{
}</code></pre>
<p class="p noindent para-continued" data-line="1761"><span data-line="1761"></span>The body is empty, because Dafny<span data-line="1761"></span>&#39;<span data-line="1761"></span>s automatic induction completes the proof.
</p><h5 id="sec-answer-to-exercise-ex-finiteandascending" class="h4" data-line="1763" data-heading-depth="4" style="display:block"><span data-line="1763"></span>Answer to Exercise<span data-line="1763"></span>&nbsp;<a href="#ex-finiteandascending" class="localref" style="target-element:exercise"><span class="exercise-label">1</span></a></h5>
<p class="p noindent" data-line="1765"><span data-line="1765"></span>To define <span data-line="1765"></span><code class="code code1 language-dafnyx lang-dafnyx dafnyx colorized">FiniteAndAscending</code><span data-line="1765"></span>, use a least predicate:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="1767" data-line-first="1768" style="display:block"><code data-line="1768"><span style="color:blue">least</span> <span style="color:blue">predicate</span> FiniteAndAscending(s: Stream&lt;A&gt;) {
  <span style="color:blue">match</span> s
  <span style="color:blue">case</span> Nil =&gt; <span style="color:blue">true</span>
  <span style="color:blue">case</span> Cons(x, Nil) =&gt; <span style="color:blue">true</span>
  <span style="color:blue">case</span> Cons(x, Cons(y, _)) =&gt; lt(x, y) &amp;&amp; FiniteAndAscending(s.tail)
}</code></pre>
<div class="bibl" data-line="1776;out/krml285-bib.bbl.mdk:1" style="bbl-file:out/krml285-bib.bbl.mdk"><h2 id="sec-references" class="clearnum h1 heading-references" data-line="1776;out/krml285-bib.bbl.mdk:2" data-heading-depth="1" style="display:block"><span data-line="1776;out/krml285-bib.bbl.mdk:2"></span>References</h2>
<div class="bibliography bib-numeric" data-hanging-indent="0" data-style="plain" data-line="1776;out/krml285-bib.bbl.mdk:3" style="bibstyle:madoko-numeric">
<div id="cousotcousot:constructivetarski" class="bibitem" data-cite-label="0" data-line="1776;out/krml285-bib.bbl.mdk:4" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[0];searchterm:Constructive+versions+Tarski+fixed+point+theorems+++Cousot+Cousot+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:5"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[0]</span><span data-line="1776;out/krml285-bib.bbl.mdk:5"></span>P. Cousot and R. Cousot.
<span data-line="1776;out/krml285-bib.bbl.mdk:6"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:6"></span> Constructive versions of Tarski<span data-line="1776;out/krml285-bib.bbl.mdk:6"></span>&#39;<span data-line="1776;out/krml285-bib.bbl.mdk:6"></span>s fixed point theorems.
<span data-line="1776;out/krml285-bib.bbl.mdk:7"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:7"></span> <span data-line="1776;out/krml285-bib.bbl.mdk:7"></span><em class="em-low1">Pacific Journal of Mathematics</em><span data-line="1776;out/krml285-bib.bbl.mdk:7"></span><span data-line="1776;out/krml285-bib.bbl.mdk:7"></span>, 81(1):43<span data-line="1776;out/krml285-bib.bbl.mdk:7"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:7"></span>57, 1979.<span data-line="1776;out/krml285-bib.bbl.mdk:7"></span>&nbsp;<a href="http://www.bing.com/search?q=Constructive+versions+Tarski+fixed+point+theorems+++Cousot+Cousot+" class="bibsearch">&#128270;</a></div>
<div id="cousotcousot:abstractinterpretation" class="bibitem" data-cite-label="1" data-line="1776;out/krml285-bib.bbl.mdk:10" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[1];searchterm:Patrick+Cousot+Rhadia+Cousot+Abstract+interpretation+unified+lattice+model+static+analysis+programs+construction+approximation+fixpoints+_Conference+Record+Fourth+Annual+Symposium+Principles+Programming+Languages_+pages+January++;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:11"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[1]</span><span data-line="1776;out/krml285-bib.bbl.mdk:11"></span>Patrick Cousot and Rhadia Cousot.
<span data-line="1776;out/krml285-bib.bbl.mdk:12"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:12"></span> Abstract interpretation: a unified lattice model for static analysis
  of programs by construction or approximation of fixpoints.
<span data-line="1776;out/krml285-bib.bbl.mdk:14"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:14"></span> In <span data-line="1776;out/krml285-bib.bbl.mdk:14"></span><em class="em-low1">Conference Record of the Fourth Annual ACM Symposium on
  Principles of Programming Languages</em><span data-line="1776;out/krml285-bib.bbl.mdk:15"></span><span data-line="1776;out/krml285-bib.bbl.mdk:15"></span>, pages 238<span data-line="1776;out/krml285-bib.bbl.mdk:15"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:15"></span>252. ACM, January 1977.<span data-line="1776;out/krml285-bib.bbl.mdk:15"></span>&nbsp;<a href="http://www.bing.com/search?q=Patrick+Cousot+Rhadia+Cousot+Abstract+interpretation+unified+lattice+model+static+analysis+programs+construction+approximation+fixpoints+_Conference+Record+Fourth+Annual+Symposium+Principles+Programming+Languages_+pages+January++" class="bibsearch">&#128270;</a></div>
<div id="kozensilva:practicalcoinduction" class="bibitem" data-cite-label="2" data-line="1776;out/krml285-bib.bbl.mdk:18" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[2];searchterm:Practical+coinduction++Dexter+Kozen+Alexandra+Silva+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:19"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[2]</span><span data-line="1776;out/krml285-bib.bbl.mdk:19"></span>Dexter Kozen and Alexandra Silva.
<span data-line="1776;out/krml285-bib.bbl.mdk:20"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:20"></span> Practical coinduction.
<span data-line="1776;out/krml285-bib.bbl.mdk:21"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:21"></span> <span data-line="1776;out/krml285-bib.bbl.mdk:21"></span><em class="em-low1">Mathematical Structures in Computer Science</em><span data-line="1776;out/krml285-bib.bbl.mdk:21"></span><span data-line="1776;out/krml285-bib.bbl.mdk:21"></span>, 27(7):1132<span data-line="1776;out/krml285-bib.bbl.mdk:21"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:21"></span>1152,
  2017.<span data-line="1776;out/krml285-bib.bbl.mdk:22"></span>&nbsp;<a href="http://www.bing.com/search?q=Practical+coinduction++Dexter+Kozen+Alexandra+Silva+" class="bibsearch">&#128270;</a></div>
<div id="leino:induction" class="bibitem" data-cite-label="3" data-line="1776;out/krml285-bib.bbl.mdk:25" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[3];searchterm:Automating+induction+with+solver+++Rustan+Leino+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:26"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[3]</span><span data-line="1776;out/krml285-bib.bbl.mdk:26"></span>K.<span data-line="1776;out/krml285-bib.bbl.mdk:26"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:26"></span>Rustan<span data-line="1776;out/krml285-bib.bbl.mdk:26"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:26"></span>M. Leino.
<span data-line="1776;out/krml285-bib.bbl.mdk:27"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:27"></span> Automating induction with an SMT solver.
<span data-line="1776;out/krml285-bib.bbl.mdk:28"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:28"></span> In Viktor Kuncak and Andrey Rybalchenko, editors, <span data-line="1776;out/krml285-bib.bbl.mdk:28"></span><em class="em-low1">Verification,
  Model Checking, and Abstract Interpretation &#8212; 13th International
  Conference, VMCAI 2012</em><span data-line="1776;out/krml285-bib.bbl.mdk:30"></span><span data-line="1776;out/krml285-bib.bbl.mdk:30"></span>, volume 7148 of <span data-line="1776;out/krml285-bib.bbl.mdk:30"></span><em class="em-low1">Lecture Notes in Computer
  Science</em><span data-line="1776;out/krml285-bib.bbl.mdk:31"></span><span data-line="1776;out/krml285-bib.bbl.mdk:31"></span>, pages 315<span data-line="1776;out/krml285-bib.bbl.mdk:31"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:31"></span>331. Springer, January 2012.<span data-line="1776;out/krml285-bib.bbl.mdk:31"></span>&nbsp;<a href="http://www.bing.com/search?q=Automating+induction+with+solver+++Rustan+Leino+" class="bibsearch">&#128270;</a></div>
<div id="leino:itp2013" class="bibitem" data-cite-label="4" data-line="1776;out/krml285-bib.bbl.mdk:34" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[4];searchterm:Automating+theorem+proving+with+++Rustan+Leino+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:35"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[4]</span><span data-line="1776;out/krml285-bib.bbl.mdk:35"></span>K.<span data-line="1776;out/krml285-bib.bbl.mdk:35"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:35"></span>Rustan<span data-line="1776;out/krml285-bib.bbl.mdk:35"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:35"></span>M. Leino.
<span data-line="1776;out/krml285-bib.bbl.mdk:36"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:36"></span> Automating theorem proving with SMT.
<span data-line="1776;out/krml285-bib.bbl.mdk:37"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:37"></span> In Sandrine Blazy, Christine Paulin-Mohring, and David Pichardie,
  editors, <span data-line="1776;out/krml285-bib.bbl.mdk:38"></span><em class="em-low1">Interactive Theorem Proving &#8212; 4th International Conference,
  ITP 2013</em><span data-line="1776;out/krml285-bib.bbl.mdk:39"></span><span data-line="1776;out/krml285-bib.bbl.mdk:39"></span>, volume 7998 of <span data-line="1776;out/krml285-bib.bbl.mdk:39"></span><em class="em-low1">Lecture Notes in Computer Science</em><span data-line="1776;out/krml285-bib.bbl.mdk:39"></span><span data-line="1776;out/krml285-bib.bbl.mdk:39"></span>, pages
  2<span data-line="1776;out/krml285-bib.bbl.mdk:40"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:40"></span>16. Springer, July 2013.<span data-line="1776;out/krml285-bib.bbl.mdk:40"></span>&nbsp;<a href="http://www.bing.com/search?q=Automating+theorem+proving+with+++Rustan+Leino+" class="bibsearch">&#128270;</a></div>
<div id="lpar-20:compiling_hilberts_epsilon_operator" class="bibitem" data-cite-label="5" data-line="1776;out/krml285-bib.bbl.mdk:43" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[5];searchterm:Compiling+Hilbert+epsilon+operator+++Rustan+Leino+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:44"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[5]</span><span data-line="1776;out/krml285-bib.bbl.mdk:44"></span>K.<span data-line="1776;out/krml285-bib.bbl.mdk:44"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:44"></span>Rustan<span data-line="1776;out/krml285-bib.bbl.mdk:44"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:44"></span>M. Leino.
<span data-line="1776;out/krml285-bib.bbl.mdk:45"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:45"></span> Compiling Hilbert<span data-line="1776;out/krml285-bib.bbl.mdk:45"></span>&#39;<span data-line="1776;out/krml285-bib.bbl.mdk:45"></span>s epsilon operator.
<span data-line="1776;out/krml285-bib.bbl.mdk:46"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:46"></span> In Ansgar Fehnker, Annabelle McIver, Geoff Sutcliffe, and Andrei
  Voronkov, editors, <span data-line="1776;out/krml285-bib.bbl.mdk:47"></span><em class="em-low1">LPAR-20. 20th International Conferences on Logic for
  Programming, Artificial Intelligence and Reasoning &#8212; Short Presentations</em><span data-line="1776;out/krml285-bib.bbl.mdk:48"></span><span data-line="1776;out/krml285-bib.bbl.mdk:48"></span>,
  volume<span data-line="1776;out/krml285-bib.bbl.mdk:49"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:49"></span>35 of <span data-line="1776;out/krml285-bib.bbl.mdk:49"></span><em class="em-low1">EPiC Series in Computing</em><span data-line="1776;out/krml285-bib.bbl.mdk:49"></span><span data-line="1776;out/krml285-bib.bbl.mdk:49"></span>, pages 106<span data-line="1776;out/krml285-bib.bbl.mdk:49"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:49"></span>118. EasyChair, 2015.<span data-line="1776;out/krml285-bib.bbl.mdk:49"></span>&nbsp;<a href="http://www.bing.com/search?q=Compiling+Hilbert+epsilon+operator+++Rustan+Leino+" class="bibsearch">&#128270;</a></div>
<div id="krml265:callinglemmasautomatically" class="bibitem" data-cite-label="6" data-line="1776;out/krml285-bib.bbl.mdk:52" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[6];searchterm:Dafny+power+user+Calling+lemmas+automatically+++Rustan+Leino+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:53"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[6]</span><span data-line="1776;out/krml285-bib.bbl.mdk:53"></span>K.<span data-line="1776;out/krml285-bib.bbl.mdk:53"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:53"></span>Rustan<span data-line="1776;out/krml285-bib.bbl.mdk:53"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:53"></span>M. Leino.
<span data-line="1776;out/krml285-bib.bbl.mdk:54"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:54"></span> Dafny power user: Calling lemmas automatically.
<span data-line="1776;out/krml285-bib.bbl.mdk:55"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:55"></span> Manuscript KRML 265, June 2019.
<span data-line="1776;out/krml285-bib.bbl.mdk:56"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:56"></span> <span data-line="1776;out/krml285-bib.bbl.mdk:56"></span><a href="http://leino.science/papers/krml265.html" class="texturl monospace">http://&#8203;leino.&#8203;science/&#8203;papers/&#8203;krml265.&#8203;html</a><span data-line="1776;out/krml285-bib.bbl.mdk:56"></span>.<span data-line="1776;out/krml285-bib.bbl.mdk:56"></span>&nbsp;<a href="http://www.bing.com/search?q=Dafny+power+user+Calling+lemmas+automatically+++Rustan+Leino+" class="bibsearch">&#128270;</a></div>
<div id="leinopolikarpova:calc" class="bibitem" data-cite-label="7" data-line="1776;out/krml285-bib.bbl.mdk:59" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[7];searchterm:Verified+calculations+++Rustan+Leino+Nadia+Polikarpova+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:60"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[7]</span><span data-line="1776;out/krml285-bib.bbl.mdk:60"></span>K.<span data-line="1776;out/krml285-bib.bbl.mdk:60"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:60"></span>Rustan<span data-line="1776;out/krml285-bib.bbl.mdk:60"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:60"></span>M. Leino and Nadia Polikarpova.
<span data-line="1776;out/krml285-bib.bbl.mdk:61"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:61"></span> Verified calculations.
<span data-line="1776;out/krml285-bib.bbl.mdk:62"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:62"></span> In Ernie Cohen and Andrey Rybalchenko, editors, <span data-line="1776;out/krml285-bib.bbl.mdk:62"></span><em class="em-low1">Verified
  Software: Theories, Tools, Experiments &#8212; 5th International Conference,
  VSTTE 2013, Revised Selected Papers</em><span data-line="1776;out/krml285-bib.bbl.mdk:64"></span><span data-line="1776;out/krml285-bib.bbl.mdk:64"></span>, volume 8164 of <span data-line="1776;out/krml285-bib.bbl.mdk:64"></span><em class="em-low1">Lecture Notes in
  Computer Science</em><span data-line="1776;out/krml285-bib.bbl.mdk:65"></span><span data-line="1776;out/krml285-bib.bbl.mdk:65"></span>, pages 170<span data-line="1776;out/krml285-bib.bbl.mdk:65"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:65"></span>190. Springer, 2014.<span data-line="1776;out/krml285-bib.bbl.mdk:65"></span>&nbsp;<a href="http://www.bing.com/search?q=Verified+calculations+++Rustan+Leino+Nadia+Polikarpova+" class="bibsearch">&#128270;</a></div>
<div id="martinlof:constructivemath" class="bibitem" data-cite-label="8" data-line="1776;out/krml285-bib.bbl.mdk:68" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[8];searchterm:_Notes+Constructive+Mathematics_+++Martin+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:69"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[8]</span><span data-line="1776;out/krml285-bib.bbl.mdk:69"></span>Per Martin-L<span data-line="1776;out/krml285-bib.bbl.mdk:69"></span>&#246;<span data-line="1776;out/krml285-bib.bbl.mdk:69"></span>f.
<span data-line="1776;out/krml285-bib.bbl.mdk:70"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:70"></span> <span data-line="1776;out/krml285-bib.bbl.mdk:70"></span><em class="em-low1">Notes on Constructive Mathematics</em><span data-line="1776;out/krml285-bib.bbl.mdk:70"></span><span data-line="1776;out/krml285-bib.bbl.mdk:70"></span>.
<span data-line="1776;out/krml285-bib.bbl.mdk:71"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:71"></span> Stockholm, Almqvist <span data-line="1776;out/krml285-bib.bbl.mdk:71"></span>&#38;<span data-line="1776;out/krml285-bib.bbl.mdk:71"></span> Wiksell, 1970.<span data-line="1776;out/krml285-bib.bbl.mdk:71"></span>&nbsp;<a href="http://www.bing.com/search?q=_Notes+Constructive+Mathematics_+++Martin+" class="bibsearch">&#128270;</a></div>
<div id="knastertarski" class="bibitem" data-cite-label="9" data-line="1776;out/krml285-bib.bbl.mdk:74" style="text-indent:-2rem;margin-left:2rem;bibitem-label:[9];searchterm:+lattice+theoretical+fixed+point+theorem+applications+++Tarski+;spellcheck:false"><span data-line="1776;out/krml285-bib.bbl.mdk:75"></span><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[9]</span><span data-line="1776;out/krml285-bib.bbl.mdk:75"></span>A.<span data-line="1776;out/krml285-bib.bbl.mdk:75"></span>&#160;<span data-line="1776;out/krml285-bib.bbl.mdk:75"></span>Tarski.
<span data-line="1776;out/krml285-bib.bbl.mdk:76"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:76"></span> A lattice theoretical fixed point theorem and its applications.
<span data-line="1776;out/krml285-bib.bbl.mdk:77"></span><span class="newblock"></span><span data-line="1776;out/krml285-bib.bbl.mdk:77"></span> <span data-line="1776;out/krml285-bib.bbl.mdk:77"></span><em class="em-low1">Pacific Journal of Mathematics</em><span data-line="1776;out/krml285-bib.bbl.mdk:77"></span><span data-line="1776;out/krml285-bib.bbl.mdk:77"></span>, 5:285<span data-line="1776;out/krml285-bib.bbl.mdk:77"></span>&#8211;<span data-line="1776;out/krml285-bib.bbl.mdk:77"></span>309, 1955.<span data-line="1776;out/krml285-bib.bbl.mdk:77"></span>&nbsp;<a href="http://www.bing.com/search?q=+lattice+theoretical+fixed+point+theorem+applications+++Tarski+" class="bibsearch">&#128270;</a></div></div></div><span data-line=""></span></div>
<svg id='math-svg-paths' style='display:none' version='1.1' viewBox='0 0 0 0' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'>
<defs>
<path d='M8.269 -6.426C8.269 -6.884 7.502 -6.814 7.193 -6.814H3.437C2.939 -6.814 2.052 -6.526 1.893 -5.988C1.913 -5.928 1.933 -5.918 1.993 -5.918C2.212 -5.918 2.511 -6.097 2.65 -6.247C2.959 -6.247 3.258 -6.267 3.567 -6.267H4.184C4.184 -6.267 4.144 -6.087 4.144 -6.077C3.756 -4.254 3.168 -2.71 2.73 -1.733C2.67 -1.604 2.132 -0.359 1.993 -0.239C1.554 -0.239 1.225 -0.478 1.046 -0.867C1.016 -0.927 1.016 -0.966 0.946 -0.966C0.717 -0.966 0.169 -0.648 0.169 -0.478C0.169 -0.458 0.179 -0.438 0.189 -0.418C0.369 0.05 0.817 0.319 1.305 0.319C1.813 0.319 2.401 -0.05 2.72 -0.418C3.049 -0.797 3.706 -2.431 3.965 -3.029H5.888C5.878 -3.019 5.868 -3.009 5.868 -2.999C5.868 -2.959 5.928 -2.929 5.968 -2.929C6.187 -2.929 6.755 -3.208 6.755 -3.517C6.755 -3.587 6.685 -3.577 6.565 -3.577H4.174C4.433 -4.473 4.772 -5.35 4.951 -6.267H6.267C6.516 -6.267 7.213 -6.316 7.392 -6.097C7.412 -6.037 7.382 -5.938 7.412 -5.888C7.432 -5.868 7.462 -5.858 7.492 -5.858C7.731 -5.858 8.269 -6.157 8.269 -6.426Z' id='g0-70'/>
<path d='M4.075 -6.296C4.075 -6.476 4.075 -6.655 3.875 -6.655S3.676 -6.446 3.676 -6.296V-0.399H0.907C0.757 -0.399 0.548 -0.399 0.548 -0.199S0.757 0 0.907 0H6.854C7.024 0 7.203 0 7.203 -0.199S7.024 -0.399 6.854 -0.399H4.075V-6.296Z' id='g0-63'/>
<path d='M3.776 9.624C3.836 9.803 3.925 9.963 4.144 9.963C4.384 9.963 4.443 9.793 4.493 9.644L7.681 0.558C7.731 0.418 7.731 0.359 7.731 0.349C7.731 0.139 7.562 0 7.392 0C7.213 0 7.103 0.1 7.034 0.299L4.144 8.578L1.265 0.349C1.205 0.179 1.146 0 0.897 0C0.727 0 0.558 0.139 0.558 0.349C0.558 0.369 0.558 0.418 0.608 0.558L3.776 9.624Z' id='g1-87'/>
<path d='M6.017 -5.559C6.077 -5.689 6.087 -5.709 6.087 -5.758C6.087 -5.868 5.998 -5.958 5.888 -5.958C5.788 -5.958 5.729 -5.888 5.659 -5.738L3.318 -0.468L0.976 -5.748C0.897 -5.938 0.817 -5.958 0.747 -5.958C0.638 -5.958 0.548 -5.868 0.548 -5.758C0.548 -5.738 0.548 -5.719 0.608 -5.599L3.088 0.01C3.168 0.179 3.228 0.219 3.318 0.219C3.447 0.219 3.477 0.149 3.537 0.01L6.017 -5.559Z' id='g0-95'/>
<path d='M4.981 -6.555C4.981 -6.884 4.951 -6.914 4.633 -6.914H0.897C0.727 -6.914 0.548 -6.914 0.548 -6.715S0.727 -6.516 0.897 -6.516H4.583V-3.656H1.036C0.867 -3.656 0.687 -3.656 0.687 -3.457S0.867 -3.258 1.036 -3.258H4.583V-0.399H0.897C0.727 -0.399 0.548 -0.399 0.548 -0.199S0.727 0 0.897 0H4.633C4.951 0 4.981 -0.03 4.981 -0.359V-6.555Z' id='g0-57'/>
</defs>
</svg>

</body>

</html>
