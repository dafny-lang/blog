<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.2.3" />
  <meta name="viewport" content="initial-scale=1.0" />
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote {
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013";
      position: absolute;
      margin-left: -1em;
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    text-align: left;
    white-space: pre;
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko span.math-rendering {
    display:inline-block;
    width:8em;
    overflow-x:auto;
    font-size:70%;
  }
  .madoko span.math-rendering::-webkit-scrollbar {
    width:4px;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 {
    margin-top: 1.22em;
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  {
    margin-top: 1ex;
  }
  .madoko h5, .madoko h6 {
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 {
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 {
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt,
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  
  <style>
    body.madoko {
        max-width: 100%;
        margin: 0;
        padding: 0;
      }
      .page-content {
        padding: 0;
      }
  </style>
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">

<p class="p noindent" data-line="19"><span data-line="19"></span>Dafny is a programming language. It should be familiar to anyone with
experience with languages like Java or C<span data-line="20"></span>#<span data-line="20"></span>.  In a nutshell, it is
characterized by:
</p>
<ul class="ul list-dash compact" data-line="23">
<li class="li ul-li list-dash-li compact-li" data-line="23"><span data-line="23"></span>A strong and static type system
</li>
<li class="li ul-li list-dash-li compact-li" data-line="24"><span data-line="24"></span>Class-based object-orientation, with trait-based inheritance
</li>
<li class="li ul-li list-dash-li compact-li" data-line="25"><span data-line="25"></span>Functional programming features and a module system
</li></ul>

<p class="p noindent" data-line="27"><span data-line="27"></span>It comes with standard tools such as a compiler, support for testing
and test generation, a VSCode IDE extension, support for projects and
packaging.
</p>
<p class="p indent" data-line="31"><span data-line="31"></span>There are two characteristics that make Dafny quite different from
most other programming languages.  First and foremost, Dafny is a
language designed with formal verification in mind. In Dafny, you can
annotate your code to mathematically formalize its specification, and
verify that your code is correct with respect to its specification.
</p>
<p class="p indent" data-line="37"><span data-line="37"></span>Second, Dafny takes interoperability very seriously. We understand
that if you have an existing application written in another language,
the benefits of formal verification don<span data-line="39"></span>&#39;<span data-line="39"></span>t justify the costs of
rewriting your application in Dafny. Despite its importance, we will
not discuss interoperability any further, but this will be the topic
of other blog posts.
</p>
<p class="p indent" data-line="44"><span data-line="44"></span>We<span data-line="44"></span>&#39;<span data-line="44"></span>re going to introduce Dafny and some of its less common concepts
through a classic example: insertion sort. Ideally, reading through
will give you a concrete idea of what it feels like to write verified
software. All you need to follow is some experience with a Java-like
language  and a vague recollection of insertion sort. 
</p><h2 id="sec-an-unverified-implementation-of-insertion-sort" class="h1" data-line="50" data-heading-depth="1" style="display:block"><span data-line="50"></span>An Unverified Implementation of Insertion Sort</h2>
<p class="p noindent" data-line="52"><span data-line="52"></span>Dafny is a full-fledged programming language and you may even want to
use it if you have no interest in verification whatsoever. In fact,
writing unverified Dafny program is a good way to get familiarity with
the language.  Following is one possible implementation of
insertion sort in Dafny.
</p><!-- inline-dafny Unverified/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="60" data-line-first="61" style="display:block"><code data-line="61">  <span style="color:blue">method</span> {<span style="color:purple">:verify</span> <span style="color:blue">false</span>} InsertionSort(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;)
  {
    for i <span style="color:blue">:=</span> <span class="constant" style="color:purple">0</span> to a.Length
    {
      <span style="color:blue">var</span> minValue <span style="color:blue">:=</span> a[i];
      <span style="color:blue">var</span> minPos <span style="color:blue">:=</span> i;
      for j <span style="color:blue">:=</span> i + <span class="constant" style="color:purple">1</span> to a.Length
      {
        <span style="color:blue">if</span> a[j] &lt; minValue {
          minValue <span style="color:blue">:=</span> a[j];
          minPos <span style="color:blue">:=</span> j;
        }
      }
      <span style="color:blue">if</span> i != minPos {
        a[i], a[minPos] <span style="color:blue">:=</span> minValue, a[i];
      }
    }
  }</code></pre>
<p class="p noindent para-continued" data-line="82"><span data-line="82"></span>Insertion sort is implemented as a method named <span data-line="82"></span><code class="code code1">InsertionSort</code><span data-line="82"></span> (which
needs not belong to a class) that takes as a input parameter an array
of integers <span data-line="84"></span><code class="code code1">a</code><span data-line="84"></span> of type <span data-line="84"></span><code class="code code1">array&lt;int&gt;</code><span data-line="84"></span>.  It sorts the array in place
using two local variables declarations, two nested for loops,
conditional statements, and assignments. Our method is marked as
<span data-line="87"></span><code class="code code1">{:verify false}</code><span data-line="87"></span> because we do not want verification to kick in yet.
</p>
<p class="p indent" data-line="89"><span data-line="89"></span>Lets write a <span data-line="89"></span><code class="code code1">Main</code><span data-line="89"></span> method to run our program and check that it works,
at least on this one example.
</p><!-- inline-dafny Unverified/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="94" data-line-first="95" style="display:block"><code data-line="95">  <span style="color:blue">method</span> Main()
  {
    <span style="color:blue">var</span> a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt; <span style="color:blue">:=</span> <span style="color:blue">new</span> <span style="color:teal">int</span>[<span class="constant" style="color:purple">3</span>];
    a[<span class="constant" style="color:purple">0</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">2</span>; a[<span class="constant" style="color:purple">1</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">4</span>; a[<span class="constant" style="color:purple">2</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">1</span>;
    InsertionSort(a);
    <span style="color:blue">print</span> a[..];
  }

}</code></pre>
<p class="p noindent para-continued" data-line="107"><span data-line="107"></span>If you copy and paste these two methods into a file, say <span data-line="107"></span><code class="code code1">isort.dfy</code><span data-line="107"></span>,
install dafny, and run <span data-line="108"></span><code class="code code1">dafny run isort.dfy</code><span data-line="108"></span> on the command line, you
will see the message:
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="111" data-line-first="112" style="display:block"><code data-line="112">Dafny program verifier did not attempt verification
[1, 2, 4]</code></pre><h2 id="sec-verification-of-insertion-sort" class="h1" data-line="116" data-heading-depth="1" style="display:block"><span data-line="116"></span>Verification of Insertion Sort</h2>
<p class="p noindent" data-line="118"><span data-line="118"></span>Let<span data-line="118"></span>&#39;<span data-line="118"></span>s now verify our implementation of insertion sort. Before we can
do the actual verification, we need to specify what we expect of
insertion sort. First, we need to formalize what it means for an array
to be ordered.
</p>
<p class="p indent" data-line="123"><span data-line="123"></span>In English, we might say something like: <span data-line="123"></span><em class="em-star1">Definition: an array is
ordered if for any non-negative integer value i ranging from 0 to the
length of the array, excluded, the value at index i is less than the
value at index i+1</em><span data-line="126"></span>. With more formal notation, we might also say:
<span data-line="127"></span><em class="em-star1">Definition: an array a of length l is orderd if and only if for all i
in [0,l), a[i] &lt;= a[i+1]</em><span data-line="128"></span>.
</p>
<p class="p indent" data-line="130"><span data-line="130"></span>In Dafny, we do not write our specifications in English but instead in
a formal language. As a first approximation, the formal language is
that of formal mathematics, in a syntax that closely resembles the
syntax of Dafny<span data-line="133"></span>&#39;<span data-line="133"></span>s expressions. In Dafny, such a definition is called a
<span data-line="134"></span><code class="code code1">predicate</code><span data-line="134"></span>.
</p><!-- inline-dafny VerifiedInt/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="138" data-line-first="139" style="display:block"><code data-line="139">  <span style="color:blue">ghost</span> <span style="color:blue">predicate</span> Ordered(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
    <span style="color:purple">reads</span> a
    <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
  {
    <span style="color:blue">forall</span> i: <span style="color:teal">nat</span> :: <span class="constant" style="color:purple">0</span> &lt; left &lt;= i &lt; right ==&gt; a[i-<span class="constant" style="color:purple">1</span>] &lt;= a[i]
  }</code></pre>
<p class="p noindent para-continued" data-line="148"><span data-line="148"></span>There<span data-line="148"></span>&#39;<span data-line="148"></span>s a lot to unpack in this example. First note that we define a
predicate <span data-line="149"></span><code class="code code1">Ordered</code><span data-line="149"></span> with three typed parameters. The first parameter,
<span data-line="150"></span><code class="code code1">a</code><span data-line="150"></span>, is the array. The two extra parameters, <span data-line="150"></span><code class="code code1">left</code><span data-line="150"></span> and <span data-line="150"></span><code class="code code1">right</code><span data-line="150"></span> allow
us to generalize the definition to a sub-range, which will be useful
later on.
</p>
<p class="p indent" data-line="154"><span data-line="154"></span>The body of the predicate, <span data-line="154"></span><code class="code code1">forall i: nat :: 0 &lt; left &lt;= i &lt; right ==&gt;
a[i-1] &lt;= a[i]</code><span data-line="155"></span>, is the definition itself. This definition is a
mathematical proposition, as hinted by the keyword <span data-line="156"></span><code class="code code1">forall</code><span data-line="156"></span>. This
proposition may or may not be computable.
</p>
<p class="p indent" data-line="159"><span data-line="159"></span>Our predicate definition is prefixed with the keyword <span data-line="159"></span><code class="code code1">ghost</code><span data-line="159"></span> to
indicate that it is meant to be used for specification purposes and
need not be compiled or be included in the executable. In some cases,
the keyword may be required if the predicate is truly a non-computable
mathematical formula.
</p>
<p class="p indent" data-line="165"><span data-line="165"></span>The two <span data-line="165"></span><em class="em-star1">clauses</em><span data-line="165"></span> that follow the declaration of the predicate are
relevant to verification. The first clause, <span data-line="166"></span><code class="code code1">reads a</code><span data-line="166"></span> makes it
explicit that the predicate reads the array a. This will not play an
important role in our example, but in general, this is critical
information to keep reasoning about heap-allocated objects simple and
modular.
</p>
<p class="p indent" data-line="172"><span data-line="172"></span>The second clause, <span data-line="172"></span><code class="code code1">requires left &lt;= right &lt;= a.Length</code><span data-line="172"></span>, is a
precondition that restricts the definition to values of <span data-line="173"></span><code class="code code1">left</code><span data-line="173"></span>,
<span data-line="174"></span><code class="code code1">right</code><span data-line="174"></span>, and <span data-line="174"></span><code class="code code1">a.Length</code><span data-line="174"></span> to ones satisfying that precondition. Such
preconditions are a fundamental feature of Dafny that allow for the
definition of partial functions. It may not be obvious at first sight,
but this is highly valuable to writing efficient code, since you can
define partial functions and ensure statically that they will not be
used outside of their intended domain of definition, removing any need
for checking arguments at runtime and making your code throw an
exception (hint: Dafny does not have exceptions!), or worse, return a
dummy value.
</p>
<p class="p indent" data-line="184"><span data-line="184"></span>Our specification of insertion sort is not complete yet. Aside from
ensuring that the algorithm makes the array ordered, we also need to
ensure that the values in the array after sorting are the same ones as
before. More formally, we want to ensure that the multiset of values
of the array before and after sorting are equal. We capture this
definition with another predicate, <span data-line="189"></span><code class="code code1">Preserved</code><span data-line="189"></span>.
</p><!-- inline-dafny VerifiedInt/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="193" data-line-first="194" style="display:block"><code data-line="194">  twostate <span style="color:blue">predicate</span> Preserved(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
    <span style="color:purple">reads</span> a
    <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
  {
    <span style="color:teal">multiset</span>(a[left..right]) == <span style="color:teal">multiset</span>(<span style="color:blue">old</span>(a[left..right]))
  }</code></pre>
<p class="p noindent para-continued" data-line="203"><span data-line="203"></span>This definition introduces a few new interesting concepts. First, the
expression <span data-line="204"></span><code class="code code1">multiset(a[left..right])</code><span data-line="204"></span> shows an example use not one but
two of Dany builtin collection types. The subexpression
<span data-line="206"></span><code class="code code1">a[left..right]</code><span data-line="206"></span> transforms the subarray into a <span data-line="206"></span><em class="em-star1">sequence</em><span data-line="206"></span> (or list)
of values. The expression <span data-line="207"></span><code class="code code1">multiset(a[left..right])</code><span data-line="207"></span> creates a
multiset from that sequence. You might think that while this notation
is conveniently succint, the performance of this code will suffer, but
remember, this is part of the specification, and this will have no
impact on the runtime performance of our insertion sort
implementation.
</p>
<p class="p indent" data-line="214"><span data-line="214"></span>Second, note that while predicate <span data-line="214"></span><code class="code code1">Ordered</code><span data-line="214"></span> captures a property that
is intrinsic to the array, our new predicate is meant to capture a
relation between the input and the output of insertion
sort. Therefore, we need to be able to refer to the array both before
execution of insertion sort and after. This is done thanks to the use
of the <span data-line="219"></span><code class="code code1">twostate</code><span data-line="219"></span> prefix that declares that the predicate is a
relation between a heap-allocated object before and after execution of
some method, and the expression <span data-line="221"></span><code class="code code1">old</code><span data-line="221"></span> that refers to the array before
execution. Other mentions of <span data-line="222"></span><code class="code code1">a</code><span data-line="222"></span> refer to that array after execution
of the method.
</p>
<p class="p indent" data-line="225"><span data-line="225"></span>We can now combine our two predicates into one, <span data-line="225"></span><code class="code code1">Sorted</code><span data-line="225"></span>, that will be
the final specification of our implementation.
</p><!-- inline-dafny VerifiedInt/M3 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="230" data-line-first="231" style="display:block"><code data-line="231">  twostate <span style="color:blue">predicate</span> Sorted(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;)
    <span style="color:purple">reads</span> a
  {
    Ordered(a,<span class="constant" style="color:purple">0</span>,a.Length) &amp;&amp; Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
  }</code></pre>
<p class="p noindent para-continued" data-line="239"><span data-line="239"></span>Now that we are done formalizing our specification, we can revisit our
implementation of insertion sort and ensures, with mathematical
certainty, that the code satisfies our specification. To attach the
specification to the implementation, we annotate the method with a
clause <span data-line="243"></span><code class="code code1">ensures Sorted(a)</code><span data-line="243"></span> that establishes that any execution of
<span data-line="244"></span><code class="code code1">InsertionSort</code><span data-line="244"></span> should result in an array <span data-line="244"></span><code class="code code1">a</code><span data-line="244"></span> that satisfies the
predicate <span data-line="245"></span><code class="code code1">Sorted</code><span data-line="245"></span>. We call such clause a postcondition.
</p><!-- inline-dafny VerifiedInt/M4 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="249" data-line-first="250" style="display:block"><code data-line="250">  <span style="color:blue">method</span> InsertionSort(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;)
    <span style="color:purple">modifies</span> a
    <span style="color:purple">ensures</span> Sorted(a)
  {
    for i <span style="color:blue">:=</span> <span class="constant" style="color:purple">0</span> to a.Length
      <span style="color:purple">invariant</span> Ordered(a,<span class="constant" style="color:purple">0</span>,i)
      <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
    {
      <span style="color:blue">var</span> minValue <span style="color:blue">:=</span> a[i];
      <span style="color:blue">var</span> minPos <span style="color:blue">:=</span> i;
      for j <span style="color:blue">:=</span> i + <span class="constant" style="color:purple">1</span> to a.Length
        <span style="color:purple">invariant</span> minPos &lt; a.Length
        <span style="color:purple">invariant</span> a[minPos] == minValue
      {
        <span style="color:blue">if</span> a[j] &lt; minValue {
          minValue <span style="color:blue">:=</span> a[j];
          minPos <span style="color:blue">:=</span> j;
        }
      }
      <span style="color:blue">if</span> i != minPos {
        a[i], a[minPos] <span style="color:blue">:=</span> minValue, a[i];
      }
    }
  }

}</code></pre>
<p class="p noindent para-continued" data-line="279"><span data-line="279"></span>Note that the verified implementation is quite close to the unverified
one. One of the fundamental design principles of Dafny is that
programming and veification should be integrated, and in some cases
you should be able to reason about your code directly, and not a model
of it. So, in the same way that the specification is attached to the
declaration, the verification is done by annotating the body of the
code. The <span data-line="285"></span><code class="code code1">modifies a</code><span data-line="285"></span> clause does not play an important role in this
example and is the dual of the reads clause of our predicates. While
predicates need to be specific about what heap-allocated values they
read, methods are usually free to read any heap-allcoated values but
need to be specific about which ones they modify. Combined, these two
kinds of clauses make verification of code that works with
heap-allocated values surprisingly easy.
</p>
<p class="p indent" data-line="293"><span data-line="293"></span>The body of the method was modified for verification purposes by
addings four invariant annotations attached to the loops. To
understand both why we need such annotations, but also why we <span data-line="295"></span><em class="em-star1">only</em><span data-line="295"></span>
need such annotations, it is useful to have a vague understanging of
how verification works.
</p>
<p class="p indent" data-line="299"><span data-line="299"></span>Our verified insertion sort comes with two key ingredients: code and
specification. To verify that the code meets the spec with
mathematical certainlty, testing will not do. Instead, the Dafny
compiler transforms the specification and the code into a mathematical
formula. If we can prove that this mathematical formula is true, then
the code satisfies the specification. Otherwise it may or may
not. Proving such mathematical formula would be a lot of work, so
Dafny makes use of an <span data-line="306"></span><em class="em-star1">automated theorem prover</em><span data-line="306"></span> (ATP) to prove it on
your behalf.
</p>
<p class="p indent" data-line="309"><span data-line="309"></span>Alas, ATPs have fundamental limitations and while they excell at
proving properties of linear code, they need some help with
loops. Fundamentally, they need to know of properties that are true
when the loop start its execution, that remain true after execution of
the loop, and that imply what needs to be true after execution of the
loops. This is called an invariant property because it captures what
does not change despite all the complicated things that happen during
execution of the loop.
</p>
<p class="p indent" data-line="318"><span data-line="318"></span>To understand these invariants, you know need to think about what
insertion sort does and simulate its behavior. At every iteration of
the outer loop, the assumption is that all values at indices less than
the current index have been sorted. The inner loop then searches for
the smallest value in the suffix of the array and this value is
swapped with the value at the current index of the outer loop. We can
capture these properties as invariant. The invariants of the outer
loop indeed state that the array is sorted up to index i, not
included. Meanhile the invariants of the inner loop capture the
property that what is currently considered to be the smallest value in
the suffix of the array is indeed the smallest one we have seen so
far.
</p>
<p class="p indent" data-line="331"><span data-line="331"></span>With these invariant annotations, Dafny can verify on its own, in an
instant, that the body of the method indeed satifies the
postcondition, which specifices that the array is ordered and contains
the same values as when the method was called.
</p><h2 id="sec-three" class="h1" data-line="337" data-heading-depth="1" style="display:block"><span data-line="337"></span>Three</h2><!-- inline-dafny VerifiedAbstract/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="341" data-line-first="342" style="display:block"><code data-line="342">  <span style="color:blue">trait</span> Comparable&lt;T(==)&gt; {

    <span style="color:blue">function</span> Lt(x: T, y: T): <span style="color:teal">bool</span>

  }</code></pre><!-- inline-dafny VerifiedAbstract/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="352" data-line-first="353" style="display:block"><code data-line="353">  <span style="color:blue">trait</span> Sorted&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt; {

    <span style="color:blue">ghost</span> <span style="color:blue">predicate</span> Ordered(a: <span style="color:teal">array</span>&lt;T&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
      <span style="color:purple">reads</span> a
      <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
    {
      <span style="color:blue">forall</span> i: <span style="color:teal">nat</span> :: <span class="constant" style="color:purple">0</span> &lt; left &lt;= i &lt; right ==&gt; Lt(a[i-<span class="constant" style="color:purple">1</span>],a[i]) || a[i-<span class="constant" style="color:purple">1</span>] == a[i]
    }

    twostate <span style="color:blue">predicate</span> Preserved(a: <span style="color:teal">array</span>&lt;T&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
      <span style="color:purple">reads</span> a
      <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
    {
      <span style="color:teal">multiset</span>(a[left..right]) == <span style="color:teal">multiset</span>(<span style="color:blue">old</span>(a[left..right]))
    }

    twostate <span style="color:blue">predicate</span> Sorted(a: <span style="color:teal">array</span>&lt;T&gt;)
      <span style="color:purple">reads</span> a
    {
      Ordered(a,<span class="constant" style="color:purple">0</span>,a.Length) &amp;&amp; Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
    }

  }</code></pre><!-- inline-dafny VerifiedAbstract/M3 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="381" data-line-first="382" style="display:block"><code data-line="382">  <span style="color:blue">trait</span> InsertionSort&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt;, Sorted&lt;T&gt; {

    <span style="color:blue">method</span> InsertionSort(a: <span style="color:teal">array</span>&lt;T&gt;)
      <span style="color:purple">modifies</span> a
      <span style="color:purple">ensures</span> Sorted(a)
    {
      for i <span style="color:blue">:=</span> <span class="constant" style="color:purple">0</span> to a.Length
        <span style="color:purple">invariant</span> Ordered(a,<span class="constant" style="color:purple">0</span>,i)
        <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
      {
        <span style="color:blue">var</span> minValue <span style="color:blue">:=</span> a[i];
        <span style="color:blue">var</span> minPos <span style="color:blue">:=</span> i;
        for j <span style="color:blue">:=</span> i + <span class="constant" style="color:purple">1</span> to a.Length
          <span style="color:purple">invariant</span> minPos &lt; a.Length
          <span style="color:purple">invariant</span> a[minPos] == minValue
        {
          <span style="color:blue">if</span> Lt(a[j], minValue) {
            minValue <span style="color:blue">:=</span> a[j];
            minPos <span style="color:blue">:=</span> j;
          }
        }
        <span style="color:blue">if</span> i != minPos {
          a[i], a[minPos] <span style="color:blue">:=</span> minValue, a[i];
        }
      }
    }

  }</code></pre><!-- inline-dafny VerifiedAbstract/M4 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="415" data-line-first="416" style="display:block"><code data-line="416">  <span style="color:blue">class</span> Sort&lt;T(==)&gt; <span style="color:blue">extends</span> InsertionSort&lt;T&gt; {

    const CMP: (T,T) -&gt; <span style="color:teal">bool</span>

    <span style="color:blue">constructor</span>(cmp: (T,T) -&gt; <span style="color:teal">bool</span>)
      <span style="color:purple">ensures</span> CMP == cmp
    {
      CMP <span style="color:blue">:=</span> cmp;
    }

    <span style="color:blue">function</span> Lt(x: T, y: T): <span style="color:teal">bool</span> {
      CMP(x,y)
    }

  }</code></pre><!-- inline-dafny VerifiedAbstract/M5 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="436" data-line-first="437" style="display:block"><code data-line="437">  <span style="color:blue">method</span> Main()
  {
    <span style="color:blue">var</span> a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt; <span style="color:blue">:=</span> <span style="color:blue">new</span> <span style="color:teal">int</span>[<span class="constant" style="color:purple">3</span>];
    a[<span class="constant" style="color:purple">0</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">2</span>; a[<span class="constant" style="color:purple">1</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">4</span>; a[<span class="constant" style="color:purple">2</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">1</span>;
    <span style="color:blue">var</span> Sort <span style="color:blue">:=</span> <span style="color:blue">new</span> Sort((x: <span style="color:teal">int</span>, y: <span style="color:teal">int</span>) =&gt; x &lt; y);
    Sort.InsertionSort(a);
    <span style="color:blue">print</span> a[..];
  }

}</code></pre><h2 id="sec-four" class="h1" data-line="450" data-heading-depth="1" style="display:block"><span data-line="450"></span>Four</h2><!-- inline-dafny Complexity/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="454" data-line-first="455" style="display:block"><code data-line="455">  <span style="color:blue">trait</span> Measurable&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt; {

    <span style="color:blue">ghost</span> <span style="color:blue">var</span> comparisonCount: <span style="color:teal">nat</span>

    <span style="color:blue">method</span> Ltm(x: T, y: T) <span style="color:blue">returns</span> (b: <span style="color:teal">bool</span>)
      <span style="color:purple">modifies</span> <span style="color:blue">this</span>`comparisonCount
      <span style="color:purple">ensures</span> b ==&gt; Lt(x,y)
      <span style="color:purple">ensures</span> comparisonCount == <span style="color:blue">old</span>(comparisonCount) + <span class="constant" style="color:purple">1</span>
    {
      comparisonCount <span style="color:blue">:=</span> comparisonCount + <span class="constant" style="color:purple">1</span>;
      b <span style="color:blue">:=</span> Lt(x,y);
    }

  }</code></pre><!-- inline-dafny Complexity/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="474" data-line-first="475" style="display:block"><code data-line="475">  <span style="color:blue">function</span> Sum(x: <span style="color:teal">int</span>): <span style="color:teal">nat</span>
  {
    <span style="color:blue">if</span> x &lt;= <span class="constant" style="color:purple">0</span> <span style="color:blue">then</span> <span class="constant" style="color:purple">0</span> <span style="color:blue">else</span> x + Sum(x-<span class="constant" style="color:purple">1</span>)
  }</code></pre><!-- inline-dafny Complexity/M3 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="484" data-line-first="485" style="display:block"><code data-line="485">  <span style="color:blue">trait</span> InsertionSort&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt;, Measurable&lt;T&gt;, Sorted&lt;T&gt; {

    <span style="color:blue">method</span> InsertionSort(a: <span style="color:teal">array</span>&lt;T&gt;)
      <span style="color:purple">modifies</span> a, <span style="color:blue">this</span>
      <span style="color:purple">requires</span> comparisonCount == <span class="constant" style="color:purple">0</span>
      <span style="color:purple">ensures</span> Sorted(a)
      <span style="color:purple">ensures</span> comparisonCount &lt;= a.Length * a.Length
    {

      for i <span style="color:blue">:=</span> <span class="constant" style="color:purple">0</span> to a.Length
        <span style="color:purple">invariant</span> Ordered(a,<span class="constant" style="color:purple">0</span>,i)
        <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
        <span style="color:purple">invariant</span> comparisonCount == i * a.Length - Sum(i)
      {
        <span style="color:blue">var</span> minValue <span style="color:blue">:=</span> a[i];
        <span style="color:blue">var</span> minPos <span style="color:blue">:=</span> i;
        <span style="color:blue">assert</span> comparisonCount == i * a.Length - Sum(i) + (i + <span class="constant" style="color:purple">1</span> - i) - <span class="constant" style="color:purple">1</span>;
        for j <span style="color:blue">:=</span> i + <span class="constant" style="color:purple">1</span> to a.Length
          <span style="color:purple">invariant</span> minPos &lt; a.Length
          <span style="color:purple">invariant</span> a[minPos] == minValue
          <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
          <span style="color:purple">invariant</span> comparisonCount == i * a.Length - Sum(i) + (j - i) - <span class="constant" style="color:purple">1</span>
        {
          <span style="color:blue">label</span> L:
          <span style="color:blue">var</span> cmp <span style="color:blue">:=</span> Ltm(a[j], minValue);
          <span style="color:blue">assert</span> a[..] == <span style="color:blue">old</span>@L(a[..]);
          <span style="color:blue">if</span> cmp {
            minValue <span style="color:blue">:=</span> a[j];
            minPos <span style="color:blue">:=</span> j;
          }
          <span style="color:blue">assert</span>(i * a.Length - Sum(i) + (j - i) - <span class="constant" style="color:purple">1</span>) + <span class="constant" style="color:purple">1</span> == i * a.Length - Sum(i) + ((j + <span class="constant" style="color:purple">1</span>) - i) - <span class="constant" style="color:purple">1</span>;
        }
        <span style="color:blue">if</span> i != minPos {
          a[i], a[minPos] <span style="color:blue">:=</span> minValue, a[i];
        }
        <span style="color:blue">assert</span> comparisonCount == (i+<span class="constant" style="color:purple">1</span>) * a.Length - Sum(i+<span class="constant" style="color:purple">1</span>);
      }
    }

  }</code></pre><!-- inline-dafny Complexity/M4 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="530" data-line-first="531" style="display:block"><code data-line="531">  <span style="color:blue">class</span> Sort&lt;T(==)&gt; <span style="color:blue">extends</span> InsertionSort&lt;T&gt; {

    const CMP: (T,T) -&gt; <span style="color:teal">bool</span>

    <span style="color:blue">constructor</span>(cmp: (T,T) -&gt; <span style="color:teal">bool</span>)
      <span style="color:purple">ensures</span> CMP == cmp
      <span style="color:purple">ensures</span> comparisonCount == <span class="constant" style="color:purple">0</span>
    {
      CMP <span style="color:blue">:=</span> cmp;
      comparisonCount <span style="color:blue">:=</span> <span class="constant" style="color:purple">0</span>;
    }

    <span style="color:blue">function</span> Lt(x: T, y: T): <span style="color:teal">bool</span> {
      CMP(x,y)
    }

  }</code></pre><!-- inline-dafny Complexity/M5 -->


<pre class="para-block pre-fenced pre-fenced3 language-dafny lang-dafny dafny colorized" data-line="552" data-line-first="553" style="display:block"><code data-line="553">  <span style="color:blue">method</span> Main()
  {
    <span style="color:blue">var</span> a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt; <span style="color:blue">:=</span> <span style="color:blue">new</span> <span style="color:teal">int</span>[<span class="constant" style="color:purple">3</span>];
    a[<span class="constant" style="color:purple">0</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">2</span>; a[<span class="constant" style="color:purple">1</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">4</span>; a[<span class="constant" style="color:purple">2</span>] <span style="color:blue">:=</span> <span class="constant" style="color:purple">1</span>;
    <span style="color:blue">var</span> Sort <span style="color:blue">:=</span> <span style="color:blue">new</span> Sort((x: <span style="color:teal">int</span>, y: <span style="color:teal">int</span>) =&gt; x &lt; y);
    Sort.InsertionSort(a);
    <span style="color:blue">print</span> a[..];
  }

}</code></pre><span data-line=""></span></div>
</body>

</html>
