<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.2.3" />
  <meta name="viewport" content="initial-scale=1.0" />
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote {
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013";
      position: absolute;
      margin-left: -1em;
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    text-align: left;
    white-space: pre;
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko span.math-rendering {
    display:inline-block;
    width:8em;
    overflow-x:auto;
    font-size:70%;
  }
  .madoko span.math-rendering::-webkit-scrollbar {
    width:4px;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 {
    margin-top: 1.22em;
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  {
    margin-top: 1ex;
  }
  .madoko h5, .madoko h6 {
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 {
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 {
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt,
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  
  <style>
    body.madoko {
        max-width: 100%;
        margin: 0;
        padding: 0;
      }
      .page-content {
        padding: 0;
      }
  </style>
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">
<h2 id="sec-introduction" class="h1" data-line="19" data-heading-depth="1" style="display:block"><span data-line="19"></span>Introduction</h2>
<p class="p noindent" data-line="21"><span data-line="21"></span>Dafny is a programming language. It should be familiar to anyone with
experience with languages like Java or C<span data-line="22"></span>#<span data-line="22"></span>.  In a nutshell, it is
characterized by:
</p>
<ul class="ul list-dash compact" data-line="25">
<li class="li ul-li list-dash-li compact-li" data-line="25"><span data-line="25"></span>A strong and static type system
</li>
<li class="li ul-li list-dash-li compact-li" data-line="26"><span data-line="26"></span>Class-based object-orientation, with trait-based inheritance
</li>
<li class="li ul-li list-dash-li compact-li" data-line="27"><span data-line="27"></span>Functional programming features and a module system
</li></ul>

<p class="p noindent" data-line="29"><span data-line="29"></span>It comes with standard tools such as a compiler, support for testing
and test generation, a VSCode IDE extension, support for projects and
packaging.
</p>
<p class="p indent" data-line="33"><span data-line="33"></span>There are two characteristics that make Dafny quite different from
most other programming languages.  First and foremost, Dafny is a
language designed with formal verification in mind. In Dafny, you can
annotate your code to mathematically formalize its specification, and
verify that your code is correct with respect to its specification.
</p>
<p class="p indent" data-line="39"><span data-line="39"></span>Second, Dafny takes interoperability very seriously. We understand
that if you have an existing application written in another language,
the benefits of formal verification don<span data-line="41"></span>&#39;<span data-line="41"></span>t justify the costs of
rewriting your application in Dafny. Despite its importance, we will
not discuss interoperability any further, but this will be the topic
of other blog posts.
</p>
<p class="p indent" data-line="46"><span data-line="46"></span>We<span data-line="46"></span>&#39;<span data-line="46"></span>re going to introduce Dafny and some of its less common concepts
through a classic example: insertion sort. Ideally, reading through
will give you a concrete idea of what it feels like to write verified
software. All you need to follow is some experience with a Java-like
language  and a vague recollection of insertion sort. 
</p><h2 id="sec-an-unverified-implementation-of-insertion-sort" class="h1" data-line="52" data-heading-depth="1" style="display:block"><span data-line="52"></span>An Unverified Implementation of Insertion Sort</h2>
<p class="p noindent" data-line="54"><span data-line="54"></span>Dafny is a full-fledged programming language and you may even want to
use it if you have no interest in verification whatsoever. In fact,
writing unverified Dafny program is a good way to get familiarity with
the language.  Following is one possible implementation of
insertion sort in Dafny.
</p><!-- inline-dafny Unverified/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="62" data-line-first="63" style="display:block"><code data-line="63">  <span style="color:blue">method</span> {<span style="color:purple">:verify</span> <span style="color:blue">false</span>} InsertionSort(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;)
  {
    <span style="color:blue">for</span> i := <span class="constant" style="color:purple">0</span> to a.Length
    {
      <span style="color:blue">var</span> minValue := a[i];
      <span style="color:blue">var</span> minPos := i;
      <span style="color:blue">for</span> j := i + <span class="constant" style="color:purple">1</span> to a.Length
      {
        <span style="color:blue">if</span> a[j] &lt; minValue {
          minValue := a[j];
          minPos := j;
        }
      }
      <span style="color:blue">if</span> i != minPos {
        a[i], a[minPos] := minValue, a[i];
      }
    }
  }</code></pre>
<p class="p noindent para-continued" data-line="84"><span data-line="84"></span>Insertion sort is implemented as a method named <span data-line="84"></span><code class="code code1">InsertionSort</code><span data-line="84"></span> (which
needs not belong to a class) that takes as a input parameter an array
of integers <span data-line="86"></span><code class="code code1">a</code><span data-line="86"></span> of type <span data-line="86"></span><code class="code code1">array&lt;int&gt;</code><span data-line="86"></span>.  It sorts the array in place
using two local variables declarations, two nested for loops,
conditional statements, and assignments. Our method is marked as
<span data-line="89"></span><code class="code code1">{:verify false}</code><span data-line="89"></span> because we do not want verification to kick in yet.
</p>
<p class="p indent" data-line="91"><span data-line="91"></span>Lets write a <span data-line="91"></span><code class="code code1">Main</code><span data-line="91"></span> method to run our program and check that it works,
at least on this one example.
</p><!-- inline-dafny Unverified/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="96" data-line-first="97" style="display:block"><code data-line="97">  <span style="color:blue">method</span> Main()
  {
    <span style="color:blue">var</span> a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt; := <span style="color:blue">new</span> <span style="color:teal">int</span>[<span class="constant" style="color:purple">3</span>];
    a[<span class="constant" style="color:purple">0</span>] := <span class="constant" style="color:purple">2</span>; a[<span class="constant" style="color:purple">1</span>] := <span class="constant" style="color:purple">4</span>; a[<span class="constant" style="color:purple">2</span>] := <span class="constant" style="color:purple">1</span>;
    InsertionSort(a);
    <span style="color:blue">print</span> a[..];
  }

}</code></pre>
<p class="p noindent para-continued" data-line="109"><span data-line="109"></span>If you copy and paste these two methods into a file, say <span data-line="109"></span><code class="code code1">isort.dfy</code><span data-line="109"></span>,
install dafny, and run <span data-line="110"></span><code class="code code1">dafny run isort.dfy</code><span data-line="110"></span> on the command line, you
will see the message:
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="113" data-line-first="114" style="display:block"><code data-line="114">Dafny program verifier did not attempt verification
[1, 2, 4]</code></pre><h2 id="sec-verification-of-insertion-sort" class="h1" data-line="118" data-heading-depth="1" style="display:block"><span data-line="118"></span>Verification of Insertion Sort</h2>
<p class="p noindent" data-line="120"><span data-line="120"></span>Let<span data-line="120"></span>&#39;<span data-line="120"></span>s now verify our implementation of insertion sort. Before we can
do the actual verification, we need to specify what we expect of
insertion sort. First, we need to formalize what it means for an array
to be ordered.
</p>
<p class="p indent" data-line="125"><span data-line="125"></span>In English, we might say something like: <span data-line="125"></span><em class="em-star1">Definition: an array is
ordered if for any non-negative integer value i ranging from 0 to the
length of the array, excluded, the value at index i is less than the
value at index i+1</em><span data-line="128"></span>. With more formal notation, we might also say:
<span data-line="129"></span><em class="em-star1">Definition: an array a of length l is ordered if and only if for all i
in [0,l), a[i] &lt;= a[i+1]</em><span data-line="130"></span>.
</p>
<p class="p indent" data-line="132"><span data-line="132"></span>In Dafny, we do not write our specifications in English but instead in
a formal language. As a first approximation, the formal language is
that of formal mathematics, in a syntax that closely resembles the
syntax of Dafny<span data-line="135"></span>&#39;<span data-line="135"></span>s expressions. In Dafny, such a definition is called a
<span data-line="136"></span><code class="code code1">predicate</code><span data-line="136"></span>.
</p><!-- inline-dafny VerifiedInt/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="140" data-line-first="141" style="display:block"><code data-line="141">  <span style="color:blue">ghost</span> <span style="color:blue">predicate</span> Ordered(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
    <span style="color:purple">reads</span> a
    <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
  {
    <span style="color:blue">forall</span> i: <span style="color:teal">nat</span> :: <span class="constant" style="color:purple">0</span> &lt; left &lt;= i &lt; right ==&gt; a[i-<span class="constant" style="color:purple">1</span>] &lt;= a[i]
  }</code></pre>
<p class="p noindent para-continued" data-line="150"><span data-line="150"></span>There<span data-line="150"></span>&#39;<span data-line="150"></span>s a lot to unpack in this example. First note that we define a
predicate <span data-line="151"></span><code class="code code1">Ordered</code><span data-line="151"></span> with three typed parameters. The first parameter,
<span data-line="152"></span><code class="code code1">a</code><span data-line="152"></span>, is the array. The two extra parameters, <span data-line="152"></span><code class="code code1">left</code><span data-line="152"></span> and <span data-line="152"></span><code class="code code1">right</code><span data-line="152"></span> allow
us to generalize the definition to a sub-range, which will be useful
later on.
</p>
<p class="p indent" data-line="156"><span data-line="156"></span>The body of the predicate, <span data-line="156"></span><code class="code code1">forall i: nat :: 0 &lt; left &lt;= i &lt; right ==&gt;
a[i-1] &lt;= a[i]</code><span data-line="157"></span>, is the definition itself. This definition is a
mathematical proposition, as hinted by the keyword <span data-line="158"></span><code class="code code1">forall</code><span data-line="158"></span>. This
proposition may or may not be computable.
</p>
<p class="p indent" data-line="161"><span data-line="161"></span>Our predicate definition is prefixed with the keyword <span data-line="161"></span><code class="code code1">ghost</code><span data-line="161"></span> to
indicate that it is meant to be used for specification purposes and
need not be compiled or be included in the executable. In some cases,
the keyword may be required if the predicate is truly a non-computable
mathematical formula.
</p>
<p class="p indent" data-line="167"><span data-line="167"></span>The two <span data-line="167"></span><em class="em-star1">clauses</em><span data-line="167"></span> that follow the declaration of the predicate are
relevant to verification. The first clause, <span data-line="168"></span><code class="code code1">reads a</code><span data-line="168"></span> makes it
explicit that the predicate reads the array a. This will not play an
important role in our example, but in general, this is critical
information to keep reasoning about heap-allocated objects simple and
modular.
</p>
<p class="p indent" data-line="174"><span data-line="174"></span>The second clause, <span data-line="174"></span><code class="code code1">requires left &lt;= right &lt;= a.Length</code><span data-line="174"></span>, is a
precondition that restricts the definition to values of <span data-line="175"></span><code class="code code1">left</code><span data-line="175"></span>,
<span data-line="176"></span><code class="code code1">right</code><span data-line="176"></span>, and <span data-line="176"></span><code class="code code1">a.Length</code><span data-line="176"></span> to ones satisfying that precondition. Such
preconditions are a fundamental feature of Dafny that allow for the
definition of partial functions. It may not be obvious at first sight,
but this is highly valuable to writing efficient code, since you can
define partial functions and ensure statically that they will not be
used outside of their intended domain of definition, removing any need
for checking arguments at runtime and making your code throw an
exception (hint: Dafny does not have exceptions!), or worse, return a
dummy value.
</p>
<p class="p indent" data-line="186"><span data-line="186"></span>Our specification of insertion sort is not complete yet. Aside from
ensuring that the algorithm makes the array ordered, we also need to
ensure that the values in the array after sorting are the same ones as
before. More formally, we want to ensure that the multiset of values
of the array before and after sorting are equal. We capture this
definition with another predicate, <span data-line="191"></span><code class="code code1">Preserved</code><span data-line="191"></span>.
</p><!-- inline-dafny VerifiedInt/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="195" data-line-first="196" style="display:block"><code data-line="196">  <span style="color:blue">twostate</span> <span style="color:blue">predicate</span> Preserved(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
    <span style="color:purple">reads</span> a
    <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
  {
    <span style="color:teal">multiset</span>(a[left..right]) == <span style="color:teal">multiset</span>(<span style="color:blue">old</span>(a[left..right]))
  }</code></pre>
<p class="p noindent para-continued" data-line="205"><span data-line="205"></span>This definition introduces a few new interesting concepts. First, the
expression <span data-line="206"></span><code class="code code1">multiset(a[left..right])</code><span data-line="206"></span> shows an example use not one but
two of Dafny<span data-line="207"></span>&#39;<span data-line="207"></span>s built-in collection types. The subexpression
<span data-line="208"></span><code class="code code1">a[left..right]</code><span data-line="208"></span> transforms the sub-array into a <span data-line="208"></span><em class="em-star1">sequence</em><span data-line="208"></span> (or list)
of values. The expression <span data-line="209"></span><code class="code code1">multiset(a[left..right])</code><span data-line="209"></span> creates a
multiset from that sequence. You might think that while this notation
is conveniently succint, the performance of this code will suffer, but
remember, this is part of the specification, and this will have no
impact on the runtime performance of our insertion sort
implementation.
</p>
<p class="p indent" data-line="216"><span data-line="216"></span>Second, note that while predicate <span data-line="216"></span><code class="code code1">Ordered</code><span data-line="216"></span> captures a property that
is intrinsic to the array, our new predicate is meant to capture a
relation between the input and the output of insertion
sort. Therefore, we need to be able to refer to the array both before
execution of insertion sort and after. This is done thanks to the use
of the <span data-line="221"></span><code class="code code1">twostate</code><span data-line="221"></span> prefix that declares that the predicate is a
relation between a heap-allocated object before and after execution of
some method, and the expression <span data-line="223"></span><code class="code code1">old</code><span data-line="223"></span> that refers to the array before
execution. Other mentions of <span data-line="224"></span><code class="code code1">a</code><span data-line="224"></span> refer to that array after execution
of the method.
</p>
<p class="p indent" data-line="227"><span data-line="227"></span>We can now combine our two predicates into one, <span data-line="227"></span><code class="code code1">Sorted</code><span data-line="227"></span>, that will be
the final specification of our implementation.
</p><!-- inline-dafny VerifiedInt/M3 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="232" data-line-first="233" style="display:block"><code data-line="233">  <span style="color:blue">twostate</span> <span style="color:blue">predicate</span> Sorted(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;)
    <span style="color:purple">reads</span> a
  {
    Ordered(a,<span class="constant" style="color:purple">0</span>,a.Length) &amp;&amp; Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
  }</code></pre>
<p class="p noindent para-continued" data-line="241"><span data-line="241"></span>Now that we are done formalizing our specification, we can revisit our
implementation of insertion sort and ensures, with mathematical
certainty, that the code satisfies our specification. To attach the
specification to the implementation, we annotate the method with a
clause <span data-line="245"></span><code class="code code1">ensures Sorted(a)</code><span data-line="245"></span> that establishes that any execution of
<span data-line="246"></span><code class="code code1">InsertionSort</code><span data-line="246"></span> should result in an array <span data-line="246"></span><code class="code code1">a</code><span data-line="246"></span> that satisfies the
predicate <span data-line="247"></span><code class="code code1">Sorted</code><span data-line="247"></span>. We call such clause a postcondition.
</p><!-- inline-dafny VerifiedInt/M4 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="251" data-line-first="252" style="display:block"><code data-line="252">  <span style="color:blue">method</span> InsertionSort(a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt;)
    <span style="color:purple">modifies</span> a
    <span style="color:purple">ensures</span> Sorted(a)
  {
    <span style="color:blue">for</span> i := <span class="constant" style="color:purple">0</span> to a.Length
      <span style="color:purple">invariant</span> Ordered(a,<span class="constant" style="color:purple">0</span>,i)
      <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
    {
      <span style="color:blue">var</span> minValue := a[i];
      <span style="color:blue">var</span> minPos := i;
      <span style="color:blue">for</span> j := i + <span class="constant" style="color:purple">1</span> to a.Length
        <span style="color:purple">invariant</span> minPos &lt; a.Length
        <span style="color:purple">invariant</span> a[minPos] == minValue
      {
        <span style="color:blue">if</span> a[j] &lt; minValue {
          minValue := a[j];
          minPos := j;
        }
      }
      <span style="color:blue">if</span> i != minPos {
        a[i], a[minPos] := minValue, a[i];
      }
    }
  }

}</code></pre>
<p class="p noindent para-continued" data-line="281"><span data-line="281"></span>Note that the verified implementation is quite close to the unverified
one. One of the fundamental design principles of Dafny is that
programming and verification should be integrated, and in some cases
you should be able to reason about your code directly, and not a model
of it. So, in the same way that the specification is attached to the
declaration, the verification is done by annotating the body of the
code. The <span data-line="287"></span><code class="code code1">modifies a</code><span data-line="287"></span> clause does not play an important role in this
example and is the dual of the reads clause of our predicates. While
predicates need to be specific about what heap-allocated values they
read, methods are usually free to read any heap-allocated values but
need to be specific about which ones they modify. Combined, these two
kinds of clauses make verification of code that works with
heap-allocated values surprisingly easy.
</p>
<p class="p indent" data-line="295"><span data-line="295"></span>The body of the method was modified for verification purposes by
adding four invariant annotations attached to the loops. To
understand both why we need such annotations, but also why we <span data-line="297"></span><em class="em-star1">only</em><span data-line="297"></span>
need such annotations, it is useful to have a vague understanding of
how verification works.
</p>
<p class="p indent" data-line="301"><span data-line="301"></span>Our verified insertion sort comes with two key ingredients: code and
specification. To verify that the code meets the spec with
mathematical certainly, testing will not do. Instead, the Dafny
compiler transforms the specification and the code into a mathematical
formula. If we can prove that this mathematical formula is true, then
the code satisfies the specification. Otherwise it may or may
not. Proving such mathematical formula would be a lot of work, so
Dafny makes use of an <span data-line="308"></span><em class="em-star1">automated theorem prover</em><span data-line="308"></span> (ATP) to prove it on
your behalf.
</p>
<p class="p indent" data-line="311"><span data-line="311"></span>Alas, ATPs have fundamental limitations and while they excel at
proving properties of linear code, they need some help with
loops. Fundamentally, they need to know of properties that are true
when the loop start its execution, that remain true after execution of
the loop, and that imply what needs to be true after execution of the
loops. This is called an invariant property because it captures what
does not change despite all the complicated things that happen during
execution of the loop.
</p>
<p class="p indent" data-line="320"><span data-line="320"></span>To understand these invariants, you know need to think about what
insertion sort does and simulate its behavior. At every iteration of
the outer loop, the assumption is that all values at indices less than
the current index have been sorted. The inner loop then searches for
the smallest value in the suffix of the array and this value is
swapped with the value at the current index of the outer loop. We can
capture these properties as invariant. The invariants of the outer
loop indeed state that the array is sorted up to index i, not
included. Meanwhile the invariants of the inner loop capture the
property that what is currently considered to be the smallest value in
the suffix of the array is indeed the smallest one we have seen so
far.
</p>
<p class="p indent" data-line="333"><span data-line="333"></span>With these invariant annotations, Dafny can verify on its own, in an
instant, that the body of the method indeed satisfies the
postcondition, which specifies that the array is ordered and contains
the same values as when the method was called.
</p><h2 id="sec-generic-insertion-sort" class="h1" data-line="338" data-heading-depth="1" style="display:block"><span data-line="338"></span>Generic Insertion Sort</h2>
<p class="p noindent" data-line="340"><span data-line="340"></span>To keep things simple, we have thus far assumed that the input array
contains integers. Now we would like to abstract our implementation so
that it can sort an array for any values as long as they can be
compared. In Dafny, we would do this using a <span data-line="343"></span><em class="em-star1">trait</em><span data-line="343"></span>. If you<span data-line="343"></span>&#39;<span data-line="343"></span>re not
familiar with the concept, you can think of it as an interface which
may contain code. We define a trait of <span data-line="345"></span><code class="code code1">Comparable</code><span data-line="345"></span> values.
</p><!-- inline-dafny VerifiedAbstract/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="349" data-line-first="350" style="display:block"><code data-line="350">  <span style="color:blue">trait</span> Comparable&lt;T(==)&gt; {

    <span style="color:blue">function</span> Lt(x: T, y: T): <span style="color:teal">bool</span>

  }</code></pre>
<p class="p noindent para-continued" data-line="358"><span data-line="358"></span>Our trait is generic and parameterized by a type <span data-line="358"></span><code class="code code1">T</code><span data-line="358"></span>. The suffix
<span data-line="359"></span><code class="code code1">(==)</code><span data-line="359"></span> is a <span data-line="359"></span><em class="em-star1">type characteristic</em><span data-line="359"></span> that will ensure that our trait is
only instantiated on types for which it is possible to test whether
two values are equal. The trait contains a single declaration for a
function <span data-line="362"></span><code class="code code1">Lt</code><span data-line="362"></span> that takes two parameters of type <span data-line="362"></span><code class="code code1">T</code><span data-line="362"></span> and returns a
Boolean value.
</p>
<p class="p indent" data-line="365"><span data-line="365"></span>In Dafny, we make a distinction between <span data-line="365"></span><em class="em-star1">methods</em><span data-line="365"></span> and <span data-line="365"></span><em class="em-star1">functions</em><span data-line="365"></span>. As
a first approximation, you can think of them as the imperative and the
functional version of a computation, respectively. While the body of
methods is made of a sequence of statements, the body of a function is
an expression. While a method can declare mutable local variables and
modify heap-allocated values, functions are, as a first approximation,
free of side effects and state.
</p>
<p class="p indent" data-line="373"><span data-line="373"></span>In general, when a choice between a method and a function is possible,
it is wise to choose using a function as it makes verification easier.
</p>
<p class="p indent" data-line="376"><span data-line="376"></span>We extend the <span data-line="376"></span><code class="code code1">Comparable</code><span data-line="376"></span> trait to define a new one, <span data-line="376"></span><code class="code code1">Sorted</code><span data-line="376"></span> that
will group together our predicates for specification.
</p><!-- inline-dafny VerifiedAbstract/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="381" data-line-first="382" style="display:block"><code data-line="382">  <span style="color:blue">trait</span> Sorted&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt; {

    <span style="color:blue">ghost</span> <span style="color:blue">predicate</span> Ordered(a: <span style="color:teal">array</span>&lt;T&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
      <span style="color:purple">reads</span> a
      <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
    {
      <span style="color:blue">forall</span> i: <span style="color:teal">nat</span> :: <span class="constant" style="color:purple">0</span> &lt; left &lt;= i &lt; right ==&gt; Lt(a[i-<span class="constant" style="color:purple">1</span>],a[i]) || a[i-<span class="constant" style="color:purple">1</span>] == a[i]
    }

    <span style="color:blue">twostate</span> <span style="color:blue">predicate</span> Preserved(a: <span style="color:teal">array</span>&lt;T&gt;, left: <span style="color:teal">nat</span>, right: <span style="color:teal">nat</span>)
      <span style="color:purple">reads</span> a
      <span style="color:purple">requires</span> left &lt;= right &lt;= a.Length
    {
      <span style="color:teal">multiset</span>(a[left..right]) == <span style="color:teal">multiset</span>(<span style="color:blue">old</span>(a[left..right]))
    }

    <span style="color:blue">twostate</span> <span style="color:blue">predicate</span> Sorted(a: <span style="color:teal">array</span>&lt;T&gt;)
      <span style="color:purple">reads</span> a
    {
      Ordered(a,<span class="constant" style="color:purple">0</span>,a.Length) &amp;&amp; Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
    }

  }</code></pre>
<p class="p noindent para-continued" data-line="408"><span data-line="408"></span>We can now define insertion sort in a trait <span data-line="408"></span><code class="code code1">InsertionSort</code><span data-line="408"></span> where the
type of values is abstract but extends the traits <span data-line="409"></span><code class="code code1">Comparable</code><span data-line="409"></span> and
<span data-line="410"></span><code class="code code1">Sorted</code><span data-line="410"></span>.
</p><!-- inline-dafny VerifiedAbstract/M3 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="414" data-line-first="415" style="display:block"><code data-line="415">  <span style="color:blue">trait</span> InsertionSort&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt;, Sorted&lt;T&gt; {

    <span style="color:blue">method</span> InsertionSort(a: <span style="color:teal">array</span>&lt;T&gt;)
      <span style="color:purple">modifies</span> a
      <span style="color:purple">ensures</span> Sorted(a)
    {
      <span style="color:blue">for</span> i := <span class="constant" style="color:purple">0</span> to a.Length
        <span style="color:purple">invariant</span> Ordered(a,<span class="constant" style="color:purple">0</span>,i)
        <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
      {
        <span style="color:blue">var</span> minValue := a[i];
        <span style="color:blue">var</span> minPos := i;
        <span style="color:blue">for</span> j := i + <span class="constant" style="color:purple">1</span> to a.Length
          <span style="color:purple">invariant</span> minPos &lt; a.Length
          <span style="color:purple">invariant</span> a[minPos] == minValue
        {
          <span style="color:blue">if</span> Lt(a[j], minValue) {
            minValue := a[j];
            minPos := j;
          }
        }
        <span style="color:blue">if</span> i != minPos {
          a[i], a[minPos] := minValue, a[i];
        }
      }
    }

  }</code></pre>
<p class="p noindent para-continued" data-line="446"><span data-line="446"></span>Dafny is designed in such a way that verification is unaffected by
this abstraction and the verification effort is unchanged.
</p>
<p class="p indent" data-line="449"><span data-line="449"></span>Traits, unlike classes, cannot be instantiated, so if we want to use
our insertion sort implementation, we need to define a class that
extends the trait. You might wonder why we did not define insertion
sort in a class directly: it is because in Dafny, a class cannot
extend another class! This unusual design ensures that you can benefit
from multiple inheritance while keeping verification reasonable
simple. Nevertheless, you should still be able to design your code
following the core precepts of object-oriented programming:
inheritance, sub-typing, late binding, overriding, encapsulation, and
dynamic dispatch. There is one exception: Dafny does not support open
recursion.
</p>
<p class="p indent" data-line="461"><span data-line="461"></span>We therefore define a class <span data-line="461"></span><code class="code code1">Sort</code><span data-line="461"></span> that extends <span data-line="461"></span><code class="code code1">InsertionSort</code><span data-line="461"></span> and
complete its implementation.
</p><!-- inline-dafny VerifiedAbstract/M4 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="466" data-line-first="467" style="display:block"><code data-line="467">  <span style="color:blue">class</span> Sort&lt;T(==)&gt; <span style="color:blue">extends</span> InsertionSort&lt;T&gt; {

    <span style="color:blue">const</span> CMP: (T,T) -&gt; <span style="color:teal">bool</span>

    <span style="color:blue">constructor</span>(cmp: (T,T) -&gt; <span style="color:teal">bool</span>)
      <span style="color:purple">ensures</span> CMP == cmp
    {
      CMP := cmp;
    }

    <span style="color:blue">function</span> Lt(x: T, y: T): <span style="color:teal">bool</span> {
      CMP(x,y)
    }

  }</code></pre>
<p class="p noindent para-continued" data-line="485"><span data-line="485"></span>The class is made of typical members such as fields, constructors,
methods, and functions. A constant (or immutable) field <span data-line="486"></span><code class="code code1">CMP</code><span data-line="486"></span> holds
our comparison function and is set by the constructor. Function <span data-line="487"></span><code class="code code1">Lt</code><span data-line="487"></span>
that was declared in the <span data-line="488"></span><code class="code code1">Comparable</code><span data-line="488"></span> trait is implemented. We can see
that Dafny a glimpse of the functional programming side of Dafny: it
is possible to pass a function as an argument to a
method/function/constructor and to store it in a field.
</p>
<p class="p indent" data-line="493"><span data-line="493"></span>We can now write a <span data-line="493"></span><code class="code code1">Main</code><span data-line="493"></span> method to test our generic insertion sort.
</p><!-- inline-dafny VerifiedAbstract/M5 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="497" data-line-first="498" style="display:block"><code data-line="498">  <span style="color:blue">method</span> Main()
  {
    <span style="color:blue">var</span> a: <span style="color:teal">array</span>&lt;<span style="color:teal">int</span>&gt; := <span style="color:blue">new</span> <span style="color:teal">int</span>[<span class="constant" style="color:purple">3</span>];
    a[<span class="constant" style="color:purple">0</span>] := <span class="constant" style="color:purple">2</span>; a[<span class="constant" style="color:purple">1</span>] := <span class="constant" style="color:purple">4</span>; a[<span class="constant" style="color:purple">2</span>] := <span class="constant" style="color:purple">1</span>;
    <span style="color:blue">var</span> Sort := <span style="color:blue">new</span> Sort((x: <span style="color:teal">int</span>, y: <span style="color:teal">int</span>) =&gt; x &lt; y);
    Sort.InsertionSort(a);
    <span style="color:blue">print</span> a[..];
  }

}</code></pre><h2 id="sec-a-more-advanced-example-of-verification" class="h1" data-line="511" data-heading-depth="1" style="display:block"><span data-line="511"></span>A More Advanced Example of Verification</h2>
<p class="p noindent" data-line="513"><span data-line="513"></span>There is a lot more we could prove about our insertion sort
implementation. For example, you may try to prove that insertion sort
is stable. Instead, we will prove properties about the runtime
complexity of our implementation. This will give us a chance to
introduce more interesting concepts. Recall that when studying the
runtime complexity of a sorting algorithm we usually count either the
number of comparisons, or the number of swaps. In this example, we
will focus on establishing a bound on the number of comparisons. More
specifically, we want to show that if the input array is of size n,
the number of comparisons will be less than n <span data-line="522"></span>*<span data-line="522"></span> n.
</p>
<p class="p indent" data-line="524"><span data-line="524"></span>To that end, we extend trait <span data-line="524"></span><code class="code code1">Comparable</code><span data-line="524"></span> to define a new trait
<span data-line="525"></span><code class="code code1">Measurable</code><span data-line="525"></span>. The purpose of this trait is to keep track of the number
of times we call the comparison function. 
</p><!-- inline-dafny Complexity/M1 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="530" data-line-first="531" style="display:block"><code data-line="531">  <span style="color:blue">trait</span> Measurable&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt; {

    <span style="color:blue">ghost</span> <span style="color:blue">var</span> comparisonCount: <span style="color:teal">nat</span>

    <span style="color:blue">method</span> Ltm(x: T, y: T) <span style="color:blue">returns</span> (b: <span style="color:teal">bool</span>)
      <span style="color:purple">modifies</span> <span style="color:blue">this</span>`comparisonCount
      <span style="color:purple">ensures</span> b ==&gt; Lt(x,y)
      <span style="color:purple">ensures</span> comparisonCount == <span style="color:blue">old</span>(comparisonCount) + <span class="constant" style="color:purple">1</span>
    {
      comparisonCount := comparisonCount + <span class="constant" style="color:purple">1</span>;
      b := Lt(x,y);
    }

  }</code></pre>
<p class="p noindent para-continued" data-line="548"><span data-line="548"></span>A crucial detail is that we are declaring a mutable field,
<span data-line="549"></span><code class="code code1">comparisonCount</code><span data-line="549"></span> as <span data-line="549"></span><code class="code code1">ghost</code><span data-line="549"></span>. This is because while we do need a
variable to keep track of the number of times the comparison function
has been called, we do not want this variable and its counting to
affect the performance of our code! By declaring the field as <span data-line="552"></span><code class="code code1">ghost</code><span data-line="552"></span>,
we ensure that it will be removed by the compiler.
</p>
<p class="p indent" data-line="555"><span data-line="555"></span>The <span data-line="555"></span><code class="code code1">Measurable</code><span data-line="555"></span> trait defines method <span data-line="555"></span><code class="code code1">Ltm</code><span data-line="555"></span> that calls our comparison
function but also increment the counter. Because the counter is ghost,
the statement that increments it will be removed by the
compiler. Because <span data-line="558"></span><code class="code code1">Ltm</code><span data-line="558"></span> modifies the state of the object it belongs
to, it needs to declare <span data-line="559"></span><code class="code code1">modifies this</code><span data-line="559"></span>. In fact, to simplify
verification, we declare more specifically that we modify one specfic
field of the oject as <span data-line="561"></span><code class="code code1">modifies this</code><span data-line="561"></span>comparisonCount<span data-line="561"></span>`<span data-line="561"></span>.
</p>
<p class="p indent" data-line="563"><span data-line="563"></span>At a high-level, a pencil-and-paper proof would look something like
this. Assume that the array is of size l. At every iteration of the
outer loop, if the index is at position i, the inner loop will do
roughly l<span data-line="566"></span> <span data-line="566"></span>- i comparison. All in all, it means that the number of
comparison will be something like l<span data-line="567"></span> <span data-line="567"></span>+ (l-1)<span data-line="567"></span> <span data-line="567"></span>+ <span data-line="567"></span>&#8230;<span data-line="567"></span> <span data-line="567"></span>+ 1.  In preparation
for reasoning about such a summation, we define a function <span data-line="568"></span><code class="code code1">Sum</code><span data-line="568"></span>.
</p><!-- inline-dafny Complexity/M2 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="572" data-line-first="573" style="display:block"><code data-line="573">  <span style="color:blue">ghost</span> <span style="color:blue">function</span> Sum(x: <span style="color:teal">int</span>): <span style="color:teal">nat</span>
  {
    <span style="color:blue">if</span> x &lt;= <span class="constant" style="color:purple">0</span> <span style="color:blue">then</span> <span class="constant" style="color:purple">0</span> <span style="color:blue">else</span> x + Sum(x-<span class="constant" style="color:purple">1</span>)
  }</code></pre>
<p class="p noindent para-continued" data-line="580"><span data-line="580"></span>Even though this function is not used in the specification, we declare
it <span data-line="581"></span><code class="code code1">ghost</code><span data-line="581"></span> to clarify that it is used only as part of the mathematical
reasoning and should be understood as a function in the mathematical
sense. It happens to be computable, but in general, it may not be. 
</p>
<p class="p indent" data-line="585"><span data-line="585"></span>We can add a second postcondition to our method, and a precondition to
assume that the counter starts at 0. Of course, we can expect to add
additional invariants to loops to help the verification of our
complexity property. 
 
<span data-line="590"></span><!-- inline-dafny Complexity/M3 --><span data-line="590"></span>
</p>
<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="592" data-line-first="593" style="display:block"><code data-line="593">  <span style="color:blue">trait</span> InsertionSort&lt;T(==)&gt; <span style="color:blue">extends</span> Comparable&lt;T&gt;, Measurable&lt;T&gt;, Sorted&lt;T&gt; {

    <span style="color:blue">method</span> InsertionSort(a: <span style="color:teal">array</span>&lt;T&gt;)
      <span style="color:purple">modifies</span> a, <span style="color:blue">this</span>
      <span style="color:purple">requires</span> comparisonCount == <span class="constant" style="color:purple">0</span>
      <span style="color:purple">ensures</span> Sorted(a)
      <span style="color:purple">ensures</span> comparisonCount &lt;= a.Length * a.Length
    {

      <span style="color:blue">for</span> i := <span class="constant" style="color:purple">0</span> to a.Length
        <span style="color:purple">invariant</span> Ordered(a,<span class="constant" style="color:purple">0</span>,i)
        <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
        <span style="color:purple">invariant</span> comparisonCount == i * a.Length - Sum(i)
      {
        <span style="color:blue">var</span> minValue := a[i];
        <span style="color:blue">var</span> minPos := i;
        <span style="color:blue">assert</span> comparisonCount == i * a.Length - Sum(i) + (i + <span class="constant" style="color:purple">1</span> - i) - <span class="constant" style="color:purple">1</span>;
        <span style="color:blue">for</span> j := i + <span class="constant" style="color:purple">1</span> to a.Length
          <span style="color:purple">invariant</span> minPos &lt; a.Length
          <span style="color:purple">invariant</span> a[minPos] == minValue
          <span style="color:purple">invariant</span> Preserved(a,<span class="constant" style="color:purple">0</span>,a.Length)
          <span style="color:purple">invariant</span> comparisonCount == i * a.Length - Sum(i) + (j - i) - <span class="constant" style="color:purple">1</span>
        {
          <span style="color:blue">label</span> L:
          <span style="color:blue">var</span> cmp := Ltm(a[j], minValue);
          <span style="color:blue">assert</span> a[..] == <span style="color:blue">old</span>@L(a[..]);
          <span style="color:blue">if</span> cmp {
            minValue := a[j];
            minPos := j;
          }
          <span style="color:blue">assert</span>(i * a.Length - Sum(i) + (j - i) - <span class="constant" style="color:purple">1</span>) + <span class="constant" style="color:purple">1</span> == i * a.Length - Sum(i) + ((j + <span class="constant" style="color:purple">1</span>) - i) - <span class="constant" style="color:purple">1</span>;
        }
        <span style="color:blue">if</span> i != minPos {
          a[i], a[minPos] := minValue, a[i];
        }
        <span style="color:blue">assert</span> comparisonCount == (i+<span class="constant" style="color:purple">1</span>) * a.Length - Sum(i+<span class="constant" style="color:purple">1</span>);
      }
    }

  }</code></pre>
<p class="p noindent para-continued" data-line="636"><span data-line="636"></span>In this case, verification required a little more information than
just the loop invariants. Note that we have added a few <span data-line="637"></span><code class="code code1">assert</code><span data-line="637"></span>
statements that can be understood as hints of a property that ought to
hold at the position where it is stated. The point of such assertions
is to break down the proof and provide hints to the ATP by stating
intermediate properties that can be potentially easier to verify but
will play a key role in the overall proof. Take <span data-line="642"></span><code class="code code1">assert
comparisonCount == (i+1) * a.Length - Sum(i+1);</code><span data-line="643"></span> for example. This is
letting the verifier know of a useful identity between <span data-line="644"></span><code class="code code1">Sum</code><span data-line="644"></span> and
<span data-line="645"></span><code class="code code1">comparisonCount</code><span data-line="645"></span>.
</p>
<p class="p indent" data-line="647"><span data-line="647"></span>Another example, probably much more mysterious, is <span data-line="647"></span><code class="code code1">assert a[..] ==
old@L(a[..]);</code><span data-line="648"></span>. It states that the values of the array are the same at
the point in the program labeled <span data-line="649"></span><code class="code code1">L</code><span data-line="649"></span> and the one where the assertion
is made. By default, the <span data-line="650"></span><code class="code code1">old</code><span data-line="650"></span> expression refers to the state of the
method at the beginning of execution, but it can be modulated to refer
to a specific line in the body of the statement.
</p>
<p class="p indent" data-line="654"><span data-line="654"></span>You may try to understand what these assertions mean and why they are
useful, but the point of this discussion isn<span data-line="655"></span>&#39;<span data-line="655"></span>t to understand how to
verify the complexity of insertion sort, but rather to address the
most important frustrations of new Dafny users: how do we know what
assertions to make and where? In hindsight, all these assertions might
seem true and relevant, but it doesn<span data-line="659"></span>&#39;<span data-line="659"></span>t say anything about how to come
up with them, and to new Dafny users, it might seem like a magic
incantation.
</p>
<p class="p indent" data-line="663"><span data-line="663"></span>It is crucial to understand that these are not, in fact, magic
incantation that only people trained as mathematicians can
spell. Dafny is not just a full-fledged programming language, it is
also a full-fledged <span data-line="666"></span><em class="em-star1">proof assistant</em><span data-line="666"></span>. There is a systematic way to
figure out how to convince Dafny that a result is true if it is indeed
the case. It may not always be trivial, and it requires some training,
but you can rest assured that if there is a proof, you ought to be
able to provide enough information for the verification.
</p>
<p class="p indent" data-line="672"><span data-line="672"></span>Consider again the obscure case of <span data-line="672"></span><code class="code code1">assert a[..] ==
old@L(a[..]);</code><span data-line="673"></span>. No-one could just guess that verification needs this
specific property at this specific place for the verification to
succeed, not even Dafny<span data-line="675"></span>&#39;<span data-line="675"></span>s creator. Without this assertion,
verification fails but assists you by providing a key piece of
information: invariant <span data-line="677"></span><code class="code code1">Preserved(a,0,a.Length)</code><span data-line="677"></span> could not be proved
to be maintained by the inner loop.
</p>
<p class="p indent" data-line="680"><span data-line="680"></span>Since it is an invariant, it should hold at any point within the loop,
so we can assert it in between every statement to see which one makes
the verification fail. You will find that it is statement <span data-line="682"></span><code class="code code1">var cmp :=
Ltm(a[j], minValue);</code><span data-line="683"></span> that prevents the verification from verifying
the invariant. Three possibilities:
</p>
<ul class="ul list-dash compact" data-line="686">
<li class="li ul-li list-dash-li compact-li" data-line="686"><span data-line="686"></span>The code is actually incorrect
</li>
<li class="li ul-li list-dash-li compact-li" data-line="687"><span data-line="687"></span>The invariant isn<span data-line="687"></span>&#39;<span data-line="687"></span>t actually one and our proof is wrong
</li>
<li class="li ul-li list-dash-li compact-li" data-line="688"><span data-line="688"></span>The verification needs some hint
</li></ul>

<p class="p noindent" data-line="690"><span data-line="690"></span>To some extent, it makes sense that the verification might need a
hint. When we call method <span data-line="691"></span><code class="code code1">Ltm</code><span data-line="691"></span>, how do we know that it is not going
to change array <span data-line="692"></span><code class="code code1">a</code><span data-line="692"></span>? Of course it is in a sense obvious since it is
clearly not mentioning <span data-line="693"></span><code class="code code1">a</code><span data-line="693"></span> but obvious doesn<span data-line="693"></span>&#39;<span data-line="693"></span>t cut it in formal
verification. Now, we did specify that the method modifies the field
but nothing else, so it should be the case that <span data-line="695"></span><code class="code code1">a</code><span data-line="695"></span> is left
unchanged. This is where it makes sense to assert <span data-line="696"></span><code class="code code1">a[..] ==
old@L(a[..]);</code><span data-line="697"></span> to double-check that the verification agrees. In this
case, not only does it agree, but it also turns out to be the hint the
verification needs ot succeed.
</p>
<p class="p indent" data-line="701"><span data-line="701"></span>One may feel like the verification should not have required such a
hint but ATPs are fundamentally bound to miss obvious facts every now
and then. It is not a bug of the verifier, merely an unfortunate and
perhaps unavoidable case of incompleteness of its proving capability. 
</p>
<p class="p indent" data-line="706"><span data-line="706"></span>We can finish our implementation by defining a class, making to
initialize the counter properly.
</p><!-- inline-dafny Complexity/M4 -->



<pre class="para-block pre-fenced pre-fenced3 language-dafnyx lang-dafnyx dafnyx colorized" data-line="711" data-line-first="712" style="display:block"><code data-line="712">  <span style="color:blue">class</span> Sort&lt;T(==)&gt; <span style="color:blue">extends</span> InsertionSort&lt;T&gt; {

    <span style="color:blue">const</span> CMP: (T,T) -&gt; <span style="color:teal">bool</span>

    <span style="color:blue">constructor</span>(cmp: (T,T) -&gt; <span style="color:teal">bool</span>)
      <span style="color:purple">ensures</span> CMP == cmp
      <span style="color:purple">ensures</span> comparisonCount == <span class="constant" style="color:purple">0</span>
    {
      CMP := cmp;
      comparisonCount := <span class="constant" style="color:purple">0</span>;
    }

    <span style="color:blue">function</span> Lt(x: T, y: T): <span style="color:teal">bool</span> {
      CMP(x,y)
    }

  }</code></pre><h2 id="sec-conclusion" class="h1" data-line="732" data-heading-depth="1" style="display:block"><span data-line="732"></span>Conclusion</h2>
<p class="p noindent" data-line="734"><span data-line="734"></span>Hopefully, this example gives a concrete idea of what program
specification and verification feels like, and shows that it is not
limited to toy academic languages. Proving the functional correctness
of insertion sort shows that even for such a non-trivial properties,
automation is good enough to keep the verification effort
low. Moreover, the complexity example shows that while more abstract
and mathematical properties may require more work, verification
remains doable. Because Dafny is not just a great programming language
but also a great proof assistant, one can learn systematic
methodologies to verify code.
</p>
<p class="p indent" data-line="745"><span data-line="745"></span>In the end, the only issue standing between you and writing verified
code isn<span data-line="746"></span>&#39;<span data-line="746"></span>t the difficulty of verification but rather a costs/benefits
analysis. If you have an existing application written in another
language and working well enough, it doesn<span data-line="748"></span>&#39;<span data-line="748"></span>t make sense to rewrite
everything in Dafny for some elusive mathematical certainty that your
code satisfies a specification which could also have its own
issues. This is where Dafny<span data-line="751"></span>&#39;<span data-line="751"></span>s second key feature, interoperability,
comes in, but this is another story<span data-line="752"></span>&#8230;<span data-line="752"></span>
</p><span data-line=""></span></div>
</body>

</html>
